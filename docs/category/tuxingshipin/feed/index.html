<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>图形视频 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/tuxingshipin/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Tue, 11 Jun 2019 06:44:14 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>图形视频 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>图像分割算法的优缺点比较</title>
		<link>https://uzzz.org/article/2941.html</link>
				<pubDate>Tue, 11 Jun 2019 06:44:14 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2941.html</guid>
				<description><![CDATA[本文章只做简单介绍各个分割方法，后续会对各个方法一一做详细介绍 数字图像处理常用的图像分割算法有： 基于阀值的分割方法。 基于边缘的分割方法。 基于区域的分割方法。 基于聚类分析的图像分割方法。 基于小波变换的分割方法。 基于数学形态学方法。 基于人工神经网络的方法。 基于遗传算法的方法。 阈值分割 1、原理 用一个或几个阈值将图像的灰度直方图分成几个类， 认为图像中灰度 值在同一类中的像素属于同一物体。（常用的二值分割） 2、优点 直接利用图像的灰度特性，所以计算简单、运算效率较高、速度快。 3、适用范围 相差很大的不同目标和背景能进行有效的分割。 4、缺点 对噪声敏感，对灰度差异不明显以及不同目标灰度值有重叠分割不明显，所以需要与其他方法进行结合。合适的阈值查找。 边缘分割 1、原理 通常不同的区域之间的边缘上像素灰度值的变化往往比较剧烈， 这是边缘检测方法得以实现的主要假设之一。常用灰度的一阶或二阶微分算子进行边缘检测。 2、优点 搜索检测的速度快，对边缘检测好。 3、适用范围 低噪声干扰，区域之间的性质差别很大（或则说边缘变化大）。 4、缺点 不能得到较好的区域结构，边缘检测时抗噪性和检测精度之间的矛盾。精度提高，则会牺牲抗噪性，反之。我们可以设置一个熵，取一个折中的办法，求取熵最大的时候的精度和抗噪性。 区域分割 1、原理 把具有某种相似性质的像索连通，从而构成最终的分割区域。它采用两种方法：分裂和合并 2、优点 有效地克服其他方法存在的图像分割空间小连续的缺点，有较好的区域特征。 3、适用范围 需得到具有区域结构的分割图。 4、缺点 容易造成图像的过度分割，将边缘检测与区域分割结合，可以得到良好的分割效果。 聚类分析的图像分割 1、原理 将图像空间中的像素用对应的特征空间点表示，根据它们在特征空间的聚集对特征空间进行分割，然后将它们映射回原图像空间，得到分割结果。它采用两种方法：K 均值、模糊 C 均值聚类(FCM)算法 2、优点 且 FCM 算法对初始参数极为敏感，有时需要人工干预参数的初始化以接近全局最优解，提高分割速度。 3、适用范围 适合图像中存在不确定性和模糊性。 4、缺点 传统 FCM 算法没有考虑空间信息，对噪声和灰度不均匀敏感。 聚类分析所要做的工作。 (1)、聚类的类数如何确定。 (2)、怎样确定聚类的有效性准则。 (3)、聚类中心的位置和特性事先不清楚时， 如何设置初始值。 (4)、运算的开销。 小波变换的分割 1、原理 将基于小波变换的阈值图像分割方法的基本思想是，首先由二进小波变换将图像的直方图分解为不同层次的小波系数，然后依据给定的分割准则和小波系数选择阈值门限，最后利用阈值标出图像分割的区域。 2、优点 空域和频域的局域变换，因而能有效地从信号中提取信息，通过伸缩和平移等运算功能对函数或信号进行多尺度分析，解决了傅立叶变换不能解决的许多问题。由于是频域操作，所以对噪声不敏感。 3、适用范围 用于边缘检测，可提取多尺度边缘，并可通过对图像奇异度的计算和估计来区分一些边缘的类型。 4、缺点 选取合适的滤波器 基于数学形态学方法 1、原理 利用一个称为结构元素的探针来收集图像的信息， 当探针在图像中不断的移动时， 不仅可根据图像各个部分间的相互关系来了解图像的结构特征， 而且利用数学形态学基本运算还可以构造出许多非常有效的图像处理与分析方法。 2、优点 定位效果好、分割精度高、抗噪声性能好 基本的形态运算是腐蚀与膨胀。 3、适用范围 可以用于抑制噪声、特性提取、边缘检测、图像分割等图像处理问题，处理灰度图像 4、缺点 图像处理后， 依然存在大量与目标不符的短线和孤立点。由于预处理工作的不彻底， 还需要进行一系列的基于点的开( 闭) 运算， 因此运算速度明显下降。克服这些缺陷，将是数学形态学以后的工作方向。 基于人工神经网络 1、原理 通过训练多层感知机来得到线性决策函数，然后用决策函数对像 素进行分类来达到分割的目的。 2、优点 解决图像中的噪声和不均匀问题。 3、适用范围 可以用于抑制噪声、特性提取、边缘检测、图像分割等图像处理问题，处理灰度图像 4、缺点 选择何种网络结构是这种方法要解决的主要问题。需要大量数据，速度非常慢，结构复杂，分割精度与数据量有关。 基于遗传算法的方法 1、原理 利用 GA 的全局寻优能力及对初始位置的不敏感特性， 可以改进图像分割的性能。 2、优点 很强的全局优化搜索能力。 3、适用范围 适用于阈值分割法以及区域生长法中，寻找全局最优。 4、缺点 其难点在于适应度函数的选择以及交叉概率和变异概率的确定。GA 还有可能收敛于局部最优。 声明 这是我自己看了一些论文和文章，从中的一些总结和摘抄，可能我的理解有误，希望大家多多提提宝贵的意见。而且我的语言能力不是太好，大家将就看看。哈哈]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h1><a id="_0"></a>本文章只做简单介绍各个分割方法，后续会对各个方法一一做详细介绍</h1>
<p>数字图像处理常用的图像分割算法有：</p>
<ol>
<li>基于阀值的分割方法。</li>
<li>基于边缘的分割方法。</li>
<li>基于区域的分割方法。</li>
<li>基于聚类分析的图像分割方法。</li>
<li>基于小波变换的分割方法。</li>
<li>基于数学形态学方法。</li>
<li>基于人工神经网络的方法。</li>
<li>基于遗传算法的方法。</li>
</ol>
<h1><a id="_15"></a>阈值分割</h1>
<p>1、原理<br /> 用一个或几个阈值将图像的灰度直方图分成几个类， 认为图像中灰度 值在同一类中的像素属于同一物体。（常用的二值分割）<br /> 2、优点<br /> 直接利用图像的灰度特性，所以计算简单、运算效率较高、速度快。<br /> 3、适用范围<br /> 相差很大的不同目标和背景能进行有效的分割。<br /> 4、缺点<br /> 对噪声敏感，对灰度差异不明显以及不同目标灰度值有重叠分割不明显，所以需要与其他方法进行结合。合适的阈值查找。</p>
<h1><a id="_25"></a>边缘分割</h1>
<p>1、原理<br /> 通常不同的区域之间的边缘上像素灰度值的变化往往比较剧烈， 这是边缘检测方法得以实现的主要假设之一。常用灰度的一阶或二阶微分算子进行边缘检测。<br /> 2、优点<br /> 搜索检测的速度快，对边缘检测好。<br /> 3、适用范围<br /> 低噪声干扰，区域之间的性质差别很大（或则说边缘变化大）。<br /> 4、缺点<br /> 不能得到较好的区域结构，边缘检测时抗噪性和检测精度之间的矛盾。精度提高，则会牺牲抗噪性，反之。我们可以设置一个熵，取一个折中的办法，求取熵最大的时候的精度和抗噪性。</p>
<h1><a id="_36"></a>区域分割</h1>
<p>1、原理<br /> 把具有某种相似性质的像索连通，从而构成最终的分割区域。它采用两种方法：分裂和合并<br /> 2、优点<br /> 有效地克服其他方法存在的图像分割空间小连续的缺点，有较好的区域特征。<br /> 3、适用范围<br /> 需得到具有区域结构的分割图。<br /> 4、缺点<br /> 容易造成图像的过度分割，将边缘检测与区域分割结合，可以得到良好的分割效果。</p>
<h1><a id="_47"></a>聚类分析的图像分割</h1>
<p>1、原理<br /> 将图像空间中的像素用对应的特征空间点表示，根据它们在特征空间的聚集对特征空间进行分割，然后将它们映射回原图像空间，得到分割结果。它采用两种方法：K 均值、模糊 C 均值聚类(FCM)算法<br /> 2、优点<br /> 且 FCM 算法对初始参数极为敏感，有时需要人工干预参数的初始化以接近全局最优解，提高分割速度。<br /> 3、适用范围<br /> 适合图像中存在不确定性和模糊性。<br /> 4、缺点<br /> 传统 FCM 算法没有考虑空间信息，对噪声和灰度不均匀敏感。<br /> 聚类分析所要做的工作。<br /> (1)、聚类的类数如何确定。<br /> (2)、怎样确定聚类的有效性准则。<br /> (3)、聚类中心的位置和特性事先不清楚时， 如何设置初始值。<br /> (4)、运算的开销。</p>
<h2><a id="_61"></a>小波变换的分割</h2>
<p>1、原理<br /> 将基于小波变换的阈值图像分割方法的基本思想是，首先由二进小波变换将图像的直方图分解为不同层次的小波系数，然后依据给定的分割准则和小波系数选择阈值门限，最后利用阈值标出图像分割的区域。<br /> 2、优点<br /> 空域和频域的局域变换，因而能有效地从信号中提取信息，通过伸缩和平移等运算功能对函数或信号进行多尺度分析，解决了傅立叶变换不能解决的许多问题。由于是频域操作，所以对噪声不敏感。<br /> 3、适用范围<br /> 用于边缘检测，可提取多尺度边缘，并可通过对图像奇异度的计算和估计来区分一些边缘的类型。<br /> 4、缺点<br /> 选取合适的滤波器</p>
<h1><a id="_71"></a>基于数学形态学方法</h1>
<p>1、原理<br /> 利用一个称为结构元素的探针来收集图像的信息， 当探针在图像中不断的移动时， 不仅可根据图像各个部分间的相互关系来了解图像的结构特征， 而且利用数学形态学基本运算还可以构造出许多非常有效的图像处理与分析方法。<br /> 2、优点<br /> 定位效果好、分割精度高、抗噪声性能好<br /> 基本的形态运算是腐蚀与膨胀。<br /> 3、适用范围<br /> 可以用于抑制噪声、特性提取、边缘检测、图像分割等图像处理问题，处理灰度图像</p>
<p>4、缺点<br /> 图像处理后， 依然存在大量与目标不符的短线和孤立点。由于预处理工作的不彻底， 还需要进行一系列的基于点的开( 闭) 运算， 因此运算速度明显下降。克服这些缺陷，将是数学形态学以后的工作方向。</p>
<h1><a id="_86"></a>基于人工神经网络</h1>
<p>1、原理<br /> 通过训练多层感知机来得到线性决策函数，然后用决策函数对像<br /> 素进行分类来达到分割的目的。<br /> 2、优点<br /> 解决图像中的噪声和不均匀问题。<br /> 3、适用范围<br /> 可以用于抑制噪声、特性提取、边缘检测、图像分割等图像处理问题，处理灰度图像</p>
<p>4、缺点<br /> 选择何种网络结构是这种方法要解决的主要问题。需要大量数据，速度非常慢，结构复杂，分割精度与数据量有关。</p>
<h1><a id="_101"></a>基于遗传算法的方法</h1>
<p>1、原理<br /> 利用 GA 的全局寻优能力及对初始位置的不敏感特性， 可以改进图像分割的性能。<br /> 2、优点<br /> 很强的全局优化搜索能力。<br /> 3、适用范围<br /> 适用于阈值分割法以及区域生长法中，寻找全局最优。</p>
<p>4、缺点<br /> 其难点在于适应度函数的选择以及交叉概率和变异概率的确定。GA 还有可能收敛于局部最优。</p>
<h1><a id="_115"></a>声明</h1>
<p>这是我自己看了一些论文和文章，从中的一些总结和摘抄，可能我的理解有误，希望大家多多提提宝贵的意见。而且我的语言能力不是太好，大家将就看看。哈哈</p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>ps高低频磨皮详细教学</title>
		<link>https://uzzz.org/article/2769.html</link>
				<pubDate>Sun, 26 May 2019 15:18:25 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2769.html</guid>
				<description><![CDATA[很多同学都知道高低频磨皮，其实高低频不仅可以用来磨皮肤，还可以用来磨头发，磨衣物上的褶皱等。操作方法有多种，但原理都一样，都是通过融合颜色及明暗对比再提取纹理达到一个降低反差并保留纹理的磨皮效果。所谓高低频，就是使用两个图层以不同的方式提取图像中的信息，这两个图层一个叫低频层一个叫高频层。这里给大家演示一下常用的三种操作方法。 &#160; 第一种： 复制两个原图-下方图层进行表面模糊（菜单栏滤镜-模糊-表面模糊，也可以用高斯模糊）-根据需要的融合效果设置半径与阈值（半径可以理解为力度，阈值可以理解为范围）-此层作为低频层。 &#160; 上方图层进行反相（Ctrl+I）-将不透明度改为50％。 3.合并可见图层作为高频层-关闭下方两个图层的可见性或直接删除-将高频层的混合模式改为线性光-进行表面模糊（参数需小于低频层的2~5倍） 好了，放大看下对比效果： 下面演示一下第二种操作方法，与第一种的原理及效果相同，只是操作方式有点区别。这次我们用高斯模糊代替表面模糊，两者只是模糊方式不同，不在所包括的操作方法内。 第二种： 还是复制两个图层-下方图层进行高斯模糊（菜单栏滤镜-模糊-高斯模糊，也可以用表面模糊）-半径设置到看不清瑕疵确仍有轮廓为止-此层为低频层。 上方图层应用低频层混合模式减去缩放2补偿值128（菜单栏图像-应用图像）-此层作为高频层。 3.高频层进行高斯模糊（理论上模糊的参数需要与低频层相同以最大程度的保留纹理，但也可以根据效果稍微小一点以增加力度）-混合模式改为线性光。 好了，这是两种操作方法，这两种比较繁琐，磨皮的力度较小，所保留的纹理较多，适合磨皮肤。 &#160; 下面我们演示第三种较快捷的方法，这种磨皮的力度较大，所保留的纹理较少，适合磨头发、褶皱等。这次我们用头发来做演示，当然如果对皮肤质感要求不高的话也可以用于皮肤。 第三种： 先看下原图： 复制一个图层反相-混合模式线性光。 &#160; &#160; 高反差保留（滤镜-其它-高反差保留）-参数设置到反差较明显的光影平整了即可。 高斯模糊（理论上模糊的参数需要与高反差保留的参数相同，但这里稍微小一点以增加力度）。注：磨头发及褶皱时不能用表面模糊。 好了，第三种就完成了。放大看下对比效果： 当然，磨完以后要建个蒙版擦一下不需要的部分，这个就不多说了。 但可能有些同学会觉得这个头发看上去不够光滑，下面我们稍微调整一下，在不影响头发磨皮效果的前提下增强下对比。 调整步骤： 建个曲线蒙版应用高光-调整蒙版增强对比（选中蒙版-菜单栏图像-调整-曲线）-蒙版进行高斯模糊（参数宁小不大）-回到曲线提亮高光。 再建一个曲线蒙版应用上个曲线的反相蒙版（选中上个曲线的蒙版后按住Alt键拖移至这个曲线的蒙版上，然后Ctrl+I反相。当然你也可以重新应用阴影再进行一次高斯模糊）-回到曲线降暗阴影。 最后别忘了将两个曲线建个组加个蒙版擦一下。 &#160; 欢迎大家一起学习交流&#160; &#160;Q：673187073&#160;&#160; &#160;&#160; &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p style="margin-left:0cm;">很多同学都知道高低频磨皮，其实高低频不仅可以用来磨皮肤，还可以用来磨头发，磨衣物上的褶皱等。操作方法有多种，但原理都一样，都是通过融合颜色及明暗对比再提取纹理达到一个降低反差并保留纹理的磨皮效果。所谓高低频，就是使用两个图层以不同的方式提取图像中的信息，这两个图层一个叫低频层一个叫高频层。这里给大家演示一下常用的三种操作方法。</p>
<p style="margin-left:0cm;">&nbsp;</p>
<p style="margin-left:0cm;">第一种：</p>
<ol>
<li>复制两个原图-下方图层进行表面模糊（菜单栏滤镜-模糊-表面模糊，也可以用高斯模糊）-根据需要的融合效果设置半径与阈值（半径可以理解为力度，阈值可以理解为范围）-此层作为低频层。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="888" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231635259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="894"></p>
<p style="margin-left:0cm;">&nbsp;</p>
<ol>
<li>上方图层进行反相（Ctrl+I）-将不透明度改为50％。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="853" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231635493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="891"></p>
<p style="margin-left:0cm;">3.合并可见图层作为高频层-关闭下方两个图层的可见性或直接删除-将高频层的混合模式改为线性光-进行表面模糊（参数需小于低频层的2~5倍）</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="888" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231644603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="891"></p>
<p style="margin-left:0cm;">好了，放大看下对比效果：</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="569" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052623164073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="802"></p>
<p style="margin-left:0cm;">下面演示一下第二种操作方法，与第一种的原理及效果相同，只是操作方式有点区别。这次我们用高斯模糊代替表面模糊，两者只是模糊方式不同，不在所包括的操作方法内。</p>
<p style="margin-left:0cm;">第二种：</p>
<ol>
<li>还是复制两个图层-下方图层进行高斯模糊（菜单栏滤镜-模糊-高斯模糊，也可以用表面模糊）-半径设置到看不清瑕疵确仍有轮廓为止-此层为低频层。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="853" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231640374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="897"></p>
<ol>
<li>上方图层应用低频层混合模式减去缩放2补偿值128（菜单栏图像-应用图像）-此层作为高频层。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="854" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231642627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="897"></p>
<p style="margin-left:0cm;">3.高频层进行高斯模糊（理论上模糊的参数需要与低频层相同以最大程度的保留纹理，但也可以根据效果稍微小一点以增加力度）-混合模式改为线性光。</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="852" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231645505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="899"></p>
<p style="margin-left:0cm;">好了，这是两种操作方法，这两种比较繁琐，磨皮的力度较小，所保留的纹理较多，适合磨皮肤。</p>
<p style="margin-left:0cm;">&nbsp;</p>
<p style="margin-left:0cm;">下面我们演示第三种较快捷的方法，这种磨皮的力度较大，所保留的纹理较少，适合磨头发、褶皱等。这次我们用头发来做演示，当然如果对皮肤质感要求不高的话也可以用于皮肤。</p>
<p style="margin-left:0cm;">第三种：</p>
<p style="margin-left:0cm;">先看下原图：</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="1200" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231635684.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="985"></p>
<ol>
<li>复制一个图层反相-混合模式线性光。</li>
</ol>
<p style="margin-left:0cm;">&nbsp;</p>
<p style="margin-left:0cm;">&nbsp;</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="855" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231643333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="797"></p>
<ol>
<li>高反差保留（滤镜-其它-高反差保留）-参数设置到反差较明显的光影平整了即可。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="852" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231644780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="796"></p>
<ol>
<li>高斯模糊（理论上模糊的参数需要与高反差保留的参数相同，但这里稍微小一点以增加力度）。注：磨头发及褶皱时不能用表面模糊。</li>
</ol>
<p style="margin-left:0cm;"><img alt="" class="has" height="852" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052623164447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="803"></p>
<p style="margin-left:0cm;">好了，第三种就完成了。放大看下对比效果：</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="886" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231647145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="1086"></p>
<p style="margin-left:0cm;">当然，磨完以后要建个蒙版擦一下不需要的部分，这个就不多说了。</p>
<p style="margin-left:0cm;">但可能有些同学会觉得这个头发看上去不够光滑，下面我们稍微调整一下，在不影响头发磨皮效果的前提下增强下对比。</p>
<p style="margin-left:0cm;">调整步骤：</p>
<ol>
<li>建个曲线蒙版应用高光-调整蒙版增强对比（选中蒙版-菜单栏图像-调整-曲线）-蒙版进行高斯模糊（参数宁小不大）-回到曲线提亮高光。</li>
<li>再建一个曲线蒙版应用上个曲线的反相蒙版（选中上个曲线的蒙版后按住Alt键拖移至这个曲线的蒙版上，然后Ctrl+I反相。当然你也可以重新应用阴影再进行一次高斯模糊）-回到曲线降暗阴影。</li>
<li>最后别忘了将两个曲线建个组加个蒙版擦一下。</li>
</ol>
<p style="margin-left:0cm;">&nbsp;</p>
<p style="margin-left:0cm;"><img alt="" class="has" height="830" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231637588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="1067"></p>
<p style="margin-left:0cm;"><img alt="" class="has" height="862" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231637384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="895"></p>
<p style="margin-left:0cm;"><img alt="" class="has" height="888" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052623164449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="765"></p>
<p style="margin-left:0cm;"><img alt="" class="has" height="892" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231644262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="769"><img alt="" class="has" height="882" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190526231647119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5neGlhb3l1Qks=,size_16,color_FFFFFF,t_70" width="985"></p>
<p style="margin-left:0cm;">欢迎大家一起学习交流&nbsp; &nbsp;Q：673187073&nbsp;&nbsp; &nbsp;&nbsp;</p>
<p style="margin-left:0cm;">&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>食品网页色彩和风格的讲解</title>
		<link>https://uzzz.org/article/2954.html</link>
				<pubDate>Wed, 08 May 2019 10:45:18 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2954.html</guid>
				<description><![CDATA[食品网页色彩和风格的讲解 （撰写时间：5月6日 作者：李梦熙） 首先来看看讲解的第一个网页： 这个网页的风格是利用插画来装饰整个页面，让整个页面丰富活跃起来，插画风格的网页会让内容更加的突出，让整个画面有种生动的感觉，就是内容过于太少，让用户无法了解更多的内容；色彩搭配它采用黑色作底色，用白色手绘图案作装饰和内容，还有就是用一些实体物品用插画的方式来点缀整个画面，这种小清新的设计很有新意。 下面的也是一个披萨网页，但和上面的插画风格完全不一样，它是采用图片做一些效果来当做背景，然后在图片的上方放一些介绍，比如这个食物的历史或由来和食物介绍、食物价格等。 每两个图片的中间都有白底隔开，在白底上放置一些菜品，和介绍，但是这个网页也用了插画，虽然不是用的很多，但是展现和别的网页有不一样的风格，黑白版块的插入突出里面的主要内容，让用户可以更好的了解本页面的内容。色彩搭配让人感觉很舒服，用黑白做主题色、利用酒红做点缀色。 下面的那个网页是有一半展示一半网页，网页采用的颜色搭配是黑绿搭配，这种颜色搭配很少见，但它搭配出来的效果还是挺好看的，上面做了个展示，把页面更好的展示出来，让用户直观的了解整个页面，网页的内容是以居中排版为主，用印花水墨嵌入背景来做背景的点缀，这个网页使用黑、绿色搭配，让整个画面都有一种清新的感觉。 风格有点像水墨画的风格。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>食品网页色彩和风格的讲解<br /> （撰写时间：5月6日 作者：李梦熙）<br /> 首先来看看讲解的第一个网页：<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190508184404999.png" alt="在这里插入图片描述"><br /> 这个网页的风格是利用插画来装饰整个页面，让整个页面丰富活跃起来，插画风格的网页会让内容更加的突出，让整个画面有种生动的感觉，就是内容过于太少，让用户无法了解更多的内容；色彩搭配它采用黑色作底色，用白色手绘图案作装饰和内容，还有就是用一些实体物品用插画的方式来点缀整个画面，这种小清新的设计很有新意。<br /> 下面的也是一个披萨网页，但和上面的插画风格完全不一样，它是采用图片做一些效果来当做背景，然后在图片的上方放一些介绍，比如这个食物的历史或由来和食物介绍、食物价格等。<br /> 每两个图片的中间都有白底隔开，在白底上放置一些菜品，和介绍，但是这个网页也用了插画，虽然不是用的很多，但是展现和别的网页有不一样的风格，黑白版块的插入突出里面的主要内容，让用户可以更好的了解本页面的内容。色彩搭配让人感觉很舒服，用黑白做主题色、利用酒红做点缀色。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190508184422981.png" alt="在这里插入图片描述"><br /> 下面的那个网页是有一半展示一半网页，网页采用的颜色搭配是黑绿搭配，这种颜色搭配很少见，但它搭配出来的效果还是挺好看的，上面做了个展示，把页面更好的展示出来，让用户直观的了解整个页面，网页的内容是以居中排版为主，用印花水墨嵌入背景来做背景的点缀，这个网页使用黑、绿色搭配，让整个画面都有一种清新的感觉。<br /> 风格有点像水墨画的风格。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190508184451232.png" alt="在这里插入图片描述"></p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>opengl学习笔记</title>
		<link>https://uzzz.org/article/2560.html</link>
				<pubDate>Wed, 24 Apr 2019 07:22:16 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2560.html</guid>
				<description><![CDATA[一、绘制方式。 绘制方式 方式 说明 网格线绘图方式（wireframe） 这种方式仅绘制三维物体的网格轮廓线 深度优先网格线绘图方式（depth_cued） 用网格线方式绘图，增加模拟人眼看物体一样，远处的物体比近处的物体要暗一些。 反走样网格线绘图方式（antialiased） 用网格线方式绘图，绘图时采用反走样技术以减少图形线条的参差不齐。 平面消隐绘图方式（flat_shade） 对模型的隐藏面进行消隐，对模型的平面单元按光照程度进行着色但不进行光滑处理。 光滑消隐绘图方式（smooth_shade） 对模型进行消隐按光照渲染着色的过程中再进行光滑处理，这种方式更接近于现实。 加阴影和纹理的绘图方式（shadows、textures） 在模型表面贴上纹理甚至于加上光照阴影，使得三维景观像照片一样。 运动模糊的绘图方式（motion_blured） 模拟物体运动时人眼观察所感觉的动感现象。 大气环境效果（atmosphere_effects） 在三维景观中加入如雾等大气环境效果。 深度域效果（depth_effects） 类似于照相机镜头效果，模型在聚焦点处清晰，反之则模糊。 二、OpenGL核心库 1、基本图元 几何图元类型和说明 类型 说明 GL_POINTS 单个顶点集 GL_LINES 多组双顶点线段 GL_POLYGON 单个简单填充凸多边形 GL_TRAINGLES 多组独立填充三角形 GL_QUADS 多组独立填充四边形 GL_LINE_STRIP 不闭合折线 GL_LINE_LOOP 闭合折线 GL_TRAINGLE_STRIP 线型连续填充三角形串 GL_TRAINGLE_FAN 扇形连续填充三角形串 GL_QUAD_STRIP 连续填充四边形串 &#160; &#160; &#160; 2、调用函数 调用函数 函数 说明 glVertex*() 设置顶点坐标 glColor*() 设置当前颜色 glIndex*() 设置当前颜色表 glNormal*() 设置法向坐标 glEvalCoord*() 产生坐标 glCallList(),glCallLists() 执行显示列表 glTexCoord*() 设置纹理坐标 glEdgeFlag*() 控制边界绘制 glMaterial*() 设置材质 例如绘制一个三角形： glBegin( GL_TRIANGLES ); glVertex3f( 0.0, 1.0, 0.0 ); glVertex3f( -1.0, -1.0, 0.0 ); glVertex3f( 1.0, -1.0, 0.0 ); glEnd(); 例如绘制一个矩形： glBegin( GL_QUADS ); glColor3f( 0.0, 1.0, 1.0&#160;); glVertex3f( 1.0, -1.0,&#160;&#160;0.0 ); glVertex3f( 1.0, -3.0, 0.0 ); glVertex3f( 2.0, -4.0, 0.0 ); glVertex3f( 2.0, -2.0, 0.0 ); glEnd(); &#160; 二、OpenGL变换 1、几何变换（视点变换、模型变换） 1）平移 void glTranslatef( GLfloat x, GLfloat y, GLfloat z ); &#160; &#160; &#160; x、y、z分别为沿三个轴向平移的偏移量。 &#160; &#160; &#160; 例如：glTranslatef( -20.0, 0.0, 0.0 );//在绘制点坐标基础上x轴平移-20 2）缩放 void glScalef( GLfloat x, GLfloat y, GLfloat z ); &#160; &#160; &#160; x、y、z分别为沿三个轴向缩放的比例因子。 &#160; &#160; &#160; 例如：glScalef( 1.5, 0.5, 1.0 );//x轴缩放1.5，y轴缩放0.5，z轴缩放1.0。 3）旋转 void glRoteatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z ); &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>一、绘制方式。</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;">
<caption>
    绘制方式<br />
   </caption>
<thead>
<tr>
<th scope="col">方式</th>
<th scope="col">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>网格线绘图方式（wireframe）</td>
<td>这种方式仅绘制三维物体的网格轮廓线</td>
</tr>
<tr>
<td>深度优先网格线绘图方式（depth_cued）</td>
<td>用网格线方式绘图，增加模拟人眼看物体一样，远处的物体比近处的物体要暗一些。</td>
</tr>
<tr>
<td>反走样网格线绘图方式（antialiased）</td>
<td>
<p>用网格线方式绘图，绘图时采用反走样技术以减少图形线条的参差不齐。</p>
</td>
</tr>
<tr>
<td>平面消隐绘图方式（flat_shade）</td>
<td>对模型的隐藏面进行消隐，对模型的平面单元按光照程度进行着色但不进行光滑处理。</td>
</tr>
<tr>
<td>光滑消隐绘图方式（smooth_shade）</td>
<td>对模型进行消隐按光照渲染着色的过程中再进行光滑处理，这种方式更接近于现实。</td>
</tr>
<tr>
<td>加阴影和纹理的绘图方式（shadows、textures）</td>
<td>在模型表面贴上纹理甚至于加上光照阴影，使得三维景观像照片一样。</td>
</tr>
<tr>
<td>运动模糊的绘图方式（motion_blured）</td>
<td>模拟物体运动时人眼观察所感觉的动感现象。</td>
</tr>
<tr>
<td>大气环境效果（atmosphere_effects）</td>
<td>在三维景观中加入如雾等大气环境效果。</td>
</tr>
<tr>
<td>深度域效果（depth_effects）</td>
<td>类似于照相机镜头效果，模型在聚焦点处清晰，反之则模糊。</td>
</tr>
</tbody>
</table>
<p>二、OpenGL核心库</p>
<p>1、基本图元</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;">
<caption>
    几何图元类型和说明<br />
   </caption>
<thead>
<tr>
<th scope="col">类型</th>
<th scope="col">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align:top;">GL_POINTS</td>
<td style="vertical-align:top;">单个顶点集</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_LINES</td>
<td style="vertical-align:top;">多组双顶点线段</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_POLYGON</td>
<td style="vertical-align:top;">单个简单填充凸多边形</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_TRAINGLES</td>
<td style="vertical-align:top;">多组独立填充三角形</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_QUADS</td>
<td style="vertical-align:top;">多组独立填充四边形</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_LINE_STRIP</td>
<td style="vertical-align:top;">不闭合折线</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_LINE_LOOP</td>
<td style="vertical-align:top;">闭合折线</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_TRAINGLE_STRIP</td>
<td style="vertical-align:top;">线型连续填充三角形串</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_TRAINGLE_FAN</td>
<td style="vertical-align:top;">扇形连续填充三角形串</td>
</tr>
<tr>
<td style="vertical-align:top;">GL_QUAD_STRIP</td>
<td style="vertical-align:top;">连续填充四边形串</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>2、调用函数</p>
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;" summary="glBegin()和glEnd()之间可调用的函数">
<caption>
    调用函数<br />
   </caption>
<tbody>
<tr>
<td>函数</td>
<td>说明</td>
</tr>
<tr>
<td style="vertical-align:top;">glVertex*()</td>
<td style="vertical-align:top;">设置顶点坐标</td>
</tr>
<tr>
<td style="vertical-align:top;">glColor*()</td>
<td style="vertical-align:top;">设置当前颜色</td>
</tr>
<tr>
<td style="vertical-align:top;">glIndex*()</td>
<td style="vertical-align:top;">设置当前颜色表</td>
</tr>
<tr>
<td style="vertical-align:top;">glNormal*()</td>
<td style="vertical-align:top;">设置法向坐标</td>
</tr>
<tr>
<td style="vertical-align:top;">glEvalCoord*()</td>
<td style="vertical-align:top;">产生坐标</td>
</tr>
<tr>
<td style="vertical-align:top;">glCallList(),glCallLists()</td>
<td style="vertical-align:top;">执行显示列表</td>
</tr>
<tr>
<td style="vertical-align:top;">glTexCoord*()</td>
<td style="vertical-align:top;">设置纹理坐标</td>
</tr>
<tr>
<td style="vertical-align:top;">glEdgeFlag*()</td>
<td style="vertical-align:top;">控制边界绘制</td>
</tr>
<tr>
<td style="vertical-align:top;">glMaterial*()</td>
<td style="vertical-align:top;">设置材质</td>
</tr>
</tbody>
</table>
<p>例如绘制一个三角形：<br /> glBegin( GL_TRIANGLES );<br /> glVertex3f( 0.0, 1.0, 0.0 );<br /> glVertex3f( -1.0, -1.0, 0.0 );<br /> glVertex3f( 1.0, -1.0, 0.0 );<br /> glEnd();<br /><img alt="" class="has" height="484" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426101920384.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="480"></p>
<p>例如绘制一个矩形：</p>
<p>glBegin( GL_QUADS );<br /> glColor3f( 0.0, 1.0, 1.0&nbsp;);<br /> glVertex3f( 1.0, -1.0,&nbsp;&nbsp;0.0 );<br /> glVertex3f( 1.0, -3.0, 0.0 );<br /> glVertex3f( 2.0, -4.0, 0.0 );<br /> glVertex3f( 2.0, -2.0, 0.0 );<br /> glEnd();</p>
<p><img alt="" class="has" height="480" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426101953141.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="465"></p>
<p>&nbsp;</p>
<p>二、OpenGL变换<br /> 1、几何变换（视点变换、模型变换）<br /> 1）平移 void glTranslatef( GLfloat x, GLfloat y, GLfloat z );<br /> &nbsp; &nbsp; &nbsp; x、y、z分别为沿三个轴向平移的偏移量。<br /> &nbsp; &nbsp; &nbsp; 例如：glTranslatef( -20.0, 0.0, 0.0 );//在绘制点坐标基础上x轴平移-20</p>
<p>2）缩放 void glScalef( GLfloat x, GLfloat y, GLfloat z );<br /> &nbsp; &nbsp; &nbsp; x、y、z分别为沿三个轴向缩放的比例因子。<br /> &nbsp; &nbsp; &nbsp; 例如：glScalef( 1.5, 0.5, 1.0 );//x轴缩放1.5，y轴缩放0.5，z轴缩放1.0。</p>
<p>3）旋转 void glRoteatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );<br /> &nbsp; &nbsp; &nbsp; angle表示从点(x, y, z)到原点的方向逆时针旋转的角度，x、y、z是旋转方向点坐标。<br /> &nbsp; &nbsp; &nbsp; 例如：glRotatef( 90.0, 0.0, 0.0, 1.0 );// 以( 0.0, 0.0, 1.0 )绕z轴正向旋转90度<br /><img alt="" class="has" height="498" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426101958114.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="479"></p>
<p>2、投影变换<br /> 1）正射投影：glOrtho<br /> 2）透视投影：glFrustum, gluPerspective</p>
<p>3、视口变换：glViewport</p>
<p>4、裁剪变换：glClipPlane</p>
<p>&nbsp;</p>
<p>三、OpenGL颜色<br /> &nbsp; &nbsp; glColor3f、glColor3d等。</p>
<p>&nbsp;</p>
<p>四、光照<br /> 1、创建光源<br /> 2、启动光照<br /> 3、明暗处理<br /> 4、材质</p>
<p> 实例：绘制粉色实心茶壶<br /> GLfloat mat_ambient[]={ 0.8, 0.8, 0.8, 1.0 };<br /> GLfloat mat_diffuse[]={ 0.8, 0.0, 0.8, 1.0 };<br /> GLfloat mat_specular[]={ 1.0, 0.0, 1.0, 1.0 };<br /> GLflaot mat_shininess[]={ 50.0 };</p>
<p>glMaterialfv( GL_FRONT, GL_AMBIENT, mat_ambient );<br /> glMaterialfv( GL_FRONT, GL_DIFFUSE, mat_diffuse);<br /> glMaterialfv( GL_FRONT, GL_SPECULAR, mat_specular);<br /> glMaterialfv( GL_FRONT, GL_SHININESS, mat_shininess);</p>
<p>GLfloat light_postion[]={ 1.0, 1.0, 1.0, 0.0 };<br /> glLightfv( GL_LIGHT0, GL_POSITION, light_position );</p>
<p>glEnable( GL_LIGHTING );<br /> glEnable( GL_LIGHT0 );<br /> glDepthFunc( GL_LESS );<br /> glEnable( GL_DEPTH_TEST );</p>
<p>glClear( GL_COLOR_BUFFER_BIT );<br /> glColor3f( 0.0, 1.0, 1.0 );<br /> glLoadIdentity();</p>
<p>glutSolidTeapot( 1.0 );<br /> glFlush();</p>
<p>图示 如下：<br /><img alt="" class="has" height="582" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426102014674.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="493"></p>
<p>&nbsp;</p>
<p>丝状茶壶：</p>
<p><img alt="" class="has" height="560" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426101937767.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="491"></p>
<p>圆：</p>
<p><img alt="" class="has" height="473" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426101946204.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="468"></p>
<p>&nbsp;</p>
<p>实心圆环：</p>
<p><img alt="" class="has" height="483" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426102003577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="477"></p>
<p>丝状圆环：</p>
<p><img alt="" class="has" height="434" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190426102009782.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODc3MjQ5,size_16,color_FFFFFF,t_70" width="461"></p>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>cv2伪彩色applyColorMap()函数</title>
		<link>https://uzzz.org/article/2823.html</link>
				<pubDate>Sun, 09 Dec 2018 06:19:39 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2823.html</guid>
				<description><![CDATA[本文主要介绍cv2模块中的伪彩色applyColorMap()函数。 引用自：https://blog.csdn.net/u013381011/article/details/78341861 colormap（色度图） 假设我们想在地图上显示美国不同地区的温度。我们可以把美国地图上的温度数据叠加为灰度图像——较暗的区域代表较冷的温度，更明亮的区域代表较热的区域。这样的表现不仅令人难以置信，而且代表了两个重要的原因。首先，人类视觉系统没有被优化来测量灰度强度的微小变化。我们能更好地感知颜色的变化。第二，我们用不同的颜色代表不同的意思。用蓝色和较温暖的温度用红色表示较冷的温度更有意义。 温度数据只是一个例子，但还有其他几个数据是单值（灰度）的情况，但将其转换为彩色数据以实现可视化是有意义的。用伪彩色更好地显示数据的其他例子是高度、压力、密度、湿度等等。 在OpenCV中使用applycolormap（伪彩色函数） OpenCV的定义12种colormap（色度图），可以应用于灰度图像，使用函数applycolormap产生伪彩色图像。让我们很快看到如何将色度图的一种模式colormap_jet应用到一幅图像中。 下面是示例代码： import cv2 import numpy as np def colormap_name(id): switcher = { 0 : "COLORMAP_AUTUMN", 1 : "COLORMAP_BONE", 2 : "COLORMAP_JET", 3 : "COLORMAP_WINTER", 4 : "COLORMAP_RAINBOW", 5 : "COLORMAP_OCEAN", 6 : "COLORMAP_SUMMER", 7 : "COLORMAP_SPRING", 8 : "COLORMAP_COOL", 9 : "COLORMAP_HSV", 10: "COLORMAP_PINK", 11: "COLORMAP_HOT" } return switcher.get(id, 'NONE') img = cv2.imread('./pluto.jpg', cv2.IMREAD_GRAYSCALE) im_out = np.zeros((600, 800, 3), np.uint8) for i in range(0, 4): for j in range(0, 3): k = i + j * 4 im_color = cv2.applyColorMap(img, k) cv2.putText(im_color, colormap_name(k), (30, 180), cv2.FONT_HERSHEY_DUPLEX, 0.5, (255, 255, 255),1) ix200 = i * 200 jx200 = j * 200 im_out[jx200: jx200 + 200, ix200: ix200 + 200, :] = im_color cv2.imwrite('result.jpg', im_out) cv2.imshow('result', im_out) cv2.waitKey(0) cv2.destroyAllWindows() 测试图片： 测试结果：]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>本文主要介绍cv2模块中的伪彩色applyColorMap()函数。</p>
<blockquote>
<p>引用自：<a href="https://blog.csdn.net/u013381011/article/details/78341861" rel="nofollow" data-token="6f71129238e77acd1e6eb6f99f55e247">https://blog.csdn.net/u013381011/article/details/78341861</a></p>
<p>colormap（色度图）<br /> 假设我们想在地图上显示美国不同地区的温度。我们可以把美国地图上的温度数据叠加为灰度图像——较暗的区域代表较冷的温度，更明亮的区域代表较热的区域。这样的表现不仅令人难以置信，而且代表了两个重要的原因。首先，人类视觉系统没有被优化来测量灰度强度的微小变化。我们能更好地感知颜色的变化。第二，我们用不同的颜色代表不同的意思。用蓝色和较温暖的温度用红色表示较冷的温度更有意义。<br /> 温度数据只是一个例子，但还有其他几个数据是单值（灰度）的情况，但将其转换为彩色数据以实现可视化是有意义的。用伪彩色更好地显示数据的其他例子是高度、压力、密度、湿度等等。<br /> 在OpenCV中使用applycolormap（伪彩色函数）<br /> OpenCV的定义12种colormap（色度图），可以应用于灰度图像，使用函数applycolormap产生伪彩色图像。让我们很快看到如何将色度图的一种模式colormap_jet应用到一幅图像中。</p>
</blockquote>
<p>下面是示例代码：</p>
<pre class="has">
<code>import cv2
import numpy as np

def colormap_name(id):
    switcher = {
       0 : "COLORMAP_AUTUMN",
        1 : "COLORMAP_BONE",
        2 : "COLORMAP_JET",
        3 : "COLORMAP_WINTER",
        4 : "COLORMAP_RAINBOW",
        5 : "COLORMAP_OCEAN",
        6 : "COLORMAP_SUMMER",
        7 : "COLORMAP_SPRING",
        8 : "COLORMAP_COOL",
        9 : "COLORMAP_HSV",
        10: "COLORMAP_PINK",
        11: "COLORMAP_HOT" 
    }
    return switcher.get(id, 'NONE')

img = cv2.imread('./pluto.jpg', cv2.IMREAD_GRAYSCALE)
im_out = np.zeros((600, 800, 3), np.uint8)

for i in range(0, 4):
    for j in range(0, 3):
        k = i + j * 4
        im_color = cv2.applyColorMap(img, k)
        cv2.putText(im_color, colormap_name(k), (30, 180),
                   cv2.FONT_HERSHEY_DUPLEX, 0.5, (255, 255, 255),1)
        ix200 = i * 200
        jx200 = j * 200
        im_out[jx200: jx200 + 200, ix200: ix200 + 200, :] = im_color

cv2.imwrite('result.jpg', im_out)

cv2.imshow('result', im_out)
cv2.waitKey(0)
cv2.destroyAllWindows()</code></pre>
<p>测试图片：</p>
<p><img alt="" class="has" height="200" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181209141931591.jpg" width="200"></p>
<p>测试结果：</p>
<p><img alt="" class="has" height="600" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181209141928819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTYxMTE5Ng==,size_16,color_FFFFFF,t_70" width="800"></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>opencv 两路视频 保存avi 输出yuv</title>
		<link>https://uzzz.org/article/3083.html</link>
				<pubDate>Mon, 03 Dec 2018 08:32:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3083.html</guid>
				<description><![CDATA[opencv版本：3.4.1 编译工具：vs2015 说明： 两路视频：一路为网络摄像头，一路为PC usb摄像头 保存avi：根据条件切换不同视频源保存到同一个avi文件 输出yun:根据条件切换不同视频源，输出yuv作为后续使用。 #include &#60;opencv2/highgui/highgui.hpp&#62; #include &#60;opencv2/imgproc/imgproc.hpp&#62; #include &#60;opencv2/core/core.hpp&#62; using namespace cv; using namespace std; int main(int argc, char *argv[]) { VideoCapture videoInput("rtsp://X.X.X.X:554"); VideoCapture videoInput2(0); if (!videoInput.isOpened() &#124;&#124; !videoInput2.isOpened()) { return -1; } float fpsInput = 25; //获取帧率 float pauseInput = 1000 / fpsInput; //设置帧间隔 Mat frame; int w = videoInput.get(CV_CAP_PROP_FRAME_WIDTH) &#62;= videoInput2.get(CV_CAP_PROP_FRAME_WIDTH) ? videoInput2.get(CV_CAP_PROP_FRAME_WIDTH) : videoInput.get(CV_CAP_PROP_FRAME_WIDTH); int h = videoInput.get(CV_CAP_PROP_FRAME_HEIGHT) &#62;= videoInput2.get(CV_CAP_PROP_FRAME_HEIGHT) ? videoInput2.get(CV_CAP_PROP_FRAME_HEIGHT) : videoInput.get(CV_CAP_PROP_FRAME_HEIGHT); //Size videoSize = Size(videoInput.get(CV_CAP_PROP_FRAME_WIDTH), videoInput.get(CV_CAP_PROP_FRAME_HEIGHT)); Size videoSize = Size(w, h); string videoPath1 = "D:\\videoRecordPIM1.avi"; int fourcc1 = CV_FOURCC('P', 'I', 'M', '1'); VideoWriter videoOutput1(videoPath1, fourcc1, fpsInput, videoSize, true); string videoPath2 = "D:\\videoRecordMJPG.avi"; int fourcc2 = CV_FOURCC('M', 'J', 'P', 'G'); VideoWriter videoOutput2(videoPath2, fourcc2, fpsInput, videoSize, true); string videoPath3 = "D:\\videoRecordMP42.avi"; int fourcc3 = CV_FOURCC('M', 'P', '4', '2'); VideoWriter videoOutput3(videoPath3, fourcc3, fpsInput, videoSize, true); string videoPath4 = "D:\\videoRecordDIV3.avi"; int fourcc4 = CV_FOURCC('D', 'I', 'V', '3'); VideoWriter videoOutput4(videoPath4, fourcc4, fpsInput, videoSize, true); string videoPath5 = "D:\\videoRecordDIVX.avi"; int fourcc5 = CV_FOURCC('D', 'I', 'V', 'X'); VideoWriter videoOutput5(videoPath5, fourcc5, fpsInput, videoSize, true); string videoPath8 = "D:\\videoRecordFLV1.avi"; int fourcc8 = CV_FOURCC('F', 'L', 'V', '1'); VideoWriter videoOutput8(videoPath8, fourcc8,]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>opencv版本：3.4.1</p>
<p>编译工具：vs2015</p>
<p>说明：</p>
<p>两路视频：一路为网络摄像头，一路为PC usb摄像头</p>
<p>保存avi：根据条件切换不同视频源保存到同一个avi文件</p>
<p>输出yun:根据条件切换不同视频源，输出yuv作为后续使用。</p>
<hr>
<pre class="has">
<code>#include &lt;opencv2/highgui/highgui.hpp&gt;  
#include &lt;opencv2/imgproc/imgproc.hpp&gt;  
#include &lt;opencv2/core/core.hpp&gt; 

using namespace cv;
using namespace std;

int main(int argc, char *argv[])
{
	VideoCapture videoInput("rtsp://X.X.X.X:554");
	VideoCapture videoInput2(0);
	if (!videoInput.isOpened() || !videoInput2.isOpened())
	{
		return -1;
	}
	float fpsInput = 25; //获取帧率
	float pauseInput = 1000 / fpsInput;  //设置帧间隔
	Mat frame;
	int w = videoInput.get(CV_CAP_PROP_FRAME_WIDTH) &gt;= videoInput2.get(CV_CAP_PROP_FRAME_WIDTH) ? videoInput2.get(CV_CAP_PROP_FRAME_WIDTH) : videoInput.get(CV_CAP_PROP_FRAME_WIDTH);
	int h = videoInput.get(CV_CAP_PROP_FRAME_HEIGHT) &gt;= videoInput2.get(CV_CAP_PROP_FRAME_HEIGHT) ? videoInput2.get(CV_CAP_PROP_FRAME_HEIGHT) : videoInput.get(CV_CAP_PROP_FRAME_HEIGHT);

	//Size videoSize = Size(videoInput.get(CV_CAP_PROP_FRAME_WIDTH), videoInput.get(CV_CAP_PROP_FRAME_HEIGHT));
	Size videoSize = Size(w, h);

	string videoPath1 = "D:\\videoRecordPIM1.avi";
	int fourcc1 = CV_FOURCC('P', 'I', 'M', '1');
	VideoWriter videoOutput1(videoPath1, fourcc1, fpsInput, videoSize, true);

	string videoPath2 = "D:\\videoRecordMJPG.avi";
	int fourcc2 = CV_FOURCC('M', 'J', 'P', 'G');
	VideoWriter videoOutput2(videoPath2, fourcc2, fpsInput, videoSize, true);

	string videoPath3 = "D:\\videoRecordMP42.avi";
	int fourcc3 = CV_FOURCC('M', 'P', '4', '2');
	VideoWriter videoOutput3(videoPath3, fourcc3, fpsInput, videoSize, true);

	string videoPath4 = "D:\\videoRecordDIV3.avi";
	int fourcc4 = CV_FOURCC('D', 'I', 'V', '3');
	VideoWriter videoOutput4(videoPath4, fourcc4, fpsInput, videoSize, true);

	string videoPath5 = "D:\\videoRecordDIVX.avi";
	int fourcc5 = CV_FOURCC('D', 'I', 'V', 'X');
	VideoWriter videoOutput5(videoPath5, fourcc5, fpsInput, videoSize, true);

	string videoPath8 = "D:\\videoRecordFLV1.avi";
	int fourcc8 = CV_FOURCC('F', 'L', 'V', '1');
	VideoWriter videoOutput8(videoPath8, fourcc8, fpsInput, videoSize, true);

	if (!videoOutput1.isOpened())
	{
		return -1;
	}
	if (!videoOutput2.isOpened())
	{
		return -1;
	}
	if (!videoOutput3.isOpened())
	{
		return -1;
	}
	if (!videoOutput4.isOpened())
	{
		return -1;
	}
	if (!videoOutput5.isOpened())
	{
		return -1;
	}

	if (!videoOutput8.isOpened())
	{
		return -1;
	}
	int bufLen = w*h * 3 / 2;
	unsigned char* pYuvBuf = new unsigned char[bufLen];
	FILE* pFileOut = fopen("D:\\result.yuv", "w+");
	if (!pFileOut)
	{
		printf("pFileOut open error \n");
		system("pause");
		exit(-1);
	}
	int count = 0;
	Rect rect2 = {};
	rect2.x = 0;
	rect2.y = 0;
	rect2.width = w;
	rect2.height = h;

	while (true)
	{
		//切换视频源条件
		if (++count &lt; 100)
		{
			videoInput &gt;&gt; frame;
		}
		else if(count &lt; 150)
		{
			videoInput2 &gt;&gt; frame;
		}
		else
		{
			break;
		}

		if (frame.empty() || waitKey(30) == 27)
		{
			break;
		}
		//视频源分辨率不一样，则取小的分辨率
		//Mat image_roi = frame(rect2);
		Size dsize = Size(w, h);
		Mat image_roi = Mat(dsize, CV_32S);
		resize(frame, image_roi, dsize);

		videoOutput1 &lt;&lt; image_roi;
		videoOutput2 &lt;&lt; image_roi;
		videoOutput3 &lt;&lt; image_roi;
		videoOutput4 &lt;&lt; image_roi;
		videoOutput5 &lt;&lt; image_roi;
		videoOutput8 &lt;&lt; image_roi;
		imshow("Video", image_roi);
		cv::Mat yuvImg;
		//BGR转为YUV
		cv::cvtColor(image_roi, yuvImg, CV_BGR2YUV_I420);
		memcpy(pYuvBuf, yuvImg.data, bufLen*sizeof(unsigned char));
		fwrite(pYuvBuf, bufLen*sizeof(unsigned char), 1, pFileOut);

	}
	fclose(pFileOut);
	//waitKey();
	return 0;
}
</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>OpenCV&#8212;如何将彩色图像分通道输出（4）</title>
		<link>https://uzzz.org/article/3054.html</link>
				<pubDate>Mon, 03 Dec 2018 07:25:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3054.html</guid>
				<description><![CDATA[附代码如下： import cv2 as cv import numpy as np def ch(): src = cv.imread("D:/matplotlib/0.jpg") h,w,ch = np.shape(src) bgr = cv.split(src) cv.imshow("blue",bgr[0]) cv.imshow("green",bgr[1]) cv.imshow("red",bgr[2]) print(h,w,ch) cv.waitKey(0) cv.destroyAllWindows() ch() 运行效果： 代码解释： import cv2 as cv import numpy as np def ch(): src = cv.imread("D:/matplotlib/0.jpg") h,w,ch = np.shape(src) bgr = cv.split(src) #将彩色图像拆分成单个通道 cv.imshow("blue",bgr[0]) cv.imshow("green",bgr[1]) cv.imshow("red",bgr[2]) #分别显示每个通道的图像 print(h,w,ch) cv.waitKey(0) cv.destroyAllWindows() ch() &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>附代码如下：</p>
<pre>
<code class="language-html hljs">import cv2 as cv
import numpy as np
def ch():
    src = cv.imread("D:/matplotlib/0.jpg")
    h,w,ch = np.shape(src)
    bgr = cv.split(src)
    cv.imshow("blue",bgr[0])
    cv.imshow("green",bgr[1])
    cv.imshow("red",bgr[2])
    print(h,w,ch)
    cv.waitKey(0)
    cv.destroyAllWindows()
ch()</code></pre>
<p>运行效果：</p>
<p><img alt="" class="has" height="512" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181203152352178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N5MjAxNzMwODEyNzc=,size_16,color_FFFFFF,t_70" width="1200"></p>
<p>代码解释：</p>
<pre>
<code class="language-html hljs">import cv2 as cv
import numpy as np
def ch():
    src = cv.imread("D:/matplotlib/0.jpg")
    h,w,ch = np.shape(src)
    bgr = cv.split(src)
    #将彩色图像拆分成单个通道
    cv.imshow("blue",bgr[0])
    cv.imshow("green",bgr[1])
    cv.imshow("red",bgr[2])
    #分别显示每个通道的图像
    print(h,w,ch)
    cv.waitKey(0)
    cv.destroyAllWindows()
ch()</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>【图像处理】一种低光照图像的亮度提升方法（Adaptive Local Tone Mapping Based on Retinex for High Dynamic Range Images）</title>
		<link>https://uzzz.org/article/2520.html</link>
				<pubDate>Thu, 15 Nov 2018 13:25:11 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图像处理]]></category>
		<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2520.html</guid>
				<description><![CDATA[【fishing-pan：https://blog.csdn.net/u013921430 转载请注明出处】 前言   在实际的拍照过程中，常常会遇到，光线不足的情况。这时候单反用户一般会调大感光度，调大光圈，以让照片整体更清晰，更亮。那么如果照片已经被拍的很暗了，怎么办呢？这时候我们可以利用算法来提升图像整体的光照情况，让图像更清晰。   2013年这篇《Adaptive Local Tone Mapping Based on Retinex for High Dynamic Range Images》发表在了IEEE上，如题目所说，文章提到将高动态图像在低动态范围显示设备上进行显式时，会面临信息丢失的问题。因此结合传统的CENTER/SURROUND RETINEX 技术提出了全局自适应和局部自适应的HDR实现过程，对HDR image 进行色调映射。而文中的全局自适应方法对于低照度图像具有很好的照度提升效果。作者将他的Matlab脚本上传到了Github，有兴趣的可以点击这里去查看。 全局自适应原理   全局自适应方法的原理很简单，就是两个公式； L g ( x , y ) = l o g ( L w ( x , y ) / L w ˉ + 1 ) l o g ( L w m a x / L w ˉ + 1 ) L_{g}(x,y)=\frac{log(L_{w}(x,y)/\bar{L_{w}}+1)}{log(L_{wmax}/\bar{L_{w}}+1)} Lg​(x,y)=log(Lwmax​/Lw​ˉ​+1)log(Lw​(x,y)/Lw​ˉ​+1)​   上述式子中， L g ( x , y ) L_{g}(x,y) Lg​(x,y) 代表全局自适应处理的输出结果； L w ( x , y ) L_{w}(x,y) Lw​(x,y) 表示输入图像的亮度值； L w m a x L_{wmax} Lwmax​ 表示输入图像亮度的最大值； L w ˉ \bar{L_{w}} Lw​ˉ​ 表示输入图像的亮度值的对数平均值；由以下公式求得； L w ˉ = e x p ( 1 m ∗ n ∑ l o g ( σ + L w ( x , y ) ) ) \bar{L_{w}}=exp\left ( \frac{1}{m*n}\sum log(\sigma +L_{w}(x,y))\right ) Lw​ˉ​=exp(m∗n1​∑log(σ+Lw​(x,y)))   其中， m ∗ n m*n m∗n 代表图像的尺寸。 σ \sigma σ 是一个很小的值，为了防止遇到图像中亮度为0的黑点的情况；   文中提到“随着对数均值趋近于高值，函数的形状从对数趋势转换为线性趋势，因此对低对数均值的图像具有更好的提升效果。”这个方法利用到了图像的对数均值，这就是自适应的体现。   我在Matlab中分别简单的画了一下曲线，发现在对数均值比较大的时候曲线确实非常接近直线。 代码&#38;结果    我根据自己的理解以及作者的Matlab脚本，分别利用OpenCV实现了全局自适应方法。两者有很多细节不一样，结果也有一些差异；    首先是作者的matlab 代码； function outval = ALTM_Retinex(I) II = im2double(I); Ir=double(II(:,:,1)); Ig=double(II(:,:,2)); Ib=double(II(:,:,3)); % Global Adaptation Lw = 0.299 * Ir + 0.587 * Ig + 0.114 *]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-github-gist">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h3><a id="fishingpanhttpsblogcsdnnetu013921430__0"></a><strong>【fishing-pan：https://blog.csdn.net/u013921430 转载请注明出处】</strong></h3>
<h2><a id="_1"></a>前言</h2>
<p>  在实际的拍照过程中，常常会遇到，光线不足的情况。这时候单反用户一般会调大感光度，调大光圈，以让照片整体更清晰，更亮。那么如果照片已经被拍的很暗了，怎么办呢？这时候我们可以利用算法来提升图像整体的光照情况，让图像更清晰。</p>
<p>  2013年这篇《<a href="https://ieeexplore.ieee.org/abstract/document/6486837/metrics#metrics" rel="nofollow" data-token="54c0c92010719ed15009770d966a90eb">Adaptive Local Tone Mapping Based on Retinex for High Dynamic Range Images</a>》发表在了IEEE上，如题目所说，文章提到将高动态图像在低动态范围显示设备上进行显式时，会面临信息丢失的问题。因此结合传统的CENTER/SURROUND RETINEX 技术提出了全局自适应和局部自适应的HDR实现过程，对HDR image 进行色调映射。而文中的全局自适应方法对于低照度图像具有很好的照度提升效果。作者将他的Matlab脚本上传到了Github，有兴趣的可以点击<a href="https://github.com/IsaacChanghau/OptimizedImageEnhance/tree/master/matlab/ALTMRetinex" rel="nofollow" data-token="91de1e2117350982d4aa4d896c09396e">这里</a>去查看。</p>
<h2><a id="_6"></a>全局自适应原理</h2>
<p>  全局自适应方法的原理很简单，就是两个公式；<br /> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"></p>
<math>
        <semantics><br />
         <mrow><br />
          <msub><br />
           <mi><br />
            L<br />
           </mi><br />
           <mi><br />
            g<br />
           </mi><br />
          </msub><br />
          <mo><br />
           (<br />
          </mo><br />
          <mi><br />
           x<br />
          </mi><br />
          <mo separator="true"><br />
           ,<br />
          </mo><br />
          <mi><br />
           y<br />
          </mi><br />
          <mo><br />
           )<br />
          </mo><br />
          <mo><br />
           =<br />
          </mo><br />
          <mfrac><br />
           <mrow><br />
            <mi><br />
             l<br />
            </mi><br />
            <mi><br />
             o<br />
            </mi><br />
            <mi><br />
             g<br />
            </mi><br />
            <mo><br />
             (<br />
            </mo><br />
            <msub><br />
             <mi><br />
              L<br />
             </mi><br />
             <mi><br />
              w<br />
             </mi><br />
            </msub><br />
            <mo><br />
             (<br />
            </mo><br />
            <mi><br />
             x<br />
            </mi><br />
            <mo separator="true"><br />
             ,<br />
            </mo><br />
            <mi><br />
             y<br />
            </mi><br />
            <mo><br />
             )<br />
            </mo><br />
            <mi mathvariant="normal"><br />
             /<br />
            </mi><br />
            <mover accent="true"><br />
             <msub><br />
              <mi><br />
               L<br />
              </mi><br />
              <mi><br />
               w<br />
              </mi><br />
             </msub><br />
             <mo><br />
              ˉ<br />
             </mo><br />
            </mover><br />
            <mo><br />
             +<br />
            </mo><br />
            <mn><br />
             1<br />
            </mn><br />
            <mo><br />
             )<br />
            </mo><br />
           </mrow><br />
           <mrow><br />
            <mi><br />
             l<br />
            </mi><br />
            <mi><br />
             o<br />
            </mi><br />
            <mi><br />
             g<br />
            </mi><br />
            <mo><br />
             (<br />
            </mo><br />
            <msub><br />
             <mi><br />
              L<br />
             </mi><br />
             <mrow><br />
              <mi><br />
               w<br />
              </mi><br />
              <mi><br />
               m<br />
              </mi><br />
              <mi><br />
               a<br />
              </mi><br />
              <mi><br />
               x<br />
              </mi><br />
             </mrow><br />
            </msub><br />
            <mi mathvariant="normal"><br />
             /<br />
            </mi><br />
            <mover accent="true"><br />
             <msub><br />
              <mi><br />
               L<br />
              </mi><br />
              <mi><br />
               w<br />
              </mi><br />
             </msub><br />
             <mo><br />
              ˉ<br />
             </mo><br />
            </mover><br />
            <mo><br />
             +<br />
            </mo><br />
            <mn><br />
             1<br />
            </mn><br />
            <mo><br />
             )<br />
            </mo><br />
           </mrow><br />
          </mfrac><br />
         </mrow><br />
         <annotation encoding="application/x-tex"><br />
          L_{g}(x,y)=\frac{log(L_{w}(x,y)/\bar{L_{w}}+1)}{log(L_{wmax}/\bar{L_{w}}+1)}<br />
         </annotation><br />
        </semantics><br />
       </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.45722em; vertical-align: -0.96011em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.49711em;"><span class="" style="top: -2.28989em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord">/</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.82011em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.25em;">ˉ</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mord">/</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.82011em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.25em;">ˉ</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.96011em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br />   上述式子中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <msub><br />
          <mi><br />
           L<br />
          </mi><br />
          <mi><br />
           g<br />
          </mi><br />
         </msub><br />
         <mo><br />
          (<br />
         </mo><br />
         <mi><br />
          x<br />
         </mi><br />
         <mo separator="true"><br />
          ,<br />
         </mo><br />
         <mi><br />
          y<br />
         </mi><br />
         <mo><br />
          )<br />
         </mo><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         L_{g}(x,y)<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.03611em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span></span></span></span></span> 代表全局自适应处理的输出结果；<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <msub><br />
          <mi><br />
           L<br />
          </mi><br />
          <mi><br />
           w<br />
          </mi><br />
         </msub><br />
         <mo><br />
          (<br />
         </mo><br />
         <mi><br />
          x<br />
         </mi><br />
         <mo separator="true"><br />
          ,<br />
         </mo><br />
         <mi><br />
          y<br />
         </mi><br />
         <mo><br />
          )<br />
         </mo><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         L_{w}(x,y)<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span></span></span></span></span> 表示输入图像的亮度值；<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <msub><br />
          <mi><br />
           L<br />
          </mi><br />
          <mrow><br />
           <mi><br />
            w<br />
           </mi><br />
           <mi><br />
            m<br />
           </mi><br />
           <mi><br />
            a<br />
           </mi><br />
           <mi><br />
            x<br />
           </mi><br />
          </mrow><br />
         </msub><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         L_{wmax}<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span><span class="mord mathit mtight">m</span><span class="mord mathit mtight">a</span><span class="mord mathit mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 表示输入图像亮度的最大值；<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <mover accent="true"><br />
          <msub><br />
           <mi><br />
            L<br />
           </mi><br />
           <mi><br />
            w<br />
           </mi><br />
          </msub><br />
          <mo><br />
           ˉ<br />
          </mo><br />
         </mover><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         \bar{L_{w}}<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.97011em; vertical-align: -0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.82011em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.25em;">ˉ</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span> 表示输入图像的亮度值的对数平均值；由以下公式求得；<br /> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"></p>
<math>
        <semantics><br />
         <mrow><br />
          <mover accent="true"><br />
           <msub><br />
            <mi><br />
             L<br />
            </mi><br />
            <mi><br />
             w<br />
            </mi><br />
           </msub><br />
           <mo><br />
            ˉ<br />
           </mo><br />
          </mover><br />
          <mo><br />
           =<br />
          </mo><br />
          <mi><br />
           e<br />
          </mi><br />
          <mi><br />
           x<br />
          </mi><br />
          <mi><br />
           p<br />
          </mi><br />
          <mrow><br />
           <mo fence="true"><br />
            (<br />
           </mo><br />
           <mfrac><br />
            <mn><br />
             1<br />
            </mn><br />
            <mrow><br />
             <mi><br />
              m<br />
             </mi><br />
             <mo><br />
              ∗<br />
             </mo><br />
             <mi><br />
              n<br />
             </mi><br />
            </mrow><br />
           </mfrac><br />
           <mo><br />
            ∑<br />
           </mo><br />
           <mi><br />
            l<br />
           </mi><br />
           <mi><br />
            o<br />
           </mi><br />
           <mi><br />
            g<br />
           </mi><br />
           <mo><br />
            (<br />
           </mo><br />
           <mi><br />
            σ<br />
           </mi><br />
           <mo><br />
            +<br />
           </mo><br />
           <msub><br />
            <mi><br />
             L<br />
            </mi><br />
            <mi><br />
             w<br />
            </mi><br />
           </msub><br />
           <mo><br />
            (<br />
           </mo><br />
           <mi><br />
            x<br />
           </mi><br />
           <mo separator="true"><br />
            ,<br />
           </mo><br />
           <mi><br />
            y<br />
           </mi><br />
           <mo><br />
            )<br />
           </mo><br />
           <mo><br />
            )<br />
           </mo><br />
           <mo fence="true"><br />
            )<br />
           </mo><br />
          </mrow><br />
         </mrow><br />
         <annotation encoding="application/x-tex"><br />
          \bar{L_{w}}=exp\left ( \frac{1}{m*n}\sum log(\sigma +L_{w}(x,y))\right )<br />
         </annotation><br />
        </semantics><br />
       </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.97011em; vertical-align: -0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.82011em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -3.25233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.25em;">ˉ</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.40003em; vertical-align: -0.95003em;"></span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mord mathit">p</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathit">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord mathit">n</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mop op-symbol large-op" style="position: relative; top: -5e-06em;">∑</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.03588em;">σ</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></span><br />   其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <mi><br />
          m<br />
         </mi><br />
         <mo><br />
          ∗<br />
         </mo><br />
         <mi><br />
          n<br />
         </mi><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         m*n<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.46528em; vertical-align: 0em;"></span><span class="mord mathit">m</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">n</span></span></span></span></span> 代表图像的尺寸。<span class="katex--inline"><span class="katex"><span class="katex-mathml"></p>
<math>
       <semantics><br />
        <mrow><br />
         <mi><br />
          σ<br />
         </mi><br />
        </mrow><br />
        <annotation encoding="application/x-tex"><br />
         \sigma<br />
        </annotation><br />
       </semantics><br />
      </math>
<p></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">σ</span></span></span></span></span> 是一个很小的值，为了防止遇到图像中亮度为0的黑点的情况；</p>
<p>  文中提到“随着对数均值趋近于高值，函数的形状从对数趋势转换为线性趋势，因此对低对数均值的图像具有更好的提升效果。”这个方法利用到了图像的对数均值，这就是自适应的体现。</p>
<p>  我在Matlab中分别简单的画了一下曲线，发现在对数均值比较大的时候曲线确实非常接近直线。<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181115212155245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MjE0MzA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><a id="_20"></a>代码&amp;结果</h2>
<p>   我根据自己的理解以及作者的Matlab脚本，分别利用OpenCV实现了全局自适应方法。两者有很多细节不一样，结果也有一些差异；<br />    首先是作者的matlab 代码；</p>
<pre><code class="prism language-cpp">function outval <span class="token operator">=</span> <span class="token function">ALTM_Retinex</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span>
II <span class="token operator">=</span> <span class="token function">im2double</span><span class="token punctuation">(</span>I<span class="token punctuation">)</span><span class="token punctuation">;</span>
Ir<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">II</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Ig<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">II</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Ib<span class="token operator">=</span><span class="token keyword">double</span><span class="token punctuation">(</span><span class="token function">II</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span> Global Adaptation
Lw <span class="token operator">=</span> <span class="token number">0.299</span> <span class="token operator">*</span> Ir <span class="token operator">+</span> <span class="token number">0.587</span> <span class="token operator">*</span> Ig <span class="token operator">+</span> <span class="token number">0.114</span> <span class="token operator">*</span> Ib<span class="token punctuation">;</span><span class="token operator">%</span> input world luminance values
Lwmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>Lw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span> the maximum luminance value
<span class="token punctuation">[</span>m<span class="token punctuation">,</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>Lw<span class="token punctuation">)</span><span class="token punctuation">;</span>
Lwaver <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.001</span> <span class="token operator">+</span> Lw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>m <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">%</span> log<span class="token operator">-</span>average luminance
Lg <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span>Lw <span class="token operator">/</span> Lwaver <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">log</span><span class="token punctuation">(</span>Lwmax <span class="token operator">/</span> Lwaver <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gain <span class="token operator">=</span> Lg <span class="token punctuation">.</span><span class="token operator">/</span> Lw<span class="token punctuation">;</span>
<span class="token function">gain</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>Lw <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
outval <span class="token operator">=</span> <span class="token function">cat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> gain <span class="token punctuation">.</span><span class="token operator">*</span> Ir<span class="token punctuation">,</span> gain <span class="token punctuation">.</span><span class="token operator">*</span> Ig<span class="token punctuation">,</span> gain <span class="token punctuation">.</span><span class="token operator">*</span> Ib<span class="token punctuation">)</span><span class="token punctuation">;</span>
figure<span class="token punctuation">;</span>
<span class="token function">imshow</span><span class="token punctuation">(</span>outval<span class="token punctuation">)</span>
</code></pre>
<p>   接着是我参考作者提供的脚本实现的C++ 代码</p>
<pre><code class="prism language-cpp"><span class="token comment">//-------------------------------</span>
<span class="token comment">//函数名：adaptHDR；参照作者脚本实现</span>
<span class="token comment">//函数功能：全局自适应光照度提升</span>
<span class="token comment">//参数：Mat &amp;scr，输入图像</span>
<span class="token comment">//参数：Mat &amp;dst，输出图像</span>
<span class="token comment">//------------------------------</span>
<span class="token keyword">bool</span> <span class="token function">adaptHDR</span><span class="token punctuation">(</span>Mat <span class="token operator">&amp;</span>scr<span class="token punctuation">,</span> Mat <span class="token operator">&amp;</span>dst<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>scr<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token comment">//判断图像是否被正确读取；</span>
	<span class="token punctuation">{</span>
		cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"输入图像有误"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> row <span class="token operator">=</span> scr<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>
	<span class="token keyword">int</span> col <span class="token operator">=</span> scr<span class="token punctuation">.</span>cols<span class="token punctuation">;</span>


	Mat ycc<span class="token punctuation">;</span>                        <span class="token comment">//转换空间到YUV；</span>
	<span class="token function">cvtColor</span><span class="token punctuation">(</span>scr<span class="token punctuation">,</span> ycc<span class="token punctuation">,</span> COLOR_RGB2YUV<span class="token punctuation">)</span><span class="token punctuation">;</span>

	vector<span class="token operator">&lt;</span>Mat<span class="token operator">&gt;</span> <span class="token function">channels</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//分离通道，取channels[0]；</span>
	<span class="token function">split</span><span class="token punctuation">(</span>ycc<span class="token punctuation">,</span> channels<span class="token punctuation">)</span><span class="token punctuation">;</span>


	Mat <span class="token function">Luminance</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> CV_32FC1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			Luminance<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token operator">/</span> <span class="token number">255</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>


	<span class="token keyword">double</span> log_Ave <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                 <span class="token comment">//求对数均值</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.001</span> <span class="token operator">+</span> Luminance<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	log_Ave <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> <span class="token punctuation">(</span>row<span class="token operator">*</span>col<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">double</span> MaxValue<span class="token punctuation">,</span> MinValue<span class="token punctuation">;</span>      <span class="token comment">//获取亮度最大值为MaxValue；</span>
	<span class="token function">minMaxLoc</span><span class="token punctuation">(</span>Luminance<span class="token punctuation">,</span> <span class="token operator">&amp;</span>MinValue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>MaxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

	Mat hdr_L <span class="token punctuation">(</span>row<span class="token punctuation">,</span>col<span class="token punctuation">,</span>CV_32FC1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> Luminance<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> log_Ave<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> MaxValue <span class="token operator">/</span> log_Ave<span class="token punctuation">)</span><span class="token punctuation">;</span>


			<span class="token keyword">if</span> <span class="token punctuation">(</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">//对应作者代码中的gain = Lg ./ Lw;gain(find(Lw == 0)) = 0; </span>
			<span class="token punctuation">{</span>
				hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span>
			<span class="token punctuation">{</span>
				hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">/</span><span class="token operator">=</span> Luminance<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	vector<span class="token operator">&lt;</span>Mat<span class="token operator">&gt;</span> rgb_channels<span class="token punctuation">;</span>        <span class="token comment">//分别对RGB三个通道进行提升</span>
	<span class="token function">split</span><span class="token punctuation">(</span>scr<span class="token punctuation">,</span> rgb_channels<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			<span class="token keyword">int</span> r <span class="token operator">=</span> rgb_channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">*</span>hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> r<span class="token operator">&gt;</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span>r <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
			rgb_channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>

			<span class="token keyword">int</span> g <span class="token operator">=</span> rgb_channels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">*</span>hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>g<span class="token operator">&gt;</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span> g <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
			rgb_channels<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> g<span class="token punctuation">;</span>

			<span class="token keyword">int</span> b <span class="token operator">=</span> rgb_channels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">*</span>hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token operator">&gt;</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span> b <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
			rgb_channels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token function">merge</span><span class="token punctuation">(</span>rgb_channels<span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>  最后是我自己根据自己的理解实现代码</p>
<pre><code class="prism language-cpp"><span class="token comment">//-------------------------------</span>
<span class="token comment">//函数名：my_AdaptHDR；自己理解实现</span>
<span class="token comment">//函数功能：全局自适应光照度提升</span>
<span class="token comment">//参数：Mat &amp;scr，输入图像</span>
<span class="token comment">//参数：Mat &amp;dst，输出图像</span>
<span class="token comment">//------------------------------</span>

<span class="token keyword">bool</span> <span class="token function">my_AdaptHDR</span><span class="token punctuation">(</span>Mat <span class="token operator">&amp;</span>scr<span class="token punctuation">,</span> Mat <span class="token operator">&amp;</span>dst<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>scr<span class="token punctuation">.</span>data<span class="token punctuation">)</span>  <span class="token comment">//判断图像是否被正确读取；</span>
	<span class="token punctuation">{</span>
		cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"输入图像有误"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">int</span> row <span class="token operator">=</span> scr<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>
	<span class="token keyword">int</span> col <span class="token operator">=</span> scr<span class="token punctuation">.</span>cols<span class="token punctuation">;</span>


	Mat ycc<span class="token punctuation">;</span>                        <span class="token comment">//转换空间到YUV；</span>
	<span class="token function">cvtColor</span><span class="token punctuation">(</span>scr<span class="token punctuation">,</span> ycc<span class="token punctuation">,</span> COLOR_RGB2YUV<span class="token punctuation">)</span><span class="token punctuation">;</span>

	vector<span class="token operator">&lt;</span>Mat<span class="token operator">&gt;</span> <span class="token function">channels</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//分离通道，取channels[0]；</span>
	<span class="token function">split</span><span class="token punctuation">(</span>ycc<span class="token punctuation">,</span> channels<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token keyword">double</span> log_Ave <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>   <span class="token comment">//求对数均值</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0.001</span> <span class="token operator">+</span> channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	log_Ave <span class="token operator">=</span> <span class="token function">exp</span><span class="token punctuation">(</span>sum <span class="token operator">/</span> <span class="token punctuation">(</span>row<span class="token operator">*</span>col<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token keyword">double</span> MaxValue<span class="token punctuation">,</span> MinValue<span class="token punctuation">;</span>      <span class="token comment">//获取亮度最大值为MaxValue；</span>
	<span class="token function">minMaxLoc</span><span class="token punctuation">(</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>MinValue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>MaxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>

	Mat <span class="token function">hdr_L</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> CV_32FC1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> log_Ave<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> MaxValue <span class="token operator">/</span> log_Ave<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">double</span> L_MaxValue<span class="token punctuation">,</span> L_MinValue<span class="token punctuation">;</span>            <span class="token comment">//获取亮度最大值为MaxValue；</span>
	<span class="token function">minMaxLoc</span><span class="token punctuation">(</span>hdr_L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>L_MinValue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>L_MaxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> row<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token comment">//对亮度通道进行提升；</span>
	<span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>at<span class="token operator">&lt;</span>uchar<span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">255</span> <span class="token operator">*</span> <span class="token punctuation">(</span>hdr_L<span class="token punctuation">.</span>at<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">-</span> L_MinValue<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>L_MaxValue <span class="token operator">-</span> L_MinValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token function">merge</span><span class="token punctuation">(</span>channels<span class="token punctuation">,</span> ycc<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cvtColor</span><span class="token punctuation">(</span>ycc<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> COLOR_YUV2RGB<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>   两种思路的区别主要在于，我的方法是先把图像重RGB空间转换到YUV空间，然后对亮度进行提升，然后转换回RGB空间。这样做有一个问题，只提升了图像的亮度，而没有提高色度和浓度，图像会显得很亮，但是色彩不够鲜艳。而从作者提供的代码的思路来看，他用新得到的图像亮度除以原始图像亮度，得到一个亮度增益，然后将这个增益附加在每个颜色通道上。这样做三通道可以得到同样程度的亮度增强，但是这种方法可能会让图像色彩过饱和。</p>
<p>  来看看结果；<br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181115211326335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MjE0MzA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181115211339183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MjE0MzA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br /> <img src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181115211430283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM5MjE0MzA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><a id="_213"></a>总结</h2>
<p>   到底谁的思路好，我觉得我还是尊重作者的思路。但是也许有些情况下，我的方法会取得更好的效果，也可能存在更好的思路。但是最主要的方法还是在上面的两个公式中。而作者在文中主要介绍的是局部的映射方法，全局自适应是为后面做局部自适应进行铺垫的，当然，这篇博客中，不会讲到局部的方法了。</p>
<p>   对于低照度图像的计处理，我并不在行，这也是第一次接触，有些原理上面的东西还没摸清楚，只是觉得有意思就去实现了一下，有些不足的地方，还请大家指针（指正）。</p>
<h2><a id="_218"></a>参考</h2>
<blockquote>
<ol>
<li>
<p><a href="https://ieeexplore.ieee.org/abstract/document/6486837/metrics#metrics" rel="nofollow" data-token="54c0c92010719ed15009770d966a90eb">Ahn H, Keum B, Kim D, et al. Adaptive local tone mapping based on retinex for high dynamic range images[C]//Consumer Electronics<br /> (ICCE), 2013 IEEE International Conference on. IEEE, 2013:<br /> 153-156.</a></p>
</li>
<li>
<p>https://github.com/IsaacChanghau/OptimizedImageEnhance/tree/master/matlab/ALTMRetinex</p>
</li>
</ol>
</blockquote></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>关于opencv更改摄像头参数（帧率，分辨率，曝光度……）的几个问题</title>
		<link>https://uzzz.org/article/3253.html</link>
				<pubDate>Mon, 24 Sep 2018 02:17:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>
		<category><![CDATA[opencv]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3253.html</guid>
				<description><![CDATA[1，适用于VideoCapture打开的摄像头 VideoCapture capture(0); 设置摄像头参数&#160;不要随意修改 capture.set(CV_CAP_PROP_FRAME_WIDTH, 1080);//宽度 capture.set(CV_CAP_PROP_FRAME_HEIGHT, 960);//高度 capture.set(CV_CAP_PROP_FPS, 30);//帧率 帧/秒 capture.set(CV_CAP_PROP_BRIGHTNESS, 1);//亮度&#160; capture.set(CV_CAP_PROP_CONTRAST,40);//对比度 40 capture.set(CV_CAP_PROP_SATURATION, 50);//饱和度 50 capture.set(CV_CAP_PROP_HUE, 50);//色调 50 capture.set(CV_CAP_PROP_EXPOSURE, 50);//曝光 50 获取摄像头参数 得到摄像头的参数 capture.get(CV_CAP_PROP_FRAME_WIDTH); capture.get(CV_CAP_PROP_FRAME_HEIGHT); capture.get(CV_CAP_PROP_FPS); capture.get(CV_CAP_PROP_BRIGHTNESS); capture.get(CV_CAP_PROP_CONTRAST); capture.get(CV_CAP_PROP_SATURATION); capture.get(CV_CAP_PROP_HUE); capture.get(CV_CAP_PROP_EXPOSURE); 获取视频参数： capture.get(CV_CAP_PROP_FRAME_COUNT);//视频帧数&#160; 然后你会发现除了个别参数你能更改之外（如曝光度），大分布你是不能更改的，甚至都没办法得到，这种并不适用 2，不做开发，只是单纯的更改 那么推荐一个软件，amcap，百度网盘链接，https://pan.baidu.com/s/1pL8nq0V#list/path=%2F，很简单很容易上手。 补，现在突然想起来我的一个学长告诉我的，利用这个软件调节摄像头的曝光度，可以改变帧率，且摄像头会记住曝光度的设置（其他特性就没有这个特点）。-2019.3.12 3，修改opencv的文件，不过效果可能和第一个差不多 大概是在opencv的这个位置，找一下，modules/highgui/src/cap_v4l.cpp，里面有关于参数的设置，位置比较靠前，可以搜索，也可以直接找到 大致在200多行 4，v4l2 下面是我找到的一篇参考，可以突破帧率的限制，当然前提是摄像头支持 https://blog.csdn.net/c406495762/article/details/72732135 目前只适用于Linux系统，本人试验过，120帧的摄像头在只打开摄像头时可以达到100帧左右，设置的图片分辨率越小，能达到的帧率越高 #include &#60;unistd.h&#62; #include &#60;error.h&#62; #include &#60;errno.h&#62; #include &#60;fcntl.h&#62; #include &#60;sys/ioctl.h&#62; #include &#60;sys/types.h&#62; #include &#60;pthread.h&#62; #include &#60;linux/videodev2.h&#62; #include &#60;sys/mman.h&#62; #include &#60;opencv2/core/core.hpp&#62; #include &#60;opencv2/highgui/highgui.hpp&#62; #include &#60;stdio.h&#62; #include &#60;stdlib.h&#62; #include &#60;string.h&#62; #include &#60;time.h&#62; #include "opencv2/highgui/highgui.hpp" #include "opencv2/imgproc/imgproc.hpp" #include &#60;math.h&#62; #include &#60;iostream&#62; #include &#60;iomanip&#62; #include &#60;string&#62; using namespace std; using namespace cv; #define CLEAR(x) memset(&#38;(x), 0, sizeof(x)) #define IMAGEWIDTH 3264 #define IMAGEHEIGHT 2448 #define WINDOW_NAME1 "【原始图】" //为窗口标题定义的宏 #define WINDOW_NAME2 "【图像轮廓】" //为窗口标题定义的宏 Mat g_srcImage; Mat g_grayImage; int g_nThresh = 90; int g_nMaxThresh = 255; RNG g_rng(12345); Mat g_cannyMat_output; vector&#60;vector&#60;Point&#62; &#62; g_vContours; vector&#60;Vec4i&#62; g_vHierarchy; Point point1[100000]; Point point2[100000]; Point point3[100000]; int ii,iii; int flag2 = 0;//避障用 float number = 0; int fps=0; class V4L2Capture { public: V4L2Capture(char *devName, int width, int height); virtual ~V4L2Capture(); int openDevice(); int closeDevice(); int initDevice(); int startCapture(); int stopCapture(); int freeBuffers(); int getFrame(void **,size_t]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h2 id="1%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8EVideoCapture%E6%89%93%E5%BC%80%E7%9A%84%E6%91%84%E5%83%8F%E5%A4%B4">1，适用于VideoCapture打开的摄像头</h2>
<p>VideoCapture capture(0); 设置摄像头参数&nbsp;不要随意修改</p>
<p>capture.set(CV_CAP_PROP_FRAME_WIDTH, 1080);//宽度</p>
<p>capture.set(CV_CAP_PROP_FRAME_HEIGHT, 960);//高度</p>
<p>capture.set(CV_CAP_PROP_FPS, 30);//帧率 帧/秒</p>
<p>capture.set(CV_CAP_PROP_BRIGHTNESS, 1);//亮度&nbsp;</p>
<p>capture.set(CV_CAP_PROP_CONTRAST,40);//对比度 40</p>
<p>capture.set(CV_CAP_PROP_SATURATION, 50);//饱和度 50</p>
<p>capture.set(CV_CAP_PROP_HUE, 50);//色调 50</p>
<p>capture.set(CV_CAP_PROP_EXPOSURE, 50);//曝光 50 获取摄像头参数</p>
<p>得到摄像头的参数</p>
<p>capture.get(CV_CAP_PROP_FRAME_WIDTH);</p>
<p>capture.get(CV_CAP_PROP_FRAME_HEIGHT);</p>
<p>capture.get(CV_CAP_PROP_FPS);</p>
<p>capture.get(CV_CAP_PROP_BRIGHTNESS);</p>
<p>capture.get(CV_CAP_PROP_CONTRAST);</p>
<p>capture.get(CV_CAP_PROP_SATURATION);</p>
<p>capture.get(CV_CAP_PROP_HUE);</p>
<p>capture.get(CV_CAP_PROP_EXPOSURE); 获取视频参数：</p>
<p>capture.get(CV_CAP_PROP_FRAME_COUNT);//视频帧数&nbsp;</p>
<p>然后你会发现除了个别参数你能更改之外（如曝光度），大分布你是不能更改的，甚至都没办法得到，这种并不适用</p>
<h2 id="2%EF%BC%8C%E4%B8%8D%E5%81%9A%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AA%E6%98%AF%E5%8D%95%E7%BA%AF%E7%9A%84%E6%9B%B4%E6%94%B9">2，不做开发，只是单纯的更改</h2>
<p>那么推荐一个软件，amcap，百度网盘链接，<a href="https://pan.baidu.com/s/1pL8nq0V#list/path=%2F" rel="nofollow" data-token="97b1bbe118ed4b783bd17ce84fcafa7a">https://pan.baidu.com/s/1pL8nq0V#list/path=%2F</a>，很简单很容易上手。</p>
<p>补，现在突然想起来我的一个学长告诉我的，利用这个软件调节摄像头的曝光度，可以改变帧率，且摄像头会记住曝光度的设置（其他特性就没有这个特点）。-2019.3.12</p>
<h2>3，修改opencv的文件，不过效果可能和第一个差不多</h2>
<p>大概是在opencv的这个位置，找一下，modules/highgui/src/cap_v4l.cpp，里面有关于参数的设置，位置比较靠前，可以搜索，也可以直接找到</p>
<p>大致在200多行<img alt="" class="has" height="149" src="https://uzshare.com/_p?https://img-blog.csdn.net/2018092414270643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTkxNjA4Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="419"></p>
<h2>4，v4l2</h2>
<p>下面是我找到的一篇参考，可以突破帧率的限制，当然前提是摄像头支持</p>
<p><a href="https://blog.csdn.net/c406495762/article/details/72732135" rel="nofollow" data-token="1cbfb6830f56eecd337b0d11183c5bd7">https://blog.csdn.net/c406495762/article/details/72732135</a></p>
<p>目前只适用于Linux系统，本人试验过，120帧的摄像头在只打开摄像头时可以达到100帧左右，设置的图片分辨率越小，能达到的帧率越高</p>
<pre class="has">
<code class="language-cpp">#include &lt;unistd.h&gt;
#include &lt;error.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;pthread.h&gt;
#include &lt;linux/videodev2.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include &lt;math.h&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;

using namespace std;
using namespace cv;
#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))

#define IMAGEWIDTH 3264
#define IMAGEHEIGHT 2448

#define WINDOW_NAME1 "【原始图】"					//为窗口标题定义的宏
#define WINDOW_NAME2 "【图像轮廓】"        //为窗口标题定义的宏

Mat g_srcImage; Mat g_grayImage;
int g_nThresh = 90;
int g_nMaxThresh = 255;
RNG g_rng(12345);
Mat g_cannyMat_output;
vector&lt;vector&lt;Point&gt; &gt; g_vContours;
vector&lt;Vec4i&gt; g_vHierarchy;
Point point1[100000];
Point point2[100000];
Point point3[100000];
int ii,iii;
int flag2 = 0;//避障用
float number = 0;
int fps=0;


class V4L2Capture {
public:
    V4L2Capture(char *devName, int width, int height);
    virtual ~V4L2Capture();

    int openDevice();
    int closeDevice();
    int initDevice();
    int startCapture();
    int stopCapture();
    int freeBuffers();
    int getFrame(void **,size_t *);
    int backFrame();
    static void test();

private:
    int initBuffers();

    struct cam_buffer
    {
        void* start;
        unsigned int length;
    };
    char *devName;
    int capW;
    int capH;
    int fd_cam;
    cam_buffer *buffers;
    unsigned int n_buffers;
    int frameIndex;
};

V4L2Capture::V4L2Capture(char *devName, int width, int height) {
    // TODO Auto-generated constructor stub
    this-&gt;devName = devName;
    this-&gt;fd_cam = -1;
    this-&gt;buffers = NULL;
    this-&gt;n_buffers = 0;
    this-&gt;frameIndex = -1;
    this-&gt;capW=width;
    this-&gt;capH=height;
}

V4L2Capture::~V4L2Capture() {
    // TODO Auto-generated destructor stub
}

int V4L2Capture::openDevice() {
    /*设备的打开*/
    printf("video dev : %s\n", devName);
    fd_cam = open(devName, O_RDWR);
    if (fd_cam &lt; 0) {
        perror("Can't open video device");
    }
    return 0;
}

int V4L2Capture::closeDevice() {
    if (fd_cam &gt; 0) {
        int ret = 0;
        if ((ret = close(fd_cam)) &lt; 0) {
            perror("Can't close video device");
        }
        return 0;
    } else {
        return -1;
    }
}

int V4L2Capture::initDevice() {
    int ret;
    struct v4l2_capability cam_cap;		//显示设备信息
    struct v4l2_cropcap cam_cropcap;	//设置摄像头的捕捉能力
    struct v4l2_fmtdesc cam_fmtdesc;	//查询所有支持的格式：VIDIOC_ENUM_FMT
    struct v4l2_crop cam_crop;			//图像的缩放
    struct v4l2_format cam_format;		//设置摄像头的视频制式、帧格式等

    /* 使用IOCTL命令VIDIOC_QUERYCAP，获取摄像头的基本信息*/
    ret = ioctl(fd_cam, VIDIOC_QUERYCAP, &amp;cam_cap);
    if (ret &lt; 0) {
        perror("Can't get device information: VIDIOCGCAP");
    }
    printf(
            "Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\n",
            cam_cap.driver, cam_cap.card, cam_cap.bus_info,
            (cam_cap.version &gt;&gt; 16) &amp; 0XFF, (cam_cap.version &gt;&gt; 8) &amp; 0XFF,
            cam_cap.version &amp; 0XFF);

    /* 使用IOCTL命令VIDIOC_ENUM_FMT，获取摄像头所有支持的格式*/
    cam_fmtdesc.index = 0;
    cam_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    printf("Support format:\n");
    while (ioctl(fd_cam, VIDIOC_ENUM_FMT, &amp;cam_fmtdesc) != -1) {
        printf("\t%d.%s\n", cam_fmtdesc.index + 1, cam_fmtdesc.description);
        cam_fmtdesc.index++;
    }

    /* 使用IOCTL命令VIDIOC_CROPCAP，获取摄像头的捕捉能力*/
    cam_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (0 == ioctl(fd_cam, VIDIOC_CROPCAP, &amp;cam_cropcap)) {
        printf("Default rec:\n\tleft:%d\n\ttop:%d\n\twidth:%d\n\theight:%d\n",
                cam_cropcap.defrect.left, cam_cropcap.defrect.top,
                cam_cropcap.defrect.width, cam_cropcap.defrect.height);
        /* 使用IOCTL命令VIDIOC_S_CROP，获取摄像头的窗口取景参数*/
        cam_crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        cam_crop.c = cam_cropcap.defrect;		//默认取景窗口大小
        if (-1 == ioctl(fd_cam, VIDIOC_S_CROP, &amp;cam_crop)) {
            //printf("Can't set crop para\n");
        }
    } else {
        printf("Can't set cropcap para\n");
    }

    /* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/
    cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    cam_format.fmt.pix.width = capW;
    cam_format.fmt.pix.height = capH;
    cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;		//要和摄像头支持的类型对应
    cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED;
    ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format);
    if (ret &lt; 0) {
        perror("Can't set frame information");
    }
    /* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/
    cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format);
    if (ret &lt; 0) {
        perror("Can't get frame information");
    }
    printf("Current data format information:\n\twidth:%d\n\theight:%d\n",
            cam_format.fmt.pix.width, cam_format.fmt.pix.height);
    ret = initBuffers();
    if (ret &lt; 0) {
        perror("Buffers init error");
        //exit(-1);
    }
    return 0;
}

int V4L2Capture::initBuffers() {
    int ret;
    /* 使用IOCTL命令VIDIOC_REQBUFS，申请帧缓冲*/
    struct v4l2_requestbuffers req;
    CLEAR(req);
    req.count = 4;
    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    req.memory = V4L2_MEMORY_MMAP;
    ret = ioctl(fd_cam, VIDIOC_REQBUFS, &amp;req);
    if (ret &lt; 0) {
        perror("Request frame buffers failed");
    }
    if (req.count &lt; 2) {
        perror("Request frame buffers while insufficient buffer memory");
    }
    buffers = (struct cam_buffer*) calloc(req.count, sizeof(*buffers));
    if (!buffers) {
        perror("Out of memory");
    }
    for (n_buffers = 0; n_buffers &lt; req.count; n_buffers++) {
        struct v4l2_buffer buf;
        CLEAR(buf);
        // 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        buf.index = n_buffers;
        ret = ioctl(fd_cam, VIDIOC_QUERYBUF, &amp;buf);
        if (ret &lt; 0) {
            printf("VIDIOC_QUERYBUF %d failed\n", n_buffers);
            return -1;
        }
        buffers[n_buffers].length = buf.length;
        //printf("buf.length= %d\n",buf.length);
        // 映射内存
        buffers[n_buffers].start = mmap(
                NULL, // start anywhere
                buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_cam,
                buf.m.offset);
        if (MAP_FAILED == buffers[n_buffers].start) {
            printf("mmap buffer%d failed\n", n_buffers);
            return -1;
        }
    }
    return 0;
}

int V4L2Capture::startCapture() {
    unsigned int i;
    for (i = 0; i &lt; n_buffers; i++) {
        struct v4l2_buffer buf;
        CLEAR(buf);
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory = V4L2_MEMORY_MMAP;
        buf.index = i;
        if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;buf)) {
            printf("VIDIOC_QBUF buffer%d failed\n", i);
            return -1;
        }
    }
    enum v4l2_buf_type type;
    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (-1 == ioctl(fd_cam, VIDIOC_STREAMON, &amp;type)) {
        printf("VIDIOC_STREAMON error");
        return -1;
    }
    return 0;
}

int V4L2Capture::stopCapture() {
    enum v4l2_buf_type type;
    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    if (-1 == ioctl(fd_cam, VIDIOC_STREAMOFF, &amp;type)) {
        printf("VIDIOC_STREAMOFF error\n");
        return -1;
    }
    return 0;
}/*ok*/

int V4L2Capture::freeBuffers() {
    unsigned int i;
    for (i = 0; i &lt; n_buffers; ++i) {
        if (-1 == munmap(buffers[i].start, buffers[i].length)) {
            printf("munmap buffer%d failed\n", i);
            return -1;
        }
    }
    free(buffers);
    return 0;
}

int V4L2Capture::getFrame(void **frame_buf, size_t* len) {
    struct v4l2_buffer queue_buf;
    CLEAR(queue_buf);
    queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    queue_buf.memory = V4L2_MEMORY_MMAP;
    if (-1 == ioctl(fd_cam, VIDIOC_DQBUF, &amp;queue_buf)) {
        printf("VIDIOC_DQBUF error\n");
        return -1;
    }
    *frame_buf = buffers[queue_buf.index].start;
    *len = buffers[queue_buf.index].length;
    frameIndex = queue_buf.index;
    return 0;
}

int V4L2Capture::backFrame() {
    if (frameIndex != -1) {
        struct v4l2_buffer queue_buf;
        CLEAR(queue_buf);
        queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        queue_buf.memory = V4L2_MEMORY_MMAP;
        queue_buf.index = frameIndex;
        if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;queue_buf)) {
            printf("VIDIOC_QBUF error\n");
            return -1;
        }
        return 0;
    }
    return -1;
}
void V4L2Capture::test() {
    unsigned char *yuv422frame = NULL;
    unsigned long yuvframeSize = 0;

    string videoDev="/dev/video0";
    V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()),
            1920, 1080);
    vcap-&gt;openDevice();
    vcap-&gt;initDevice();
    vcap-&gt;startCapture();
    vcap-&gt;getFrame((void **) &amp;yuv422frame, (size_t *)&amp;yuvframeSize);

    vcap-&gt;backFrame();
    vcap-&gt;freeBuffers();
    vcap-&gt;closeDevice();
}
void line2(Point point3[100000], int n)
{
    float aa, bb, cc, dd, ee, ff, gg;
    int jj = 0;
    for (;jj &lt;n;jj++)
    {
        aa += point3[jj].x*point3[jj].x;
        bb += point3[jj].x;
        cc += point3[jj].x*point3[jj].y;
        dd += point3[jj].y;
    }
    ee = aa*n - bb*bb;
    if ((int)(ee* 100) != 0)
    {
        ff = (n*cc - bb*dd) / ee;
        gg = (dd - bb*ff) / n;
    }
    else {
        ff = 0;
        gg = 1;
    }
    Point point0, pointn;
    point0.y = 0;
    point0.x = gg;
    pointn.y = (n-1);
    pointn.x = ((n-1) * ff + gg);

    Mat draw_ing2 = Mat::zeros(g_cannyMat_output.size(), CV_8UC3);
    line(draw_ing2, point0, pointn, (255, 255, 255));
    imshow("10", draw_ing2);
    //cout &lt;&lt; "\n"&lt;&lt;ff &lt;&lt;"      "&lt;&lt; gg &lt;&lt; endl;
    float the =180*atan(ff)/3.14159;
    float dis = ff * 160+gg - 160;
    cout &lt;&lt; the &lt;&lt; "    " &lt;&lt; dis &lt;&lt; endl;
    //正中心ff=0，gg=160，逆时ff为正，顺时ff为负
}
void findcolor(cv::Mat &amp;image)
{
    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.begin&lt;cv::Vec3b&gt;();
    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.end&lt;cv::Vec3b&gt;();
    ii = 0;
    iii = 0;
    int flagg = 0;
        cv::Mat srcX(image.rows, image.cols , CV_32F);
        cv::Mat srcY(image.rows, image.cols, CV_32F);
        for (int i = 0;i &lt; image.rows;i++)
        {
            for (int j = 0;j &lt; image.cols;j++)
            {
                if (flagg == 0)/*这样遍历水平方向无法得到有效数据*/
                {

                    if ((*it)[0] == 255 &amp;&amp; (*it)[1] == 0 &amp;&amp; (*it)[2] == 255)
                    {
                        flagg = 1;
                        point1[ii].x = i;
                        point1[ii].y = j;
                        ii++;
                    }

                }
                else
                {
                    if ((*it)[0] == 255 &amp;&amp; (*it)[1] == 0 &amp;&amp; (*it)[2] == 255)
                    {
                        flagg = 0;
                        point2[iii].x = i;
                        point2[iii].y = j;
                        iii++;
                    }
                }
                if (it == itend)
                    break;
                else it++;
            }
        }
        IplImage pImg = IplImage(image);
        CvArr* arr = (CvArr*)&amp;pImg;
        int nn = ii;
        for (;ii &gt; 0;ii--)
        {
            point3[ii].x = (point1[ii].x + point2[ii].x) / 2;
            point3[ii].y = (point1[ii].y + point2[ii].y) / 2;
            //circle(image, point3[ii], 1, (255, 255, 255));
            cvSet2D(arr, point3[ii].x, point3[ii].y, Scalar(255, 255, 255));
        }
        line2(point3, nn);
}

void on_ThreshChange(int, void* )
{
    // 使用Canndy检测边缘
    Canny( g_grayImage, g_cannyMat_output, g_nThresh, g_nThresh*2, 3 );

    // 找到轮廓
    findContours( g_cannyMat_output, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) );

    // 计算矩
    vector&lt;Moments&gt; mu(g_vContours.size() );
    for(unsigned int i = 0; i &lt; g_vContours.size(); i++ )
    { mu[i] = moments( g_vContours[i], false ); }

    //  计算中心矩
    vector&lt;Point2f&gt; mc( g_vContours.size() );
    for( unsigned int i = 0; i &lt; g_vContours.size(); i++ )
    { mc[i] = Point2f( static_cast&lt;float&gt;(mu[i].m10/mu[i].m00), static_cast&lt;float&gt;(mu[i].m01/mu[i].m00 )); }

    // 绘制轮廓
    Mat drawing = Mat::zeros(g_cannyMat_output.size(), CV_8UC3);
    for( unsigned int i = 0; i&lt; g_vContours.size(); i++ )
    {
        //Scalar color = Scalar( g_rng.uniform(0, 255), g_rng.uniform(0,255), g_rng.uniform(0,255) );//随机生成颜色值
        Scalar color = Scalar(255, 0, 255);
        drawContours( drawing, g_vContours, i, color, 2, 8, g_vHierarchy, 0, Point() );//绘制外层和内层轮廓
        circle( drawing, mc[i], 4, color, -1, 8, 0 );;//绘制圆
    }

    findcolor(drawing);
    //line1(point1,point2,ii,iii);

    // 显示到窗口中
//    namedWindow( WINDOW_NAME2, WINDOW_AUTOSIZE );
    imshow( WINDOW_NAME2, drawing );

}

void findline(Mat image)
{
    cv::Mat_&lt;cv::Vec3b&gt;::iterator it = image.begin&lt;cv::Vec3b&gt;();
    cv::Mat_&lt;cv::Vec3b&gt;::iterator itend = image.end&lt;cv::Vec3b&gt;();
    for (;it != itend;it++)
    {
        if ((*it)[1] == 0 &amp;&amp; (*it)[2] &gt;= 100)//条件可能需要改变
        {
            if(flag2==0)
            {
                flag2 = 1;
                cout &lt;&lt; "注意line1，避障"&lt;&lt;endl;
                //向主控发送消息
            }
            else
            {
                cout &lt;&lt; "注意line2，避障" &lt;&lt; endl;
                //向主控发送消息
                //避障一与避障二中间要隔一段时间
            }

        }
    }
}
void wave(const cv::Mat &amp;image, cv::Mat &amp;result)
{
    cv::Mat srcX(image.rows / 2, image.cols / 2, CV_32F);
    cv::Mat srcY(image.rows / 2, image.cols / 2, CV_32F);
    for (int i = 0;i&lt;image.rows /2;i++)
        for (int j = 0;j &lt; image.cols /2;j++)
        {
            srcX.at&lt;float&gt;(i, j) = 2 * j;
            srcY.at&lt;float&gt;(i, j) = 2 * i;
        }
    cv::remap(image, result, srcX, srcY, cv::INTER_LINEAR);
}

void VideoPlayer() {
    unsigned char *yuv422frame = NULL;
    unsigned long yuvframeSize = 0;

    string videoDev = "/dev/video0";
    V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()), 640, 480);
    vcap-&gt;openDevice();
    vcap-&gt;initDevice();
    vcap-&gt;startCapture();

    cvNamedWindow("Capture",CV_WINDOW_AUTOSIZE);
    IplImage* img;
    CvMat cvmat;
    double t;
    clock_t start, end;
    double number=0;
    int fps=0;
    while(1){
        start=clock();
        t = (double)cvGetTickCount();
        vcap-&gt;getFrame((void **) &amp;yuv422frame, (size_t *)&amp;yuvframeSize);
        cvmat = cvMat(IMAGEHEIGHT,IMAGEWIDTH,CV_8UC3,(void*)yuv422frame);		//CV_8UC3
        //解码
        img = cvDecodeImage(&amp;cvmat,1);
        if(!img){
            printf("DecodeImage error!\n");
        }
        
        cv::Mat g_srcImage = cv::cvarrToMat(img,true);
        
        cvShowImage("Capture",img);
        cvReleaseImage(&amp;img);
        vcap-&gt;backFrame();
        if((cvWaitKey(1)&amp;255) == 27){
            exit(0);
        }



        wave(g_srcImage, g_srcImage);
        findline(g_srcImage);

        // 把原图像转化成灰度图像并进行平滑
        cvtColor(g_srcImage, g_grayImage, COLOR_BGR2GRAY);
        blur(g_grayImage, g_grayImage, Size(3, 3));


        //创建滚动条并进行初始化
        createTrackbar(" 阈值", WINDOW_NAME1, &amp;g_nThresh, g_nMaxThresh, on_ThreshChange);
        on_ThreshChange(0, 0);
		t = (double)cvGetTickCount() - t;
		printf("Used time is %g ms\n", (t / (cvGetTickFrequency() * 1000)));

        end =clock();
        number=number+end-start;
        fps++;
        if (number/ CLOCKS_PER_SEC&gt;= 0.25)//windows10   for   CLK_TCK
        {
            cout&lt;&lt;fps&lt;&lt;endl;
            fps = 0;
            number = 0;
        }
    }
    vcap-&gt;stopCapture();
    vcap-&gt;freeBuffers();
    vcap-&gt;closeDevice();

}

int main() {
    VideoPlayer();

    return 0;
}
</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>opencv图像处理初步（二）：实现色彩还原&#8212;（白平衡）</title>
		<link>https://uzzz.org/article/2683.html</link>
				<pubDate>Fri, 07 Sep 2018 09:51:04 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图形视频]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2683.html</guid>
				<description><![CDATA[&#160;0、说明 目前很多摄像头特别是网络摄像头对色彩的处理情况存在色差，比如一个橙子（是黄色的），但是拍出来的效果会泛白，有点像梨子的颜色，因此要用到色彩校正。 一般色彩校正使用白平衡，白平衡一般又分为：灰世界、完美反射、等，这里不做具体陈述。 此处提供了一种方法，总体原理为（对每个通道而言）： 1）对偏暗和偏亮的颜色进行特定的处理：指定一个特定的像素值； 2）对其他像素值进行小幅度拉伸； 3）最后三个通道合并即为最终结果。 注意：偏暗和偏亮得界限是不对称的，可以同通过改变代码中的s实现。 具体计算方式可以看源码（c语言实现，非c++）。 1、效果 &#160; 2、代码实现 2.1我的实现（调整参数s以符合自己效果） /* 对偏暗和偏亮的的像素进行处理，对其他像素进行拉伸 偏暗和偏亮的判定可以通过调整下面的s进行调整，注意偏暗和偏亮是不对称的 */ #include &#60;highgui/highgui.hpp&#62; #include &#60;imgproc/imgproc.hpp&#62; using namespace cv; using namespace std; void color_balance(IplImage *img) { int histo[256] = { 0 };//直方图统计每个像素值的数目 int num_of_pixels = img-&#62;width*img-&#62;height; //统计每个像素值的数目 for (int y = 0; y &#60; img-&#62;height; ++y) { uchar *data = (uchar*)(img-&#62;imageData + y*img-&#62;widthStep);//定义的大小和图像尺寸一致 for (int x = 0; x &#60; img-&#62;width; ++x) { histo[data[x]] += 1; } } //统计当前像素值和之前像素值的总数 for (int i = 1; i &#60; 256; ++i) histo[i] = histo[i] + histo[i - 1]; double s = 0.0265;//此参数可以调整，最好在0.1以下(0=&#60;s&#60;=1) int vmin = 0; //统计像素点数目小于num_of_pixels*s / 2的数目，s为控制比率 while (histo[vmin + 1] &#60;= cvRound(num_of_pixels*s / 2)) vmin = vmin + 1; int vmax = 255 - 1; //统计像素点数目大于num_of_pixels*(1 - s / 2)的数目，s为控制比率 while (histo[vmax - 1] &#62; cvRound(num_of_pixels*(1 - s / 2))) { vmax = vmax - 1; } if (vmax &#60; 255 - 1) vmax = vmax + 1; //处理图像中像素值大于vmin和小于vmax的像素， //即处理偏亮和偏暗的区域 for (int y = 0; y &#60; img-&#62;height; ++y) { uchar *data = (uchar*)(img-&#62;imageData + y*img-&#62;widthStep); for (int x = 0; x &#60; img-&#62;width; ++x)]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h1 id="%C2%A00%E3%80%81%E8%AF%B4%E6%98%8E">&nbsp;0、说明</h1>
<p style="text-indent:50px;">目前很多摄像头特别是网络摄像头对色彩的处理情况存在色差，比如一个橙子（是黄色的），但是拍出来的效果会泛白，有点像梨子的颜色，因此要用到色彩校正。</p>
<p style="text-indent:50px;">一般色彩校正使用白平衡，白平衡一般又分为：<strong>灰世界</strong>、<strong>完美反射、</strong>等，这里不做具体陈述。</p>
<p style="text-indent:0;">此处提供了一种方法，总体原理为（对每个通道而言）：</p>
<p style="text-indent:50px;"><strong>1）</strong>对偏暗和偏亮的颜色进行特定的处理：指定一个特定的像素值；</p>
<p style="text-indent:50px;"><strong>2）</strong>对其他像素值进行小幅度拉伸；</p>
<p style="text-indent:50px;"><strong>3）</strong>最后三个通道合并即为最终结果。</p>
<p style="text-indent:50px;"><strong>注意：</strong>偏暗和偏亮得界限是不对称的，可以同通过改变代码中的s实现。</p>
<p style="text-indent:50px;">具体计算方式可以看源码（c语言实现，非c++）。</p>
<h1 id="1%E3%80%81%E6%95%88%E6%9E%9C"><strong>1、效果</strong></h1>
<h1 id="%E2%80%8B"><img alt="" class="has" height="288" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180907144852134?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW55dXBpbmczMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="800"></h1>
<p>&nbsp;<img alt="" class="has" height="319" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180907144939914?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW55dXBpbmczMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="800"></p>
<p style="text-align:center;"><img alt="" class="has" height="322" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180907145002394?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW55dXBpbmczMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="800"></p>
<h1 id="2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><strong>2、代码实现</strong></h1>
<h3><strong>2.1我的实现（调整参数s以符合自己效果）</strong></h3>
<pre class="has">
<code class="language-cpp">/*
对偏暗和偏亮的的像素进行处理，对其他像素进行拉伸
偏暗和偏亮的判定可以通过调整下面的s进行调整，注意偏暗和偏亮是不对称的
*/
#include &lt;highgui/highgui.hpp&gt;
#include &lt;imgproc/imgproc.hpp&gt;

using namespace cv;
using namespace std;

void color_balance(IplImage *img)
{
	int histo[256] = { 0 };//直方图统计每个像素值的数目
	int num_of_pixels = img-&gt;width*img-&gt;height;
    //统计每个像素值的数目
	for (int y = 0; y &lt; img-&gt;height; ++y)
	{
		uchar *data = (uchar*)(img-&gt;imageData + y*img-&gt;widthStep);//定义的大小和图像尺寸一致
		for (int x = 0; x &lt; img-&gt;width; ++x)
		{
			histo[data[x]] += 1;
		}
	}

    //统计当前像素值和之前像素值的总数
	for (int i = 1; i &lt; 256; ++i)
		histo[i] = histo[i] + histo[i - 1];

	double s = 0.0265;//此参数可以调整，最好在0.1以下(0=&lt;s&lt;=1)

	int vmin = 0;

    //统计像素点数目小于num_of_pixels*s / 2的数目，s为控制比率
	while (histo[vmin + 1] &lt;= cvRound(num_of_pixels*s / 2))
		vmin = vmin + 1;

	int vmax = 255 - 1;

    //统计像素点数目大于num_of_pixels*(1 - s / 2)的数目，s为控制比率
	while (histo[vmax - 1] &gt; cvRound(num_of_pixels*(1 - s / 2)))
	{
		vmax = vmax - 1;
	}

	if (vmax &lt; 255 - 1)
		vmax = vmax + 1;

    //处理图像中像素值大于vmin和小于vmax的像素，
    //即处理偏亮和偏暗的区域
	for (int y = 0; y &lt; img-&gt;height; ++y)
	{

		uchar *data = (uchar*)(img-&gt;imageData + y*img-&gt;widthStep);
		for (int x = 0; x &lt; img-&gt;width; ++x)
		{
			if (data[x] &lt; vmin)
				data[x] = vmin;
			if (data[x] &gt; vmax)
				data[x] = vmax;
		}
	}

    //对其他的像素进行处理（拉伸），其实可以合并到上一步，简化时间复杂度，这里分开只是为了让过程更清楚
	for (int y = 0; y &lt; img-&gt;height; ++y)
	{

		uchar *data = (uchar*)(img-&gt;imageData + y*img-&gt;widthStep);
		for (int x = 0; x &lt; img-&gt;width; ++x)
		{
			data[x] = cvRound((data[x] - vmin)*255.0 / (vmax - vmin));
		}
	}
}


int main()
{
	IplImage *srcImg = cvLoadImage("02.jpg");//读取图片
	IplImage *dstImg = cvCreateImage(cvGetSize(srcImg), 8, 3);
	IplImage *redCh = cvCreateImage(cvGetSize(srcImg), 8, 1);//R通道
	IplImage *greenCh = cvCreateImage(cvGetSize(srcImg), 8, 1);//G通道
	IplImage *blueCh = cvCreateImage(cvGetSize(srcImg), 8, 1);//B通道
	cvSplit(srcImg, blueCh, greenCh, redCh, NULL);//把原图拆分RGB通道
	color_balance(redCh);//对R通道进行色彩平衡
	color_balance(greenCh);//对G通道进行色彩平衡
	color_balance(blueCh);//对B通道进行色彩平衡
	cvMerge(blueCh, greenCh, redCh, NULL, dstImg);//合并操作后的通道，为最终结果
    
    //显示操作
	cvNamedWindow("src", CV_WINDOW_AUTOSIZE);
	cvShowImage("src", srcImg);

	cvNamedWindow("dst", CV_WINDOW_AUTOSIZE);
	cvShowImage("dst", dstImg);
	cvWaitKey(0);

	return 0;
}</code></pre>
<h3>2.2其他方法（灰世界&#8212;&gt;这个代码对有些情况下效果不好）&nbsp;</h3>
<pre class="has">
<code class="language-cpp">#include &lt;highgui/highgui.hpp&gt;
#include &lt;imgproc/imgproc.hpp&gt;
 
using namespace cv;
 
int main()
{
	Mat imageSource = imread("02.jpg");
	imshow("原始图像", imageSource);
	vector&lt;Mat&gt; imageRGB;
 
	//RGB三通道分离
	split(imageSource, imageRGB);
 
	//求原始图像的RGB分量的均值
	double R, G, B;
	B = mean(imageRGB[0])[0];
	G = mean(imageRGB[1])[0];
	R = mean(imageRGB[2])[0];
 
	//需要调整的RGB分量的增益
	double KR, KG, KB;
	KB = (R + G + B) / (3 * B);
	KG = (R + G + B) / (3 * G);
	KR = (R + G + B) / (3 * R);
 
	//调整RGB三个通道各自的值
	imageRGB[0] = imageRGB[0] * KB;
	imageRGB[1] = imageRGB[1] * KG;
	imageRGB[2] = imageRGB[2] * KR;
 
	//RGB三通道图像合并
	merge(imageRGB, imageSource);
	imshow("白平衡调整后", imageSource);
	waitKey();
	return 0;
}
</code></pre>
<p>&nbsp;</p>
<p style="text-align:center;"><img alt="" class="has" height="600" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180730105123931?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW55dXBpbmczMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="600"></p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
