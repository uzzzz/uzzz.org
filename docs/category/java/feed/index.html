<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>java &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/java/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Mon, 27 May 2019 14:20:31 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>java &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>解决maven库里有jar包但是pom文件里依赖报错的问题</title>
		<link>https://uzzz.org/article/3323.html</link>
				<pubDate>Mon, 27 May 2019 14:20:31 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[网络安全]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3323.html</guid>
				<description><![CDATA[pom文件报错如下： &#160; 但是maven库里有这个包： &#160; &#160; 解决办法如下： 1、打开setting文件，检查mirror的id： &#160; 2、打开maven库中刚才的文件夹，找到_maven.repositories文件： &#160; 3、把nexus=改成跟上面setting文件里的mirror的id值nexus-aliyun： &#160; 最后记得maven&#8212;update一下，于是就不报错了。 &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>pom文件报错如下：</p>
<p><img alt="" class="has" height="166" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527221023501.jpg" width="567"></p>
<p>&nbsp;</p>
<p>但是maven库里有这个包：</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527221202534.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTA5MzQ3OTc=,size_16,color_FFFFFF,t_70"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>解决办法如下：</p>
<p>1、打开setting文件，检查mirror的id：</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527221319652.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTA5MzQ3OTc=,size_16,color_FFFFFF,t_70"></p>
<p>&nbsp;</p>
<p>2、打开maven库中刚才的文件夹，找到_maven.repositories文件：</p>
<p><img alt="" class="has" height="122" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019052722162587.jpg" width="408"></p>
<p>&nbsp;</p>
<p>3、把nexus=改成跟上面setting文件里的mirror的id值nexus-aliyun：</p>
<p><img alt="" class="has" height="124" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190527221831399.jpg" width="555"></p>
<p>&nbsp;</p>
<p>最后记得maven&#8212;update一下，于是就不报错了。</p>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>使用 IntelliJ IDEA 运行及调试 Java程序</title>
		<link>https://uzzz.org/article/3273.html</link>
				<pubDate>Wed, 17 Apr 2019 07:22:39 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3273.html</guid>
				<description><![CDATA[&#160; 1、运行：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal 2、调试：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal&#160; a、设置断点：选定要设置断点的行，在行号的区域后面单击鼠标左键（如行号5的后面那个大红点点） b、开始调试 c、调试说明 来自博客：https://www.cnblogs.com/chiangchou/p/idea-debug.html&#160;，写的很详细 Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。 Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 Drop Frame (默认无)：回退断点，后面章节详细说明。 &#160; &#160; &#160; &#160; IntelliJ IDEA的使用教程 及 可下载的电子文档 http://www.runoob.com/w3cnote/intellij-idea-usage.html]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h3>&nbsp;</h3>
<h3>1、运行：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal</h3>
<p><img alt="" class="has" height="688" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190417150110471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODgzMzU4,size_16,color_FFFFFF,t_70" width="967"></p>
<h3>2、调试：选择菜单栏上面的Run按钮下的Run，或是快捷键Shift+Alt+F10，然后选择类名cal&nbsp;</h3>
<p><strong>a、设置断点：选定要设置断点的行，在行号的区域后面单击鼠标左键（如行号5的后面那个大红点点）</strong></p>
<p><img alt="" class="has" height="227" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190417151013218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODgzMzU4,size_16,color_FFFFFF,t_70" width="398"></p>
<p><strong>b、开始调试</strong></p>
<p><img alt="" class="has" height="185" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190417151305985.png" width="807"></p>
<p><strong>c、调试说明</strong></p>
<p><img alt="" class="has" height="584" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190417151526560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODgzMzU4,size_16,color_FFFFFF,t_70" width="964"></p>
<blockquote>
<p>来自博客：<a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html" rel="nofollow" data-token="32969dd2f6c028f7dc2955f575aad2e3">https://www.cnblogs.com/chiangchou/p/idea-debug.html</a>&nbsp;，写的很详细</p>
<ul>
<li>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li>
<li>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</li>
<li>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li>
<li>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li>
<li>Drop Frame (默认无)：回退断点，后面章节详细说明。</li>
</ul>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>&nbsp;</h3>
<h3>IntelliJ IDEA的使用教程 及 可下载的电子文档</h3>
<p><a href="http://www.runoob.com/w3cnote/intellij-idea-usage.html" rel="nofollow" data-token="a93255a7c4a1fe38ac53edf713857303">http://www.runoob.com/w3cnote/intellij-idea-usage.html</a></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>网不好的时候尽量不要写maven工程了！！！</title>
		<link>https://uzzz.org/article/2314.html</link>
				<pubDate>Thu, 04 Apr 2019 09:13:28 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2314.html</guid>
				<description><![CDATA[今天上午写一个springmvc的maven工程&#160; 但是我不知道网不好&#160; 一直不能进行自动的进行对JavaBean的自动json化 调了好长时间&#160; jackson的依赖也导入了&#160; 但是就是转化不了&#160; 真是焦头烂额 最后我无意间点开了maven的依赖&#160; 表面上一面平静 实则暗藏杀机 &#160; 这就是我们在导入maven依赖的时候失败了&#160; 这样的情况&#160; 建议直接新复制一份工程吧&#160;&#160; 好气哦&#160; 竟然是jar包的问题&#160; 而且表面看不出来 错误&#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>今天上午写一个springmvc的maven工程&nbsp; 但是我不知道网不好&nbsp; 一直不能进行自动的进行对JavaBean的自动json化</p>
<p>调了好长时间&nbsp; jackson的依赖也导入了&nbsp; 但是就是转化不了&nbsp; 真是焦头烂额</p>
<p>最后我无意间点开了maven的依赖&nbsp; 表面上一面平静</p>
<p><img alt="" class="has" height="141" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190404171104697.png" width="132"></p>
<p>实则暗藏杀机</p>
<p><img alt="" class="has" height="476" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190404171128800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDUzMzk1,size_16,color_FFFFFF,t_70" width="516">&nbsp;</p>
<p>这就是我们在导入maven依赖的时候失败了&nbsp; 这样的情况&nbsp; 建议直接新复制一份工程吧&nbsp;&nbsp;</p>
<p>好气哦&nbsp; 竟然是jar包的问题&nbsp; 而且表面看不出来 错误&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>git错误: failed to push some refs to &#8216;xxx&#8217;</title>
		<link>https://uzzz.org/article/1460.html</link>
				<pubDate>Thu, 13 Dec 2018 14:25:16 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1460.html</guid>
				<description><![CDATA[error: failed to push some refs to &#8216;git@gitee.com:zhengjinjun/payou.git&#8217; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#8216;git pull &#8230;&#8217;) before pushing again. hint: See the &#8216;Note about fast-forwards&#8217; in &#8216;git push &#8211;help&#8217; for details. 出现问题及解决办法: 原因: github中的README.md文件不在本地代码目录中 解决办法: $ git pull &#8211;rebase origin master &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>error: failed to push some refs to &#8216;git@gitee.com:zhengjinjun/payou.git&#8217;<br /> hint: Updates were rejected because the remote contains work that you do<br /> hint: not have locally. This is usually caused by another repository pushing<br /> hint: to the same ref. You may want to first integrate the remote changes<br /> hint: (e.g., &#8216;git pull &#8230;&#8217;) before pushing again.</p>
<p>hint: See the &#8216;Note about fast-forwards&#8217; in &#8216;git push &#8211;help&#8217; for details.</p>
<p>出现问题及解决办法:</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180708114625801?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDg0MjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>原因: github中的README.md文件不在本地代码目录中</p>
<p>解决办法:</p>
<p>$ git pull &#8211;rebase origin master</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180708114907650?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDg0MjUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>java集合容器至 Comparable/tor 的笔记</title>
		<link>https://uzzz.org/article/1087.html</link>
				<pubDate>Tue, 11 Dec 2018 06:52:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1087.html</guid>
				<description><![CDATA[================ ArrayList 查的快======================== 主要的索引的方法： index对应元素的 1： 存取的是一致： 2： 有索引 3： 可存取重复 注意：就是 关于 索引的 越界的异常 &#8212;&#8212;&#8212;-。主要的方法 add（加一个） addAll（全加） remove 删除指定一个的 removeAll（删除指定全部的） get（获取 ） set（替换） 返回的是以替换的 位置 ArrayList 的底层 是 数组扩容的 ######list集合的几个遍历的方法 1：普通for、 2：增强 for 3：迭代器Iteration ====linkdeList 增删改的快 lastAdd（）lastAddAll（） endAdd（）endAddAll（） linkdeList：底层是 双循环 链表结构 节点的原因：看源码&#8212;&#8211; 数组转 链表 add linkedlast类里的 函数 —遍历慢— 每次 都是 加速的功能 的 —》在里面找get方法 里nodenode方法 里 在 长度大于二分之一的就 会 从头往后找 往 小于 ， 就从后往头找 现在问的都是 1.7 的 hashMap 1.8 的就会很少的 比如&#8212;&#8212;过时的单线程的线程安全模式&#8212;&#8212;&#8212;查的也是慢 ===============set =================== 唯一 无序的 没有索引 是原始简单的集合 查询 快 的优势用hash表来实现的 没有索引值的》不能普通的for循环 底层的hash表结构 @@@ ==》普通for循环是不行的 ： 因为没有索引值 的 迭代器 增强for 都可以的 需要Collcetion 的 Iteractor &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;hash 太常见 了 因为继承于 Object 哈希表的最大的特点：查询快 哈希表本质 就是 一个Map集合 hash 是什么 对象的地址值 系统随机给出的十进制的 重写hascode 的方法 模拟了地址值 ：列举 当hash值一样 物理地址值 就有不一样的 所以就要有 qrulse 来比较重复的值 equlse 的比较 有重复的就不存 hashSet：JDK8之前 ：数组+链表 JDK8之后 ：数组+ 链表 还有 + 红黑树： 链表长度超过8位的就转为红黑树 的快查机制 数组 把元素 做为 数组里的分组 （相同的元素为一组） 然后再把相同的一组 ：用 链表与红黑树 来进行 而链表在过于长的时候就查是的慢了 这时候 链表长度超过8位的就转为红黑树 的快查接力 set集合的存储机制：避免重复元素的 原理 横为数组 竖 为链表 或红黑树 hash表是模拟物理地址的 有可重复的元素 在通过equals 就决定了比较怕重复的不予存储的 去重 最终追溯 源码的 哈希表 就是 一个Map集合 ================ Collections 集合工具类 &#8212;&#8212;&#8212;&#8212;&#8212;&#8211; Collections 集合工具类 util 对于集合的操作 都是 静态方法 public static boolean addAll: 往集合里添加一些元素 publictatic void shuffle（List&#60;?&#62; list）: 打乱集合的元素&#8212;&#8212;-比如打牌游戏 的 洗牌]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>================ ArrayList 查的快========================<br /> 主要的索引的方法： index对应元素的<br /> 1： 存取的是一致：<br /> 2： 有索引<br /> 3： 可存取重复<br /> 注意：就是 关于 索引的 越界的异常<br /> &#8212;&#8212;&#8212;-。主要的方法<br /> add（加一个） addAll（全加）<br /> remove 删除指定一个的 removeAll（删除指定全部的）</p>
<p>get（获取 ） set（替换） 返回的是以替换的 位置</p>
<p>ArrayList 的底层 是 数组扩容的<br /> ######list集合的几个遍历的方法<br /> 1：普通for、 2：增强 for 3：迭代器Iteration</p>
<p>====<mark><mark><mark><mark><mark><mark><mark>linkdeList 增删改的快</mark></mark></mark></mark></mark></mark></mark><br /> lastAdd（）lastAddAll（）<br /> endAdd（）endAddAll（）</p>
<p>linkdeList：底层是 双循环 链表结构</p>
<p>节点的原因：看源码&#8212;&#8211; 数组转 链表<br /> add linkedlast类里的 函数</p>
<p>—遍历慢— 每次 都是<br /> 加速的功能 的 —》在里面找get方法 里nodenode方法 里<br /> 在 长度大于二分之一的就 会 从头往后找 往 小于 ， 就从后往头找<br /> 现在问的都是 1.7 的 hashMap 1.8 的就会很少的<br /> 比如&#8212;&#8212;过时的单线程的线程安全模式&#8212;&#8212;&#8212;查的也是慢</p>
<p>=<mark><mark><mark><mark>==============set ===================<br /> 唯一 无序的 没有索引 是原始简单的集合<br /> 查询 快 的优势</mark></mark>用hash表来实现的<br /> 没有索引值的</mark></mark>》不能普通的for循环</p>
<p>底层的hash表结构<br /> @@@ ==》普通for循环是不行的 ： 因为没有索引值 的<br /> 迭代器 增强for 都可以的 需要Collcetion 的 Iteractor<br /> &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;hash 太常见 了 因为继承于 Object</p>
<p>哈希表的最大的特点：查询快 哈希表本质 就是 一个Map集合</p>
<p>hash 是什么 对象的地址值 系统随机给出的十进制的<br /> 重写hascode 的方法<br /> 模拟了地址值 ：列举 当hash值一样 物理地址值 就有不一样的<br /> 所以就要有 qrulse 来比较重复的值<br /> equlse 的比较 有重复的就不存<br /> hashSet：JDK8之前 ：数组+链表<br /> JDK8之后 ：数组+ 链表 还有 + 红黑树：<br /> 链表长度超过8位的就转为红黑树 的快查机制</p>
<p>数组 把元素 做为 数组里的分组 （相同的元素为一组）<br /> 然后再把相同的一组 ：用 链表与红黑树 来进行<br /> 而链表在过于长的时候就查是的慢了 这时候<br /> 链表长度超过8位的就转为红黑树 的快查接力</p>
<p>set集合的存储机制：避免重复元素的 原理</p>
<p>横为数组 竖 为链表 或红黑树</p>
<ul>
<li>hash表是模拟物理地址的 有可重复的元素</li>
<li>在通过equals 就决定了比较怕重复的不予存储的 去重<br /> 最终追溯 源码的<br />
<hr> </li>
</ul>
<p>哈希表 就是 一个Map集合</p>
<p>================ Collections 集合工具类 &#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br /> Collections 集合工具类 util 对于集合的操作<br /> 都是 静态方法<br /> public static boolean addAll: 往集合里添加一些元素<br /> publictatic void shuffle（List&lt;?&gt; list）: 打乱集合的元素&#8212;&#8212;-比如打牌游戏 的 洗牌 就是一个shuffle<br /> public static void sort(List list):将集合元素按照 默认的规则来排序<br /> public static void sort（List list，comparator&lt;? superT&gt;）:<br /> 按照指定的（自定义的）=规则来排序</p>
<p>====》通过分析方法定义的参数：指定专属 List 类型的 使用的就是 参数里有List的<br /> sort’方法的参数 的底层 是实现了 1：comparable接口里的compareTo方法 compraeTo（）方法里定义了 比较的规则<br /> ===&gt;泛型里类型 就实现了 这个方法 于是 就查看这个泛型的源码</p>
<p>public final class Integer extends Numble implements Comparable{}</p>
<p>也就是 集合里的泛型 包装类 的 都是实现了 comparable比较器<br /> String实现了 内比较器 ：采用的是 JDK提供 源码的定义的规则<br /> 同在 Java.lang 系统的<br /> public final class String implements Java.io.Serializable,Comparable<br /> ,CharSequence{}</p>
<p>举例说： 集合里 存储的是 person类 有name 与age的属性</p>
<p>索引的0减一 根据一个差值 来决定 二分叉的<br /> sort 方法参数 2：<br /> 按照首字母进行排序 使用匿名类进行的不太理解</p>
<p>——————————————————————————————————</p>
<p>比较器的接口 分为： 内比较器 comparable （内ble） 外比较器 comparator （外tor）</p>
<p>=======&gt;内比较器 comparable 内部的就写的是固定的版本方法 所以通过源码的 比较器<br /> =======&gt;外比较器 comparator 外部 的自定义的来进行 降序 与升序的编码<br /> ====》这是 要学的 编码</p>
<h2><a id="_comparator___105"></a>@@@@@外比较器 comparator— 自定义 的</h2>
<p>这是 要学写的编码 灵活的使用在 你要比较的地方直接的实现比较的规则就可以<br /> 多用于匿名类的方式 来实现灵活的完成<br /> 匿名类依赖 产生的接口：Comparator 大括号里重写 compare（）</p>
<h2><a id="
_______
_______

___________
_________
_______111"></a>数字的是：<br /> 前减后 ：升序 前要减的 为升—前减为升<br /> 后减前 ：降序 后要减的 为降— 后减为降<br /> 对象的引用的是：<br /> 前 调用 后的==》 为升 &#8212;&#8211;前调 为升<br /> 后 调用 前的==》 为降序 &#8212;&#8211; 后调 为降<br /> 你可以转成 接口的实现类里来完成 理解后 在进行 匿名类的方式</h2>
<p>comparator 外比较器 与 Comparable内比较器的区别</p>
<p>Comparable：内比较器：是直接就实行了整体排序 自动的排序无需指定 只能用一次 写死的硬编码的<br /> compareTo（）<br /> 类在定义的时候就已产生了比较的规则：升序了Comparable 并完成compareTo方法 你可以设置你的排序 降序与升序 天生就具</p>
<h2><a id="_125"></a>备了比较的规则</h2>
<p>Comparator ：外比较器：作为sort里的参数 以匿名实现类的方式 进行<br /> 重写方法里的 控制 降序 或 升序 的 还可以控制 数据结构 和 为没有自然排序的对象提供排序<br /> compare（）<br /> 在类 没有实现 内比较器 的时候 我们在 测试类里 使用<br /> &#8212;&#8212;》外比较器 用于 已经实现 内比较器的使用<br /> @@@ 还可以在 你的使用了（实现）内比较器 的方式 还可以在 测试类里 完成 外比较器的 再次设置</p>
<p>在内部类里 的匿名类的使用率高的 要记住掌握 匿名类<br /> 匿名内部类的 范围： 大括号里的<br /> 集合里的线程<br /> ArrayList 与linkedList 是多线程的 线程是安全吗？？</p>
<p>########################### Map #####################################</p>
<p>先讲的出 增加激情 与自信 做的好</p>
<p>key 的值是不可重复的： 键找值的方法 keySet（）；<br /> 添add重复的key 就是要更新 对应的 value 值 然后替换（覆盖）==》还是唯一了</p>
<p>最常用的就是=====》HashMap<br /> JDK 1.8与1.8 之前 ：<br /> 每个集合 对用的 常用的集合类：3个代表： Arraylist HashSet HashMap</p>
<p>@@@ map 不适用 普通的for 与Intarator迭代器</p>
<p>增强for的遍历是：使用类型==》 数组 Collection 接口<br /> map 中的键与值的映射关系<br /> put 方法里 就是通过键 值的依赖作用来更新对应 认识达到了<br /> 、 键找值的 和值找键 的方式<br /> 加上 遍历的循环查找<br /> put 的认识是 和add不同的是 在map键与值的映射的特点里、<br /> 可以 键找值 与值找 键的映射 依赖的关系 来 （更新 获取） 彼此<br /> put（） remove（） get（） containsKey（）</p>
<p>get（） ：直接的get （）就可以获取 键 与 值 彼此的 映射</p>
<p>&#8212;-》键 与 值的一对 还可以是个Entry 对象<br /> 也可以说map集合里的泛型就是一个Entry对象</p>
<p>hash 表就是 Map集合？？？？？</p>
<p>Map的获取 直接是的输出 就是一对一对的 键 值 或者 Entry</p>
<p>其中基于Map 键与值 的 映射中的获取<br /> &#8212;&#8211;》这两种获取 的区别<br /> 单纯的通过键找值的==》 keySet（）理解记忆key就是键 键存储在Set里确保唯一<br /> 值找 键==》values<br /> Entry对象的获取 的 getKey（） getValue（）<br /> Entry 就是map的内部类的</p>
<p>HashMap hash确保 键与值各自 唯一<br /> 创建实体类 在测试类里进行存取 的Demo 发现了 存与获取的顺序是不一致的</p>
<p>LinkedHashMap 增加了 Linked可以确保存取的顺序是一致是的</p>
<hr>
<p>&#8212;&#8212;&#8212;&#8212;-map&#8212;&#8212;&#8211;<br /> hashMap ： key 值唯一的 ，value 为null<br /> hashset 的：<br /> 底层是 使用的code值 唯一的 要说 hash 肯还会问的<br /> Entry 对象数据<br /> hashMap—看源码：当前编辑器里 ctrl+N 搜索–看源码</p>
<p>到了这个阶段我们应该需要 怎样 的目标的 感觉</p>
<p>总结：<br /> 1 利用 key的hashcode &#8212;&#8212;&#8211;理论唯一 并不代表 实现是唯一的<br /> Entry 数组是的默认的大小16 0.75 12 到原来的 长度的0.75 就加载 =<mark>必问<br /> Load加载因子</mark>=扩容机制<br /> 再看put 就多了<br /> 扩容 2的幂次方 一千个 &#8211;2048<br /> 扩容的问题： 在进行扩容机制是非常损耗资源的 &#8212;-因为 数组 对象 还要节点<br /> 所以 最好要给与一个新的 已知 map好你的初始化 的数组</p>
<p>hashMap 不安全的 加了一整把锁 效果差一点把<br /> 解决 —ConcurrentHashMap 分段锁 机制<br /> 默认16个段（就是锁 ： HashMap）然后分段的存储的 解耦 的锁机制还可以扩容</p>
<p>笔试题：&#8212;&#8212;&#8211;》手写单项列表</p>
<p>拍的技术的核心就是原理&#8212;-大公司 的就是不需要有多大的项目</p>
<p>== 与 equals 是没有区别的 &#8212;-普通认知是的 误区<br /> 源码里有一个的<br /> return==obj<br /> GC 机制 的<br /> 单例模式</p>
<p>====================集合之间的转换,存储元素的 转存 ========================<br /> Set paihao = new HashSet&lt;&gt;();&#8212;&#8212;&gt;<br /> ArrayList pokerhao=new ArrayList&lt;&gt;();<br /> pokerhao.addAll(paihao)</p>
<h1><a id="map_
_
1___Scanner___
_2fori_____
3__
4map_containsKey_
______map_put__1_
elsemapgetkye_value__
______mapput_
5mapEntry__
___map2_1for__2_Intrator_222"></a>=<mark><mark><mark><mark><mark><mark>》使用map方法的 的案例应用《</mark></mark></mark></mark></mark></mark>========<br /> 的思路：<br /> 1：字符串的获取 ： Scanner 的键盘输入<br /> 2：手动的fori 生成 循环 将 获取的字符串对象 遍历<br /> 3：字符串对象 调用 字符的获取方法，返回字符变量<br /> 4：使用map 调用的containsKey（）的参数是这个字符变量 &#8211;》进行否定的判断<br /> map 调用put方法 传入字符变量与 次数为1<br /> else：map调用get（）获取kye键字符 返回value数量的对象 这个次数 自增<br /> map调用put 传入字符与自增的变量<br /> 5：map获取Entry对象类遍历 打印输出<br /> map遍历2种方法 1：增强for与 2： Intrator迭代器</h1>
<p>map 键找值的认知：<br /> 1：键找值的方法遍历map ,必须要用上keySet 、可以不用get（）<br /> :2：HashMap存储自定义练习的键值对 的说法：<br /> 可以存储自定义 放在键或者 值的对方 在键上的就必须重写 hashcode()yu<br /> 与equals() 来确 唯一<br /> 3：map存储的是键值对的数据 双列集合 键与值 的数据类型都可以 但是键的唯一 是必须的<br /> 4：键值对的找键和值 对于map 遍历说法：<br /> 5： Map的键key 只能是引用类型的数据 value值 也存放基本数据 引用类型的<br /> map集合是通过entrySet()来获取键值对 对象的<br /> map是 不能用普通for来遍历的 要在获取对象之后 就可以用：增强for与迭代器Intarator</p>
<p>1： null 0<br /> 2： 键找值的 不只要键找值的 还可以get（）<br /> 3： key是可以的 存放 引用的 基本的都可以</p>
<p>@#@@@ next（只 读到有效的 字符）不管是 nextInt 还是 NextDuble 都会有问题的<br /> nextline(读到 Enter键) 一行一行的读</p>
<p>注意：集合 双方的《泛型》数据类型要一致</p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>SpringBoot使用WebSocket实现服务端推送&#8212;单机实现（1）</title>
		<link>https://uzzz.org/article/1361.html</link>
				<pubDate>Sun, 14 Oct 2018 07:07:47 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[软件开发]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1361.html</guid>
				<description><![CDATA[[![star](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/badge/star.svg?theme=dark)](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/stargazers) 最近开发中需要实现服务端的推送，经过一段时间的资料查询最终锁定使用websocket来实现。JavaEE本身就支持WebSocket。我们只需要开发一个EndPoint来处理连接、消息等即可。但是WebSocket的session管理是开发中的重中之重和难点，因为你需要知道推送给谁，就需要保存代表其连接的Session。 1.首先设计管理WebSocket的session的接口WebSocketManager。 /** * 管理websocket的session,可以使用Map * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257 */ public interface WebSocketManager { /** * 在容器中的名字 */ String WEBSOCKET_MANAGER_NAME = "webSocketManager"; /** * 根据标识获取websocket session * @param identifier 标识 * @return WebSocket */ WebSocket get(String identifier); /** * 放入一个 websocket session * @param identifier 标识 * @param webSocket websocket */ void put(String identifier , WebSocket webSocket); /** * 删除 * @param identifier 标识 */ void remove(String identifier); /** * 获取当前机器上的保存的WebSocket * @return WebSocket Map */ Map&#60;String , WebSocket&#62; localWebSocketMap(); /** * 统计所有在线人数 * @return 所有在线人数 */ default int size(){ return localWebSocketMap().size(); } /** * 给某人发送消息 * @param identifier 标识 * @param message 消息 */ void sendMessage(String identifier, String message); /** * 广播 * @param message 消息 */ void broadcast(String message); /** * 修改当前的状态 * @param identifier 标识 * @param status 状态 */ void changeStatus(String identifier , int status); } 其中，identifier是一个人的标识，发送消息就以此为根据。本类定义了本地管理WebSocket、发送消息的一些方法，WebSocket是一个实体类，保存有标识和用于会话的session。 /** * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257 */ public class WebSocket implements Serializable{ public static final int STATUS_AVAILABLE = 0;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>[![star](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/badge/star.svg?theme=dark)](https://gitee.com/xxssyyyyssxx/websocket-springboot-starter/stargazers)</p>
<p>最近开发中需要实现服务端的推送，经过一段时间的资料查询最终锁定使用websocket来实现。JavaEE本身就支持WebSocket。我们只需要开发一个EndPoint来处理连接、消息等即可。但是WebSocket的session管理是开发中的重中之重和难点，因为你需要知道推送给谁，就需要保存代表其连接的Session。</p>
<p>1.首先设计管理WebSocket的session的接口WebSocketManager。</p>
<pre class="has">
<code class="language-java">/**
 * 管理websocket的session,可以使用Map
 * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257
 */
public interface WebSocketManager {
    /**
     * 在容器中的名字
     */
    String WEBSOCKET_MANAGER_NAME  = "webSocketManager";
    /**
     * 根据标识获取websocket session
     * @param identifier 标识
     * @return WebSocket
     */
    WebSocket get(String identifier);

    /**
     * 放入一个 websocket session
     * @param identifier 标识
     * @param webSocket websocket
     */
    void put(String identifier , WebSocket webSocket);

    /**
     * 删除
     * @param identifier 标识
     */
    void remove(String identifier);

    /**
     * 获取当前机器上的保存的WebSocket
     * @return WebSocket Map
     */
    Map&lt;String , WebSocket&gt; localWebSocketMap();

    /**
     * 统计所有在线人数
     * @return 所有在线人数
     */
    default int size(){
        return localWebSocketMap().size();
    }

    /**
     * 给某人发送消息
     * @param identifier 标识
     * @param message 消息
     */
    void sendMessage(String identifier, String message);

    /**
     * 广播
     * @param message 消息
     */
    void broadcast(String message);

    /**
     * 修改当前的状态
     * @param identifier 标识
     * @param status 状态
     */
    void changeStatus(String identifier , int status);
}</code></pre>
<p>其中，identifier是一个人的标识，发送消息就以此为根据。本类定义了本地管理WebSocket、发送消息的一些方法，WebSocket是一个实体类，保存有标识和用于会话的session。</p>
<pre class="has">
<code class="language-java">/**
 * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257
 */
public class WebSocket implements Serializable{
    public static final int STATUS_AVAILABLE       = 0;
    public static final int STATUS_UNAVAILABLE     = 1;
    private String identifier;
    private Session session;
    private int status;
    ...
}</code></pre>
<p>如果是单机管理websocket，可以使用一个Map来管理session。实现类如下：</p>
<pre class="has">
<code class="language-java">/**
 * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257
 */
public class MemWebSocketManager implements WebSocketManager {
    /**
     * 因为全局只有一个 WebSocketManager ，所以才敢定义为非static
     */
    private final Map&lt;String, WebSocket&gt; connections = new ConcurrentHashMap&lt;&gt;(100);

    @Override
    public WebSocket get(String identifier) {
        return connections.get(identifier);
    }

    @Override
    public void put(String identifier, WebSocket webSocket) {
        connections.put(identifier , webSocket);
    }

    @Override
    public void remove(String identifier) {
        connections.remove(identifier);
    }


    @Override
    public Map&lt;String, WebSocket&gt; localWebSocketMap() {
        return connections;
    }

    @Override
    public void sendMessage(String identifier, String message) {
        WebSocket webSocket = get(identifier);
        if(null == webSocket){throw new RuntimeException("identifier 不存在");}

        if(WebSocket.STATUS_AVAILABLE != webSocket.getStatus()){
            return;
        }

        WebSocketUtil.sendMessage(webSocket.getSession() , message);
    }

    @Override
    public void broadcast(String message) {
        localWebSocketMap().values().forEach(
                webSocket -&gt; WebSocketUtil.sendMessage(
                        webSocket.getSession() , message));
    }

    /**
     * 修改当前的状态
     * @param identifier 标识
     * @param status 状态
     */
    @Override
    public void changeStatus(String identifier , int status) {
        WebSocket socket = get(identifier);
        if(null == socket){return;}

        socket.setStatus(status);
    }
}</code></pre>
<p>将此类注入到容器中。</p>
<pre class="has">
<code class="language-java">@Bean(WebSocketManager.WEBSOCKET_MANAGER_NAME)
public WebSocketManager webSocketManager(){
    return new MemWebSocketManager();
}</code></pre>
<p>然后开发一个Endpoint，实现websocket的连接。</p>
<pre class="has">
<code class="language-java">/**
 * NOTE: Nginx反向代理要支持WebSocket，需要配置几个header，否则连接的时候就报404
       proxy_http_version 1.1;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection "upgrade";
       proxy_read_timeout 3600s; //这个时间不长的话就容易断开连接
 * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257
 */
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@ServerEndpoint(value ="/websocket/connect/{identifier}")
public class WebSocketEndpoint {
    private static final int CODE_BEATHEART  = 8;
    /**
     * 路径标识：目前使用token来代表
     */
    private static final String IDENTIFIER = "identifier";
    private static final Logger logger = LoggerFactory.getLogger(WebSocketEndpoint.class);

    /// 无法通过这种方式注入组件
    /*@Autowired
    private WebSocketManager websocketManager;*/

    public WebSocketEndpoint() {
    }

    @OnOpen
    public void onOpen(Session session, @PathParam(IDENTIFIER) String identifier) {
        try {
            logger.info("*** WebSocket opened from sessionId " + session.getId() + " , identifier = " + identifier);
            if(StrUtil.isBlank(identifier)){
                return;
            }
            WebSocket socket = new WebSocket();
            socket.setIdentifier(identifier);
            socket.setSession(session);
            socket.setStatus(WebSocket.STATUS_AVAILABLE);
            //像刷新这种，id一样，session不一样，后面的覆盖前面的

            WebSocketManager websocketManager = getWebSocketManager();

            websocketManager.put(identifier , socket);

        } catch (Exception e) {
            logger.error(e.getMessage() , e);
        }
    }

    @OnClose
    public void onClose(Session session , @PathParam(IDENTIFIER) String identifier) {
        logger.info("*** WebSocket closed from sessionId " + session.getId() + " , identifier = " + identifier);
        getWebSocketManager().remove(identifier);
    }

    @OnMessage
    public void onMessage(String message, Session session , @PathParam(IDENTIFIER) String identifier) {
        logger.info("接收到的数据为：" + message + " from sessionId " + session.getId() + " , identifier = " + identifier);
        //说明不是json，处理不了
        if (!JsonUtil.isJsonObject(message)) {return;}

        JSONObject object = new JSONObject(message);
        boolean containsKey = object.containsKey("code");

        if(!containsKey){
            return;
        }

        Integer code = object.getInteger("code");
        if(CODE_BEATHEART == code){
            Map&lt;String , Long&gt; map = new HashMap&lt;&gt;(1);
            map.put("timestamp" , System.currentTimeMillis());
            Message msg = new Message(CODE_BEATHEART , map);
            WebSocketUtil.sendMessage(session , JsonUtil.serializeJavaBean(msg));
        }

    }

    @OnError
    public void onError(Throwable t , @PathParam(IDENTIFIER) String identifier){
        logger.info("发生异常：, identifier = " + identifier);
        logger.error(t.getMessage() , t);
        getWebSocketManager().remove(identifier);
    }

    private WebSocketManager getWebSocketManager() {
        return SpringContextHolder.getBean(WebSocketManager.WEBSOCKET_MANAGER_NAME , WebSocketManager.class);
    }
}</code></pre>
<p>NOTE:</p>
<p>0. 网页端使用连接 ws://xxxxxxx/websocket/connect/{token}即可。</p>
<p>1.如果是Nginx反向代理的，需要在Nginx代理中设置几个header。如果是SLB，需要业务保障型。</p>
<p>2.如果是独立的Tomcat应用，它就会自动扫描标注了@ServerEndPoint的类，如果是内置容器，就不会扫描，需要注入一个ServerEndpointExporter。目前还不知道为什么，所以针对这两种情况，我们需要不同的配置，可以使用&nbsp;ConditionalOnProperty 轻松应对。</p>
<pre class="has">
<code class="language-java">/**
 * webSocket配置
 * @author xiongshiyan
 */
@Configuration
public class WebSocketConfig {
    /**
     * @see https://www.cnblogs.com/betterboyz/p/8669879.html
     * 首先要注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。
     * 要注意，如果使用独立的servlet容器，而不是直接使用springboot的内置容器，就不要注入ServerEndpointExporter，
     * 因为它将由容器自己提供和管理， 否则就会报重复的endpoint错误。
     */
    @ConditionalOnProperty(prefix = "server.websocket.exporter" ,
                                name = "enable" ,havingValue = "true")
    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}</code></pre>
<p>3.ServerEndpoint不会成为Spring的一个组件，所以使用@Autowired是不会生效的，所以需要一个全局获取容器的方法。利用ApplicationContextAware可以注入容器，使用一个静态变量保存起来。提供get方法。</p>
<pre class="has">
<code class="language-java">/**
 * 容器全局存留
 * @author xiongshiyan at 2018/8/14 , contact me with email yanshixiong@126.com or phone 15208384257
 */
public class SpringContextHolder implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    /**
     * 实现ApplicationContextAware接口的context注入函数, 将其存入静态变量.
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        SpringContextHolder.applicationContext = applicationContext;
    }

    /**
     * 取得存储在静态变量中的ApplicationContext.
     */
    public static ApplicationContext getApplicationContext() {
        checkApplicationContext();
        return applicationContext;
    }

    @SuppressWarnings("unchecked")
    public static Object getBean(String beanName) {
        checkApplicationContext();
        return applicationContext.getBean(beanName);
    }

    /**
     * 从静态变量ApplicationContext中取得Bean, 自动转型为所赋值对象的类型.
     */
    public static &lt;T&gt; T getBean(String beanName, Class&lt;T&gt; clazz) {
        checkApplicationContext();
        return applicationContext.getBean(beanName, clazz);
    }

    /**
     * 清除applicationContext静态变量.
     */
    public static void cleanApplicationContext() {
        applicationContext = null;
    }

    private static void checkApplicationContext() {
        if (applicationContext == null) {
            throw new IllegalStateException(
                    "applicationContext未注入,请配置SpringContextHolder");
        }
    }
}</code></pre>
<p>4.WebSocketUtil是用于发送消息的工具类，提供以阻塞 / 异步方式发送不同类型消息的能力。</p>
<pre class="has">
<code class="language-java">/**
 * @author xiongshiyan at 2018/10/11 , contact me with email yanshixiong@126.com or phone 15208384257
 */
public class WebSocketUtil {
    /**
     * 发送消息
     */
    public static boolean sendMessage(Session session, String message) {
        try {
            session.getBasicRemote().sendText(message);
            return true;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 异步发送消息
     */
    public static boolean sendMessageAsync(Session session, String message) {
        Future&lt;Void&gt; voidFuture = session.getAsyncRemote().sendText(message);
        return voidFuture.isDone();
    }

    /**
     * 发送字节消息
     */
    public static boolean sendBytes(Session session, byte[] bytes) {
        try {
            session.getBasicRemote().sendBinary(ByteBuffer.wrap(bytes));
            return true;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 异步发送字节
     */
    public static boolean sendBytesAsync(Session session, byte[] bytes) {
        Future&lt;Void&gt; voidFuture = session.getAsyncRemote().sendBinary(ByteBuffer.wrap(bytes));
        return voidFuture.isDone();
    }
    /**
     * 发送对象消息
     */
    public static boolean sendObject(Session session, Object o) {
        try {
            session.getBasicRemote().sendObject(o);
            return true;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 异步发送对象
     */
    public static boolean sendObjectAsync(Session session, Object o) {
        Future&lt;Void&gt; voidFuture = session.getAsyncRemote().sendObject(o);
        return voidFuture.isDone();
    }
}
</code></pre>
<p>5.WebSocket开发需要保持一个心跳，可以通过PING/PONG消息的方式。</p>
<p>至此，单机就可以实现WebSocket的管理和消息传送了。</p>
<p>一些测试方法：</p>
<pre class="has">
<code class="language-java">/**
 * @author xiongshiyan at 2018/10/10 , contact me with email yanshixiong@126.com or phone 15208384257
 */
@RestController
@RequestMapping("/websocket/test")
public class WebsocketTestController {
    @Autowired
    private WebSocketManager webSocketManager;

    @GetMapping("/get/send")
    public String sendGet(@RequestParam("token") String token ,
                       @RequestParam("message") String message) throws Exception{
        webSocketManager.sendMessage(token , message);
        return ("发送成功");
    }
    @PostMapping("post/send")
    public String sendPost(@RequestParam("token") String token , @RequestBody String body) throws Exception{
        webSocketManager.sendMessage(token , body);
        return ("发送成功");
    }
    @PostMapping("broadcast")
    public String broadcast(@RequestBody String body) throws Exception{
        webSocketManager.broadcast(body);
        return ("广播成功");
    }

    @GetMapping("clients")
    public String getClientsNum(){
        return ("目前在线：" + webSocketManager.size());
    }
}
</code></pre>
<p>测试的网页，可以自动重连：</p>
<pre class="has">
<code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;token1&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
Welcome token1&lt;br/&gt;
&lt;input id="text" type="text" /&gt;&lt;button οnclick="send()"&gt;Send&lt;/button&gt;    &lt;button οnclick="closeWebSocket()"&gt;Close&lt;/button&gt;
&lt;div id="status"&gt;&lt;/div&gt;
&lt;div id="message"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript"&gt;
    var websocket = null;

    //判断当前浏览器是否支持WebSocket
    if('WebSocket' in window){
        connect();
    }
    else{
        alert('Not support websocket')
    }

	function connect(){
		websocket = new WebSocket("ws://47.92.44.39:80/anfang-api/websocket/connect/token1");
		//连接发生错误的回调方法
		websocket.onerror = function(){
			setStatusInnerHTML("error");
		};

		//连接成功建立的回调方法
		websocket.onopen = function(event){
			setStatusInnerHTML("open");
		}

		//接收到消息的回调方法
		websocket.onmessage = function(event){
			console.log(event.data);
			setMessageInnerHTML(event.data);
		}

		//连接关闭的回调方法
		websocket.onclose = function(){
			setStatusInnerHTML("close");
			connect();
		}
	}

    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
    window.onbeforeunload = function(){
        websocket.close();
    }

    //将消息显示在网页上
    function setMessageInnerHTML(innerHTML){
        document.getElementById('message').innerHTML += innerHTML+'&lt;br/&gt;';
    }
	//将websocket状态显示网页上
    function setStatusInnerHTML(innerHTML){
        document.getElementById('status').innerHTML = innerHTML;
    }

    //关闭连接
    function closeWebSocket(){
        websocket.close();
    }

    //发送消息
    function send(){
        var message = document.getElementById('text').value;
        websocket.send(message);
    }
&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>给出几个测试websocket的链接地址：</p>
<p><a href="http://www.blue-zero.com/WebSocket/" rel="nofollow" data-token="fb61fc48cd7acaa9465a16027adff538">http://www.blue-zero.com/WebSocket/</a></p>
<p><a href="http://coolaf.com/tool/chattest" rel="nofollow" data-token="448ee76ba5a1b0ea3be5683cf936bcbd">http://coolaf.com/tool/chattest</a></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Android TCP真正有效的断链检测方法</title>
		<link>https://uzzz.org/article/3195.html</link>
				<pubDate>Thu, 30 Aug 2018 13:30:47 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3195.html</guid>
				<description><![CDATA[1. 利用socket提供的isConnected()与isClosed()方法来判断。但这种方式只是本地判断，只是本地操作connect()或close()方法后保存的一个状态，对于远程服务器主动断开就没有用了。 2. 利用socket中的sendUrgentData()来判断。这种方法不管是客户端主动断开还是服务器主动断开，亦或者是异常断开都是有用的。但这种方法有一个明显的缺点，它得向服务器发送数据，相当于使用OutputStream,这就会影响正常通信的速度，并且会影响另一端的运行。 3. 利用BufferedReader中的readLine()来判断。当服务器主动断开时，readLine()方法会返回null。注意这种方式要求发送的信息中必须有换行符&#8217;\r\n&#8217;、&#8217;\r&#8217;或&#8217;\n&#8217;。如果服务器发送信息中不含换行符的话，那就唯有等到socket关闭时才有机会读到。 4. 利用InputStream.read()或BufferedReader.read()来判断。当服务器主动断开时，read()会返回-1 2018-08-30实际验证:在Socket.connect()成功后，设置全局变量bConnect=true；并另开一个线程：循环调用InputStream.read()直到返回-1或异常时设置全局变量bConnect=false；在网络发送的线程中判断全局变量bConnect==true再调用OutputStream.write()。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>1. 利用socket提供的isConnected()与isClosed()方法来判断。但这种方式只是本地判断，只是本地操作connect()或close()方法后保存的一个状态，对于远程服务器主动断开就没有用了。</p>
<p>2. 利用socket中的sendUrgentData()来判断。这种方法不管是客户端主动断开还是服务器主动断开，亦或者是异常断开都是有用的。但这种方法有一个明显的缺点，它得向服务器发送数据，相当于使用OutputStream,这就会影响正常通信的速度，并且会影响另一端的运行。</p>
<p>3. 利用BufferedReader中的readLine()来判断。当服务器主动断开时，readLine()方法会返回null。注意这种方式要求发送的信息中必须有换行符&#8217;\r\n&#8217;、&#8217;\r&#8217;或&#8217;\n&#8217;。如果服务器发送信息中不含换行符的话，那就唯有等到socket关闭时才有机会读到。</p>
<p>4. 利用InputStream.read()或BufferedReader.read()来判断。当服务器主动断开时，read()会返回-1</p>
<p>2018-08-30实际验证:在Socket.connect()成功后，设置全局变量bConnect=true；并另开一个线程：循环调用InputStream.read()直到返回-1或异常时设置全局变量bConnect=false；在网络发送的线程中判断全局变量bConnect==true再调用OutputStream.write()。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>算法刷题（18）_逆时针打印矩阵学习记录</title>
		<link>https://uzzz.org/article/3379.html</link>
				<pubDate>Sat, 28 Jul 2018 21:12:15 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3379.html</guid>
				<description><![CDATA[算法刷题（18）_逆时针打印矩阵学习记录 【说明】 题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵：&#160; 1&#160;&#160; 2&#160;&#160; 3&#160;&#160; 4&#160; 5&#160;&#160; 6&#160;&#160; 7&#160;&#160; 8&#160; 9&#160; 10 11 12&#160; 13 14 15 16&#160; 则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7. 【算法实现】 package p4; /** * 逆时针打印矩阵 * @author Guozhu Zhu * @date 2018/7/29 * @version 1.0 * */ public class Test02 { public static void main(String[] args) { int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}; int[] res = Solution01(arr, 4, 3); for (int i : res) { System.out.println(i); } } public static int[] Solution01(int[][] arr, int n, int m) { int startX = 0; int startY = 0; int endX = m-1; int endY = n-1; int index = 0; int[] res = new int[n*m]; while (startX &#60;= endX &#38;&#38; startY &#60;= endY) { // 上----&#62;下 if (startY &#60;= endY) { for (int i = startY; i &#60;= endY; i++) { res[index++] = arr[i][startX]; } } // 左----&#62;右 (两列以上) if (startX &#60; endX) { for (int i = startX+1; i &#60;= endX; i++) { res[index++] = arr[endY][i]; } } // 下----&#62;上(两行两列以上) if (startX &#60; endX &#38;&#38; startY &#60; endY) { for]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<blockquote>
<p>算法刷题（18）_逆时针打印矩阵学习记录</p>
</blockquote>
<p>【说明】</p>
<p>题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵：&nbsp;<br /> 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;<br /> 5&nbsp;&nbsp; 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;<br /> 9&nbsp; 10 11 12&nbsp;<br /> 13 14 15 16&nbsp;</p>
<p>则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7.</p>
<p>【算法实现】</p>
<pre class="has">
<code class="language-java">package p4;

/**
 * 逆时针打印矩阵
 * @author Guozhu Zhu
 * @date 2018/7/29
 * @version 1.0
 *
 */
public class Test02 {
	
	public static void main(String[] args) {
		int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
		int[] res = Solution01(arr, 4, 3);
		for (int i : res) {
			System.out.println(i);
		}
	}
	
	public static int[] Solution01(int[][] arr, int n, int m) {
		int startX = 0;
		int startY = 0;
		int endX = m-1;
		int endY = n-1;
		int index = 0;
		int[] res = new int[n*m];
		while (startX &lt;= endX &amp;&amp; startY &lt;= endY) {
			// 上----&gt;下
			if (startY &lt;= endY) {
				for (int i = startY; i &lt;= endY; i++) {
					res[index++] = arr[i][startX];
				}
			}
			// 左----&gt;右 (两列以上)
			if (startX &lt; endX) {
				for (int i = startX+1; i &lt;= endX; i++) {
					res[index++] = arr[endY][i];
				}
			}
			// 下----&gt;上(两行两列以上)
			if (startX &lt; endX &amp;&amp; startY &lt; endY) {
				for (int i = endY-1; i &gt;= startY; i--) {
					res[index++] = arr[i][endX];
				}
			}
			// 右----&gt;左(三列两行以上)
			if (startX &lt; endX-1 &amp;&amp; startY &lt; endY) {
				for (int i = endX-1; i &gt;= startX+1; i--) {
					res[index++] = arr[startY][i];
				}
			}
			startX++;
			startY++;
			endX--;
			endY--;
		}
		return res;
	}

}
</code></pre>
<p><img alt="" class="has" height="452" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180729051157287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc3MDAyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="286"></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>jenkins安装及启动</title>
		<link>https://uzzz.org/article/3201.html</link>
				<pubDate>Wed, 04 Jul 2018 09:29:21 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3201.html</guid>
				<description><![CDATA[Jenkins是一个功能强大的应用程序，允许持续集成和持续交付项目，无论用的是什么平台。这是一个免费的源代码，可以处理任何类型的构建或持续集成。集成Jenkins可以用于一些测试和部署技术。Jenkins是一种软件允许持续集成。 官网：https://jenkins.io/ 一、前期准备 1、需要开放8080端口，jenkins默认监听8080端口 2、需要安装java8，jenkins是java开发，需用java运行 二、下载，以下载war包运行为例，前提 wget -P /home/jenkins http://mirrors.jenkins.io/war-stable/latest/jenkins.war 三、启动 cd /home/jenkins/ nohup java -jar /home/jenkins/jenkins.war &#38; 相关启动错误信息可通过vim /home/jenkins/nohup.out查看 1、出现错误 Jenkins requires Java 8, but you are running 1.7.0_181-mockbuild_2018_05_22_02_25-b00 from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.181.x86_64/jre 解决： 升级java版本，安装至java8 2、出现错误： 警告: Could not intialize the host network interface on nullbecause of an error: ecs-90d5: ecs-90d5: 未知的名称或服务 java.net.UnknownHostException: ecs-90d5: ecs-90d5: 未知的名称或服务 解决： vim /etc/hosts 添加一行映射即可 127.0.0.1&#160; &#160;ecs-90d5 四、查看安装秘钥 1、vim /home/jenkins/nohup.out 2、查看字样 Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: 9a8e9681d8f74a5894be57d618c6878b This may also be found at: /root/.jenkins/secrets/initialAdminPassword 3、将其中的密钥（9a8e9681d8f74a5894be57d618c6878b）复制出来 五、安装 在浏览器运行http://安装jenkins的服务器ip:8080/ ，第一次登陆要求输入密钥，将刚刚复制的密钥复制进去， 然后根据资料填写相关信息，插件安装则选择默认安装。期间要求输入登录账号和密码，记住它，然后等待一段时间安装完毕后再登陆进去。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">Jenkins是一个功能强大的应用程序，允许持续集成和持续交付项目，无论用的是什么平台。这是一个免费的源代码，可以处理任何类型的构建或持续集成。集成Jenkins可以用于一些测试和部署技术。Jenkins是一种软件允许持续集成。</span></p>
<p><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;"><span style="background-color:rgb(255,255,255);">官网：https://jenkins.io/</span></span></p>
<p></p>
<p>一、前期准备<br />
  <br />1、需要开放8080端口，jenkins默认监听8080端口<br />
  <br />2、需要安装java8，jenkins是java开发，需用java运行</p>
<p>二、下载，以下载war包运行为例，前提<br />
  <br />wget -P /home/jenkins http://mirrors.jenkins.io/war-stable/latest/jenkins.war</p>
<p>三、启动<br />
  <br />cd /home/jenkins/<br />
  <br />nohup java -jar /home/jenkins/jenkins.war &amp;</p>
<p></p>
<p>相关启动错误信息可通过vim /home/jenkins/nohup.out查看</p>
</p>
<p>1、出现错误</p>
<p>Jenkins requires Java 8, but you are running 1.7.0_181-mockbuild_2018_05_22_02_25-b00 from /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.181.x86_64/jre</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180704181353725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21seDIxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>解决：</p>
<p>升级java版本，安装至java8</p>
<p>2、出现错误：</p>
<p>警告: Could not intialize the host network interface on nullbecause of an error: ecs-90d5: ecs-90d5: 未知的名称或服务</p>
<p>java.net.UnknownHostException: ecs-90d5: ecs-90d5: 未知的名称或服务</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180704181559794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21seDIxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>解决：</p>
<p>vim /etc/hosts</p>
<p>添加一行映射即可</p>
<p>127.0.0.1&nbsp; &nbsp;ecs-90d5</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180704181637414?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21seDIxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p></p>
<p>四、查看安装秘钥<br />
  <br />1、vim /home/jenkins/nohup.out</p>
<p>2、查看字样</p>
<p>Jenkins initial setup is required. An admin user has been created and a password generated.<br />
  <br />Please use the following password to proceed to installation:</p>
<p>9a8e9681d8f74a5894be57d618c6878b</p>
<p>This may also be found at: /root/.jenkins/secrets/initialAdminPassword</p>
<p>3、将其中的密钥（9a8e9681d8f74a5894be57d618c6878b）复制出来</p>
<p>五、安装<br />
  </p>
<p>在浏览器运行http://安装jenkins的服务器ip:8080/ ，第一次登陆要求输入密钥，将刚刚复制的密钥复制进去，</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180704172859301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21seDIxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>然后根据资料填写相关信息，插件安装则选择默认安装。期间要求输入登录账号和密码，记住它，然后等待一段时间安装完毕后再登陆进去。</p>
<p> 
 </div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Ubuntu 16.04 手动安装 Oracle JDK</title>
		<link>https://uzzz.org/article/3141.html</link>
				<pubDate>Mon, 04 Jun 2018 11:56:14 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3141.html</guid>
				<description><![CDATA[Ubuntu 16.04 手动安装 Oracle JDK的步骤： 去 Oracle 官网下载，链接点此 解压到当前目录下 tar -zxvf jdk-8u111-linux-x64.tar.gz 移动解压后的文件夹到自己想要放的位置 mkdir /usr/lib/jdk mv jdk1.8.0_111 /usr/lib/jdk/jdk1.8 设置环境变量 方案一： 修改全局配置文件，作用于所有用户： vim /etc/profile 将下面的代码放在文件的末尾： 　　　　export JAVA_HOME=/usr/lib/jdk/jdk1.8 　　　　export JRE_HOME=${JAVA_HOME}/jre 　　　　export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib 　　　　export PATH=.:${JAVA_HOME}/bin:$PATH 　　　 方案二： 修改当前用户配置文件，只作用于当前用户： vim ~/.bashrc 将下面的代码放在文件的末尾： 　　　　export JAVA_HOME=/usr/lib/jdk/jdk1.8 　　　　export JRE_HOME=${JAVA_HOME}/jre 　　　　export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib 　　　　export PATH=.:${JAVA_HOME}/bin:$PATH 使我们修改的配置立刻生效 source /etc/profile 或者 source ~/.bashrc 检查是否安装成功 java -version]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-github-gist">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>Ubuntu 16.04 手动安装 Oracle JDK的步骤：</p>
<ol>
<li>
<p>去 Oracle 官网下载，<a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" rel="nofollow" data-token="c12e27652eb87d9e932147a13609245e">链接点此</a> </p>
</li>
<li>
<p>解压到当前目录下</p>
<pre class="prettyprint"><code class=" hljs lasso">tar <span class="hljs-attribute">-zxvf</span> jdk<span class="hljs-subst">-</span><span class="hljs-number">8</span>u111<span class="hljs-attribute">-linux</span><span class="hljs-attribute">-x64</span><span class="hljs-built_in">.</span>tar<span class="hljs-built_in">.</span>gz</code></pre>
</li>
<li>
<p>移动解压后的文件夹到自己想要放的位置</p>
<pre class="prettyprint"><code class=" hljs vbnet">mkdir /usr/<span class="hljs-keyword">lib</span>/jdk
mv jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0</span>_111  /usr/<span class="hljs-keyword">lib</span>/jdk/jdk1<span class="hljs-number">.8</span></code></pre>
</li>
<li>
<p>设置环境变量</p>
<pre class="prettyprint"><code class=" hljs bash">方案一：
修改全局配置文件，作用于所有用户：
    vim /etc/profile 
将下面的代码放在文件的末尾：
　　　　<span class="hljs-keyword">export</span> JAVA_HOME=/usr/lib/jdk/jdk1.<span class="hljs-number">8</span>
　　　　<span class="hljs-keyword">export</span> JRE_HOME=<span class="hljs-variable">${JAVA_HOME}</span>/jre
　　　　<span class="hljs-keyword">export</span> CLASSPATH=.:<span class="hljs-variable">${JAVA_HOME}</span>/lib:<span class="hljs-variable">${JRE_HOME}</span>/lib
　　　　<span class="hljs-keyword">export</span> PATH=.:<span class="hljs-variable">${JAVA_HOME}</span>/bin:<span class="hljs-variable">$PATH</span>
　　　
方案二：
修改当前用户配置文件，只作用于当前用户：
    vim ~/.bashrc 
将下面的代码放在文件的末尾：
　　　　<span class="hljs-keyword">export</span> JAVA_HOME=/usr/lib/jdk/jdk1.<span class="hljs-number">8</span>
　　　　<span class="hljs-keyword">export</span> JRE_HOME=<span class="hljs-variable">${JAVA_HOME}</span>/jre
　　　　<span class="hljs-keyword">export</span> CLASSPATH=.:<span class="hljs-variable">${JAVA_HOME}</span>/lib:<span class="hljs-variable">${JRE_HOME}</span>/lib
　　　　<span class="hljs-keyword">export</span> PATH=.:<span class="hljs-variable">${JAVA_HOME}</span>/bin:<span class="hljs-variable">$PATH</span></code></pre>
</li>
<li>
<p>使我们修改的配置立刻生效</p>
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">source</span> /etc/profile 
或者 
<span class="hljs-built_in">source</span> ~/.bashrc</code></pre>
</li>
<li>
<p>检查是否安装成功</p>
<pre class="prettyprint"><code class=" hljs livecodeserver">java -<span class="hljs-built_in">version</span></code></pre>
</li>
</ol></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
