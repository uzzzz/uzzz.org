<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>程序员 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/chengxuyuan/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Fri, 26 Oct 2018 02:33:56 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>程序员 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>深度 &#124; IBM长文解读人工智能、机器学习和认知计算</title>
		<link>https://uzzz.org/article/2569.html</link>
				<pubDate>Fri, 26 Oct 2018 02:33:56 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[人工智能]]></category>
		<category><![CDATA[区块链]]></category>
		<category><![CDATA[大数据]]></category>
		<category><![CDATA[程序员]]></category>
		<category><![CDATA[资讯]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2569.html</guid>
				<description><![CDATA[人工智能的发展曾经经历过几次起起伏伏，近来在深度学习技术的推动下又迎来了一波新的前所未有的高潮。近日，IBM 官网发表了一篇概述文章，对人工智能技术的发展过程进行了简单梳理，同时还图文并茂地介绍了感知器、聚类算法、基于规则的系统、机器学习、深度学习、神经网络等技术的概念和原理。 &#160; 人类对如何创造智能机器的思考从来没有中断过。期间，人工智能的发展起起伏伏，有成功，也有失败，以及其中暗藏的潜力。今天，有太多的新闻报道是关于机器学习算法的应用问题，从癌症检查预测到图像理解、自然语言处理，人工智能正在赋能并改变着这个世界。 &#160; 现代人工智能的历史具备成为一部伟大戏剧的所有元素。在最开始的 1950 年代，人工智能的发展紧紧围绕着思考机器和焦点人物比如艾伦·图灵、冯·诺伊曼，迎来了其第一次春天。经过数十年的繁荣与衰败，以及难以置信的高期望，人工智能及其先驱们再次携手来到一个新境界。现在，人工智能正展现着其真正的潜力，深度学习、认知计算等新技术不断涌现，且不乏应用指向。 &#160; 本文探讨了人工智能及其子领域的一些重要方面。下面就先从人工智能发展的时间线开始，并逐个剖析其中的所有元素。 &#160; &#160; 现代人工智能的时间线 &#160; 1950 年代初期，人工智能聚焦在所谓的强人工智能，希望机器可以像人一样完成任何智力任务。强人工智能的发展止步不前，导致了弱人工智能的出现，即把人工智能技术应用于更窄领域的问题。1980 年代之前，人工智能的研究一直被这两种范式分割着，两营相对。但是，1980 年左右，机器学习开始成为主流，它的目的是让计算机具备学习和构建模型的能力，从而它们可在特定领域做出预测等行为。很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学完往哪方面发展，想深入了解，想学习的同学欢迎加入大数据学习扣群：805127855，有大量干货（零基础以及进阶的经典实战）分享给大家，并且有清华大学毕业的资深大数据讲师给大家免费授课，给大家分享目前国内最完整的大数据高端实战实用学习流程体系 &#160; &#160; 图 1：现代人工智能发展的时间线 &#160; 在人工智能和机器学习研究的基础之上，深度学习在 2000 年左右应运而生。计算机科学家在多层神经网络之中使用了新的拓扑学和学习方法。最终，神经网络的进化成功解决了多个领域的棘手问题。 &#160; 在过去的十年中，认知计算（Cognitive computing）也出现了，其目标是打造可以学习并与人类自然交互的系统。通过成功地击败 Jeopardy 游戏的世界级选手，IBM Watson 证明了认知计算的价值。 &#160; 在本文中，我将逐一探索上述的所有领域，并对一些关键算法作出解释。 基础性人工智能 &#160; 1950 年之前的研究提出了大脑是由电脉冲网络组成的想法，正是脉冲之间的交互产生了人类思想与意识。艾伦·图灵表明一切计算皆是数字，那么，打造一台能够模拟人脑的机器也就并非遥不可及。 &#160; 上文说过，早期的研究很多是强人工智能，但是也提出了一些基本概念，被机器学习和深度学习沿用至今。 &#160; 图 2：1950 &#8211; 1980 年间人工智能方法的时间线 &#160; &#160; 人工智能搜索引擎 &#160; 人工智能中的很多问题可以通过强力搜索（brute-force search）得到解决。然而，考虑到中等问题的搜索空间，基本搜索很快就受影响。人工智能搜索的最早期例子之一是跳棋程序的开发。亚瑟·塞缪尔（Arthur Samuel）在 IBM 701 电子数据处理机器上打造了第一款跳棋程序，实现了对搜索树（alpha-beta 剪枝）的优化；这个程序也记录并奖励具体行动，允许应用学习每一个玩过的游戏（这是首个自我学习的程序）。为了提升程序的学习率，塞缪尔将其编程为自我游戏，以提升其游戏和学习的能力。 &#160; 尽管你可以成功地把搜索应用到很多简单问题上，但是当选择的数量增加时，这一方法很快就会失效。以简单的一字棋游戏为例，游戏一开始，有 9 步可能的走棋，每 1 个走棋有 8 个可能的相反走棋，依次类推。一字棋的完整走棋树包含 362,880 个节点。如果你继续将这一想法扩展到国际象棋或者围棋，很快你就会发展搜索的劣势。 &#160; &#160; 感知器 &#160; 感知器是单层神经网络的一个早期监督学习算法。给定一个输入特征向量，感知器可对输入进行具体分类。通过使用训练集，网络的权重和偏差可为线性分类而更新。感知器的首次实现是 IBM 704，接着在自定义硬件上用于图像识别。 &#160; 图 3：感知器与线性分类 &#160; 作为一个线性分类器，感知器有能力解决线性分离问题。感知器局限性的典型实例是它无法学习专属的 OR （XOR） 函数。多层感知器解决了这一问题，并为更复杂的算法、网络拓扑学、深度学习奠定了基础。 &#160; &#160; 聚类算法 &#160; 使用感知器的方法是有监督的。用户提供数据来训练网络，然后在新数据上对该网络进行测试。聚类算法则是一种无监督学习（unsupervised learning）方法。在这种模型中，算法会根据数据的一个或多个属性将一组特征向量组织成聚类。 &#160; 图 4：在一个二维特征空间中的聚类 &#160; 你可以使用少量代码就能实现的最简单的聚类算法是 k-均值（k-means）。其中，k 表示你为样本分配的聚类的数量。你可以使用一个随机特征向量来对一个聚类进行初始化，然后将其它样本添加到其最近邻的聚类（假定每个样本都能表示一个特征向量，并且可以使用 Euclidean distance 来确定「距离」）。随着你往一个聚类添加的样本越来越多，其形心（centroid，即聚类的中心）就会重新计算。然后该算法会重新检查一次样本，以确保它们都在最近邻的聚类中，最后直到没有样本需要改变所属聚类。 &#160; 尽管 k-均值聚类相对有效，但你必须事先确定 k 的大小。根据数据的不同，其它方法可能会更加有效，比如分层聚类（hierarchical clustering）或基于分布的聚类（distribution-based clustering）。 &#160; &#160; 决策树 &#160; 决策树和聚类很相近。决策树是一种关于观察（observation）的预测模型，可以得到一些结论。结论在决策树上被表示成树叶，而节点则是观察分叉的决策点。决策树来自决策树学习算法，其中数据集会根据属性值测试（attribute value tests）而被分成不同的子集，这个分割过程被称为递归分区（recursive partitioning）。 &#160; 考虑下图中的示例。在这个数据集中，我可以基于三个因素观察到某人是否有生产力。使用一个决策树学习算法，我可以通过一个指标来识别属性（其中一个例子是信息增益）。在这个例子中，心情（mood）是生产力的主要影响因素，所以我根据 Good Mood 一项是 Yes 或 No 而对这个数据集进行了分割。但是，在 Yes 这边，还需要我根据其它两个属性再次对该数据集进行切分。表中不同的颜色对应右侧中不同颜色的叶节点。 &#160; 图 5：一个简单的数据集及其得到的决策树 &#160; 决策树的一个重要性质在于它们的内在的组织能力，这能让你轻松地（图形化地）解释你分类一个项的方式。流行的决策树学习算法包括 C4.5 以及分类与回归树（Classification and Regression Tree）。 &#160; &#160; 基于规则的系统 &#160; 最早的基于规则和推理的系统是 Dendral，于 1965 年被开发出来，但直到 1970 年代，所谓的专家系统（expert systems）才开始大行其道。基于规则的系统会同时存有所需的知识的规则，并会使用一个推理系统（reasoning system）来得出结论。 &#160; 基于规则的系统通常由一个规则集合、一个知识库、一个推理引擎（使用前向或反向规则链）和一个用户接口组成。下图中，我使用了知识「苏格拉底是人」、规则「如果是人，就会死」以及一个交互「谁会死？」 &#160; 图 6：基于规则的系统 &#160; 基于规则的系统已经在语音识别、规划和控制以及疾病识别等领域得到了应用。上世纪 90 年代人们开发的一个监控和诊断大坝稳定性的系统 Kaleidos 至今仍在使用。 &#160; &#160; 机器学习 &#160; 机器学习是人工智能和计算机科学的一个子领域，也有统计学和数学优化方面的根基。机器学习涵盖了有监督学习和无监督学习领域的技术，可用于预测、分析和数据挖掘。机器学习不限于深度学习这一种。但在这一节，我会介绍几种使得深度学习变得如此高效的算法。 &#160; 图 7：机器学习方法的时间线 &#160; &#160; 反向传播 &#160; 神经网络的强大力量源于其多层的结构。单层感知器的训练是很直接的，但得到的网络并不强大。那问题就来了：我们如何训练多层网络呢？这就是反向传播的用武之地。 &#160; 反向传播是一种用于训练多层神经网络的算法。它的工作过程分为两个阶段。第一阶段是将输入传播通过整个神经网络直到最后一层（称为前馈）。第二阶段，该算法会计算一个误差，然后从最后一层到第一层反向传播该误差（调整权重）。 &#160; 图 8：反向传播示意图 &#160; 在训练过程中，该网络的中间层会自己进行组织，将输入空间的部分映射到输出空间。反向传播，使用监督学习，可以识别出输入到输出映射的误差，然后可以据此调整权重（使用一个学习率）来矫正这个误差。反向传播现在仍然是神经网络学习的一个重要方面。随着计算资源越来越快、越来越便宜，它还将继续在更大和更密集的网络中得到应用。 &#160; &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>人工智能的发展曾经经历过几次起起伏伏，近来在深度学习技术的推动下又迎来了一波新的前所未有的高潮。近日，IBM 官网发表了一篇概述文章，对人工智能技术的发展过程进行了简单梳理，同时还图文并茂地介绍了感知器、聚类算法、基于规则的系统、机器学习、深度学习、神经网络等技术的概念和原理。</p>
<p>&nbsp;</p>
<p>人类对如何创造智能机器的思考从来没有中断过。期间，人工智能的发展起起伏伏，有成功，也有失败，以及其中暗藏的潜力。今天，有太多的新闻报道是关于机器学习算法的应用问题，从癌症检查预测到图像理解、自然语言处理，人工智能正在赋能并改变着这个世界。</p>
<p>&nbsp;</p>
<p>现代人工智能的历史具备成为一部伟大戏剧的所有元素。在最开始的 1950 年代，人工智能的发展紧紧围绕着思考机器和焦点人物比如艾伦·图灵、冯·诺伊曼，迎来了其第一次春天。经过数十年的繁荣与衰败，以及难以置信的高期望，人工智能及其先驱们再次携手来到一个新境界。现在，人工智能正展现着其真正的潜力，深度学习、认知计算等新技术不断涌现，且不乏应用指向。</p>
<p>&nbsp;</p>
<p>本文探讨了人工智能及其子领域的一些重要方面。下面就先从人工智能发展的时间线开始，并逐个剖析其中的所有元素。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>现代人工智能的时间线</p>
<p>&nbsp;</p>
<p>1950 年代初期，人工智能聚焦在所谓的强人工智能，希望机器可以像人一样完成任何智力任务。强人工智能的发展止步不前，导致了弱人工智能的出现，即把人工智能技术应用于更窄领域的问题。1980 年代之前，人工智能的研究一直被这两种范式分割着，两营相对。但是，1980 年左右，机器学习开始成为主流，它的目的是让计算机具备学习和构建模型的能力，从而它们可在特定领域做出预测等行为。很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学完往哪方面发展，想深入了解，想学习的同学欢迎加入大数据学习扣群：805127855，有大量干货（零基础以及进阶的经典实战）分享给大家，并且有清华大学毕业的资深大数据讲师给大家免费授课，给大家分享目前国内最完整的大数据高端实战实用学习流程体系<br /> &nbsp;</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="151" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102433240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="691"></p>
<p>图 1：现代人工智能发展的时间线</p>
<p>&nbsp;</p>
<p>在人工智能和机器学习研究的基础之上，深度学习在 2000 年左右应运而生。计算机科学家在多层神经网络之中使用了新的拓扑学和学习方法。最终，神经网络的进化成功解决了多个领域的棘手问题。</p>
<p>&nbsp;</p>
<p>在过去的十年中，认知计算（Cognitive computing）也出现了，其目标是打造可以学习并与人类自然交互的系统。通过成功地击败 Jeopardy 游戏的世界级选手，IBM Watson 证明了认知计算的价值。</p>
<p>&nbsp;</p>
<p>在本文中，我将逐一探索上述的所有领域，并对一些关键算法作出解释。</p>
<p>基础性人工智能</p>
<p>&nbsp;</p>
<p>1950 年之前的研究提出了大脑是由电脉冲网络组成的想法，正是脉冲之间的交互产生了人类思想与意识。艾伦·图灵表明一切计算皆是数字，那么，打造一台能够模拟人脑的机器也就并非遥不可及。</p>
<p>&nbsp;</p>
<p>上文说过，早期的研究很多是强人工智能，但是也提出了一些基本概念，被机器学习和深度学习沿用至今。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="184" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102459645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="667"></p>
<p>图 2：1950 &#8211; 1980 年间人工智能方法的时间线</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>人工智能搜索引擎</p>
<p>&nbsp;</p>
<p>人工智能中的很多问题可以通过强力搜索（brute-force search）得到解决。然而，考虑到中等问题的搜索空间，基本搜索很快就受影响。人工智能搜索的最早期例子之一是跳棋程序的开发。亚瑟·塞缪尔（Arthur Samuel）在 IBM 701 电子数据处理机器上打造了第一款跳棋程序，实现了对搜索树（alpha-beta 剪枝）的优化；这个程序也记录并奖励具体行动，允许应用学习每一个玩过的游戏（这是首个自我学习的程序）。为了提升程序的学习率，塞缪尔将其编程为自我游戏，以提升其游戏和学习的能力。</p>
<p>&nbsp;</p>
<p>尽管你可以成功地把搜索应用到很多简单问题上，但是当选择的数量增加时，这一方法很快就会失效。以简单的一字棋游戏为例，游戏一开始，有 9 步可能的走棋，每 1 个走棋有 8 个可能的相反走棋，依次类推。一字棋的完整走棋树包含 362,880 个节点。如果你继续将这一想法扩展到国际象棋或者围棋，很快你就会发展搜索的劣势。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>感知器</p>
<p>&nbsp;</p>
<p>感知器是单层神经网络的一个早期监督学习算法。给定一个输入特征向量，感知器可对输入进行具体分类。通过使用训练集，网络的权重和偏差可为线性分类而更新。感知器的首次实现是 IBM 704，接着在自定义硬件上用于图像识别。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="273" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102530403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="653"></p>
<p>图 3：感知器与线性分类</p>
<p>&nbsp;</p>
<p>作为一个线性分类器，感知器有能力解决线性分离问题。感知器局限性的典型实例是它无法学习专属的 OR （XOR） 函数。多层感知器解决了这一问题，并为更复杂的算法、网络拓扑学、深度学习奠定了基础。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>聚类算法</p>
<p>&nbsp;</p>
<p>使用感知器的方法是有监督的。用户提供数据来训练网络，然后在新数据上对该网络进行测试。聚类算法则是一种无监督学习（unsupervised learning）方法。在这种模型中，算法会根据数据的一个或多个属性将一组特征向量组织成聚类。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="344" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2018102610255187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="696"></p>
<p>图 4：在一个二维特征空间中的聚类</p>
<p>&nbsp;</p>
<p>你可以使用少量代码就能实现的最简单的聚类算法是 k-均值（k-means）。其中，k 表示你为样本分配的聚类的数量。你可以使用一个随机特征向量来对一个聚类进行初始化，然后将其它样本添加到其最近邻的聚类（假定每个样本都能表示一个特征向量，并且可以使用 Euclidean distance 来确定「距离」）。随着你往一个聚类添加的样本越来越多，其形心（centroid，即聚类的中心）就会重新计算。然后该算法会重新检查一次样本，以确保它们都在最近邻的聚类中，最后直到没有样本需要改变所属聚类。</p>
<p>&nbsp;</p>
<p>尽管 k-均值聚类相对有效，但你必须事先确定 k 的大小。根据数据的不同，其它方法可能会更加有效，比如分层聚类（hierarchical clustering）或基于分布的聚类（distribution-based clustering）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>决策树</p>
<p>&nbsp;</p>
<p>决策树和聚类很相近。决策树是一种关于观察（observation）的预测模型，可以得到一些结论。结论在决策树上被表示成树叶，而节点则是观察分叉的决策点。决策树来自决策树学习算法，其中数据集会根据属性值测试（attribute value tests）而被分成不同的子集，这个分割过程被称为递归分区（recursive partitioning）。</p>
<p>&nbsp;</p>
<p>考虑下图中的示例。在这个数据集中，我可以基于三个因素观察到某人是否有生产力。使用一个决策树学习算法，我可以通过一个指标来识别属性（其中一个例子是信息增益）。在这个例子中，心情（mood）是生产力的主要影响因素，所以我根据 Good Mood 一项是 Yes 或 No 而对这个数据集进行了分割。但是，在 Yes 这边，还需要我根据其它两个属性再次对该数据集进行切分。表中不同的颜色对应右侧中不同颜色的叶节点。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="184" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102620416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="683"></p>
<p>图 5：一个简单的数据集及其得到的决策树</p>
<p>&nbsp;</p>
<p>决策树的一个重要性质在于它们的内在的组织能力，这能让你轻松地（图形化地）解释你分类一个项的方式。流行的决策树学习算法包括 C4.5 以及分类与回归树（Classification and Regression Tree）。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>基于规则的系统</p>
<p>&nbsp;</p>
<p>最早的基于规则和推理的系统是 Dendral，于 1965 年被开发出来，但直到 1970 年代，所谓的专家系统（expert systems）才开始大行其道。基于规则的系统会同时存有所需的知识的规则，并会使用一个推理系统（reasoning system）来得出结论。</p>
<p>&nbsp;</p>
<p>基于规则的系统通常由一个规则集合、一个知识库、一个推理引擎（使用前向或反向规则链）和一个用户接口组成。下图中，我使用了知识「苏格拉底是人」、规则「如果是人，就会死」以及一个交互「谁会死？」</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="377" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2018102610264788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="674"></p>
<p>图 6：基于规则的系统</p>
<p>&nbsp;</p>
<p>基于规则的系统已经在语音识别、规划和控制以及疾病识别等领域得到了应用。上世纪 90 年代人们开发的一个监控和诊断大坝稳定性的系统 Kaleidos 至今仍在使用。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>机器学习</p>
<p>&nbsp;</p>
<p>机器学习是人工智能和计算机科学的一个子领域，也有统计学和数学优化方面的根基。机器学习涵盖了有监督学习和无监督学习领域的技术，可用于预测、分析和数据挖掘。机器学习不限于深度学习这一种。但在这一节，我会介绍几种使得深度学习变得如此高效的算法。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="193" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102726685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="674"></p>
<p>图 7：机器学习方法的时间线</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>反向传播</p>
<p>&nbsp;</p>
<p>神经网络的强大力量源于其多层的结构。单层感知器的训练是很直接的，但得到的网络并不强大。那问题就来了：我们如何训练多层网络呢？这就是反向传播的用武之地。</p>
<p>&nbsp;</p>
<p>反向传播是一种用于训练多层神经网络的算法。它的工作过程分为两个阶段。第一阶段是将输入传播通过整个神经网络直到最后一层（称为前馈）。第二阶段，该算法会计算一个误差，然后从最后一层到第一层反向传播该误差（调整权重）。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="521" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102749384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="669"></p>
<p>图 8：反向传播示意图</p>
<p>&nbsp;</p>
<p>在训练过程中，该网络的中间层会自己进行组织，将输入空间的部分映射到输出空间。反向传播，使用监督学习，可以识别出输入到输出映射的误差，然后可以据此调整权重（使用一个学习率）来矫正这个误差。反向传播现在仍然是神经网络学习的一个重要方面。随着计算资源越来越快、越来越便宜，它还将继续在更大和更密集的网络中得到应用。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>卷积神经网络</p>
<p>&nbsp;</p>
<p>卷积神经网络（CNN）是受动物视觉皮层启发的多层神经网络。这种架构在包括图像处理的很多应用中都有用。第一个 CNN 是由 Yann LeCun 创建的，当时 CNN 架构主要用于手写字符识别任务，例如读取邮政编码。</p>
<p>LeNet CNN 由好几层能够分别实现特征提取和分类的神经网络组成。图像被分为多个可以被接受的区域，这些子区域进入到一个能够从输入图像提取特征的卷积层。下一步就是池化，这个过程降低了卷积层提取到的特征的维度（通过下采样的方法），同时保留了最重要的信息（通常通过最大池化的方法）。然后这个算法又执行另一次卷积和池化，池化之后便进入一个全连接的多层感知器。卷积神经网络的最终输出是一组能够识别图像特征的节点（在这个例子中，每个被识别的数字都是一个节点）。使用者可以通过反向传播的方法来训练网络。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="150" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102828234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="641"></p>
<p>图 9.LeNet 卷积神经网络架构</p>
<p>&nbsp;</p>
<p>对深层处理、卷积、池化以及全连接分类层的使用打开了神经网络的各种新型应用的大门。除了图像处理之外，卷积神经网络已经被成功地应用在了视频识别以及自然语言处理等多种任务中。卷积神经网络也已经在 GPU 上被有效地实现，这极大地提升了卷积神经网络的性能。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>长短期记忆（LSTM）</p>
<p>&nbsp;</p>
<p>记得前面反向传播中的讨论吗？网络是前馈式的训练的。在这种架构中，我们将输入送到网络并且通过隐藏层将它们向前传播到输出层。但是，还存在其他的拓扑结构。我在这里要研究的一个架构允许节点之间形成直接的回路。这些神经网络被称为循环神经网络（RNN），它们可以向前面的层或者同一层的后续节点馈送内容。这一特性使得这些网络对时序数据而言是理想化的。</p>
<p>&nbsp;</p>
<p>在 1997 年，一种叫做长短期记忆（LSTM）的特殊的循环网络被发明了。LSTM 包含网络中能够长时间或者短时间记忆数值的记忆单元。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="327" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2018102610285835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="670"></p>
<p>图 10. 长短期记忆网络和记忆单元</p>
<p>&nbsp;</p>
<p>记忆单元包含了能够控制信息流入或者流出该单元的一些门。输入门（input gate）控制什么时候新的信息可以流入记忆单元。遗忘门（forget gate）控制一段信息在记忆单元中存留的时间。最后，输出门（output gate）控制输出何时使用记忆单元中包含的信息。记忆单元还包括控制每一个门的权重。训练算法（通常是通过时间的反向传播（backpropagation-through-time），反向传播算法的一种变体）基于所得到的误差来优化这些权重。</p>
<p>LSTM 已经被应用在语音识别、手写识别、语音合成、图像描述等各种任务中。下面我还会谈到 LSTM。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>深度学习</p>
<p>&nbsp;</p>
<p>深度学习是一组相对新颖的方法集合，它们从根本上改变了机器学习。深度学习本身不是一种算法，但是它是一系列可以用无监督学习实现深度网络的算法。这些网络是非常深层的，所以需要新的计算方法来构建它们，例如 GPU，除此之外还有计算机集群。</p>
<p>&nbsp;</p>
<p>本文目前已经介绍了两种深度学习的算法：卷积神经网络和长短期记忆网络。这些算法已经被结合起来实现了一些令人惊讶的智能任务。如下图所示，卷积神经网络和长短期记忆已经被用来识别并用自然语言描述图片或者视频中的物体。</p>
<p>&nbsp;</p>
<p><img alt="" class="has" height="120" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20181026102924996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NxYWNyeTI3OTg=,size_27,color_FFFFFF,t_70" width="675"></p>
<p>图 11. 结合卷积神经网络和长短期记忆来进行图像描述</p>
<p>&nbsp;</p>
<p>深度学习算法也已经被用在了人脸识别中，也能够以 96% 的准确率来识别结核病，还被用在自动驾驶和其他复杂的问题中。</p>
<p>&nbsp;</p>
<p>然而，尽管运用深度学习算法有着很多结果，但是仍然存在问题需要我们去解决。一个最近的将深度学习用于皮肤癌检测的应用发现，这个算法比经过认证的皮肤科医生具有更高的准确率。但是，医生可以列举出导致其诊断结果的因素，却没有办法知道深度学习程序在分类的时候所用的因素。这被称为深度学习的黑箱问题。</p>
<p>&nbsp;</p>
<p>另一个被称为 Deep Patient 的应用，在提供病人的病例时能够成功地预测疾病。该应用被证明在疾病预测方面比医生还做得好——即使是众所周知的难以预测的精神分裂症。所以，即便模型效果良好，也没人能够深入到这些大型神经网络去找到原因。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>认知计算</p>
<p>&nbsp;</p>
<p>人工智能和机器学习充满了生物启示的案例。尽管早期的人工智能专注于建立模仿人脑的机器这一宏伟目标，而现在，是认知计算正在朝着这个目标迈进。</p>
<p>&nbsp;</p>
<p>认知计算建立在神经网络和深度学习之上，运用认知科学中的知识来构建能够模拟人类思维过程的系统。然而，认知计算覆盖了好多学科，例如机器学习、自然语言处理、视觉以及人机交互，而不仅仅是聚焦于某个单独的技术。</p>
<p>&nbsp;</p>
<p>认知学习的一个例子就是 IBM 的 Waston，它在 Jeopardy 上展示了当时最先进的问答交互。IBM 已经将其扩展在了一系列的 web 服务上了。这些服务提供了用于一些列应用的编程接口来构建强大的虚拟代理，这些接口有：视觉识别、语音文本转换（语音识别）、文本语音转换（语音合成）、语言理解和翻译、以及对话引擎。</p>
<p>很多初学者，对大数据的概念都是模糊不清的，大数据是什么，能做什么，学的时候，该按照什么线路去学习，学完往哪方面发展，想深入了解，想学习的同学欢迎加入大数据学习扣群：805127855，有大量干货（零基础以及进阶的经典实战）分享给大家，并且有清华大学毕业的资深大数据讲师给大家免费授课，给大家分享目前国内最完整的大数据高端实战实用学习流程体系<br /> &nbsp;</p>
<p>&nbsp;</p>
<p>继续前进</p>
<p>&nbsp;</p>
<p>本文仅仅涵盖了关于人工智能历史以及最新的神经网络和深度学习方法的一小部分。尽管人工智能和机器学习经历了很多起起伏伏，但是像深度学习和认知计算这样的新方法已经明显地提升了这些学科的水平。虽然可能还无法实现一个具有意识的机器，但是今天确实有着能够改善人类生活的人工智能系统。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>win10、ubuntu16.04双系统双硬盘安装踩坑记录</title>
		<link>https://uzzz.org/article/3217.html</link>
				<pubDate>Sun, 02 Sep 2018 12:33:37 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[程序员]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3217.html</guid>
				<description><![CDATA[坑1：镜像文件和版本的选择 我开始用的是虚拟机下载的16.04版本，可能是因为使用了虚拟机过后，镜像源出现了问题，安装后出现了不少错误，并且进入系统后也存在问题，安装体验很不好，后来下载最新版的18.04版本，在安装时一进入安装界面就会卡死，也不知道什么问题，虽说新版本很有吸引力，但是如果你只是为了学习和熟悉linux下的操作，不建议使用太新的版本。 最后我从官网上下载了16.04版本，整个安装过程没有出现异常，只是在开机后可以登录，但是无法显示桌面，下面说这个。 坑2：安装好后可以登录系统，但是无法显示桌面 出现这种问题主要是显卡驱动的问题，我的显卡是NAVIDIA GeForce GTX 1050的，可以在win10中的设备管理器中的显示设备中查看，感觉ubuntu对NAVIDIA的支持不是很好，需要自己手动安装驱动才行。 首先在选择系统的界面选中Ubuntu，然后按e键进入编辑模式，在linux最后的splash后添加单独的一个单词：nomodeset，然后按F10保存并进入系统，这次可以正常进入系统。 进入后需要手动安装驱动，因为我是NAVIDIA的显卡驱动，所以只实验了NAVIDIA的，其他出现类似问题的解决方法应该类似吧（可能），首先进入NAVIDIA的驱动选择界面，然后根据你的显卡类型选择相应的驱动，其中Product series 根据你显卡后面的数字，比如1050就是10，点击搜索后出现驱动的版本Version ，记住版本的整数部分就行，然后在终端依次输入如下命令： sudo add-apt-repository ppa:graphics-drivers/ppa sudo apt-get update sudo apt-get install nvidia-390 #此处要根据上面查询到的版本适当更改 sudo apt-get install mesa-common-dev sudo apt-get install freeglut3-dev 重启设备，进入系统后就可正常运行。 坑3：进入系统后没有亮度调节条，无法调节亮度 这种情况也是驱动的问题，如坑2那样操作之后就可以自由调节亮度了。 坑4：进入系统后无法识别无线网络，无法联网 这种情况我在虚拟机下载的unbutu16.04版本安装过程中遇到过，按照网上说的方法瞎操作一通，配置静态动态ip，添加dns，都没用，我感觉还是iso镜像源的问题，与其浪费时间，不如换个镜像源试试，说不定就行了，后来我从官网上下载的镜像源安装好后就可以直接识别无线网，不需要手动配置了。 坑5：分区问题 总结了一下网上说的分区的误区和成功经验。分区是在安装的时候，系统询问是否和windows共存，千万不要点和windows共存，因为这样的不可控会导致ubuntu的空间可能会占据windows的空间，导致windows有很大几率打不开，选择最底下的其他选项，自己配置空间。 配置的方法网上基本上都一样，我这里记录下各个区的作用和大概分配的比例： /boot ： 主分区，存放的是ubuntu的启动等关键程序，200M是肯定不够的，500M保底，如果你整体空间很多，1G也不为过 swap ：交换分区，跟内存一样大或者大点都可以 / ：根分区，存放系统软件和系统配置等，与C盘的作用有点类似，不过C盘也包含了/boot的功能，一般10到20G之间，同样整体很大的话30G也不为过 /home ：用户分区，存放的是每个用户自己的数据，例如图片、文档、视频、软件等，一般是前三个分完之后剩下的空间作为该分区的空间 坑6：最好别随意升级！卡住警告！ 如果你选择的是16.04版本，进入系统后如果你有更新软件的操作，会弹出一个对话框告诉你发现了新版本18.04，问你是否升级，如果你点了立即升级，那么能不能升级成功就看你运气了，反正我是卡在了installing snap……那里，原因是snap的下载时间太长了。网上也有不少升级时卡住的例子，建议如果想升级到18.04，直接去官网下载安装，只要不把/home的内容格式化了基本没啥影响。 但是还是开头那句话，新的不一定最适合你。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h1 id="坑1镜像文件和版本的选择">坑1：镜像文件和版本的选择</h1>
<p>我开始用的是<strong>虚拟机下载的16.04版本</strong>，可能是因为使用了虚拟机过后，镜像源出现了问题，安装后出现了不少错误，并且进入系统后也存在问题，安装体验很不好，后来下载<strong>最新版的18.04版本</strong>，在安装时一进入安装界面就会卡死，也不知道什么问题，虽说新版本很有吸引力，但是如果你只是为了学习和熟悉linux下的操作，不建议使用太新的版本。</p>
<p>最后我从<strong>官网上下载了16.04版本</strong>，整个安装过程没有出现异常，只是在开机后可以登录，但是无法显示桌面，下面说这个。</p>
<h1 id="坑2安装好后可以登录系统但是无法显示桌面">坑2：安装好后可以登录系统，但是无法显示桌面</h1>
<p>出现这种问题主要是<strong>显卡驱动</strong>的问题，我的显卡是NAVIDIA GeForce GTX 1050的，可以在win10中的设备管理器中的显示设备中查看，感觉ubuntu对NAVIDIA的支持不是很好，需要自己手动安装驱动才行。</p>
<p>首先在选择系统的界面选中Ubuntu，然后按e键进入编辑模式，在linux最后的splash后添加单独的一个单词：nomodeset，然后按F10保存并进入系统，这次可以正常进入系统。</p>
<p>进入后需要手动安装驱动，因为我是NAVIDIA的显卡驱动，所以只实验了NAVIDIA的，其他出现类似问题的解决方法应该类似吧（可能），首先进入<a href="https://www.nvidia.com/Download/index.aspx?lang=en-us" rel="nofollow" data-token="098abe3f63ac9d91416d23c72f97020a">NAVIDIA的驱动选择界面</a>，然后根据你的显卡类型选择相应的驱动，其中<code>Product series</code> 根据你显卡后面的数字，比如1050就是10，点击搜索后出现驱动的版本<code>Version</code> ，记住版本的整数部分就行，然后在终端依次输入如下命令：</p>
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-built_in">sudo</span> add-apt-repository ppa:graphics-drivers/ppa  
<span class="hljs-built_in">sudo</span> apt-get update  
<span class="hljs-built_in">sudo</span> apt-get install nvidia-<span class="hljs-number">390</span> <span class="hljs-comment">#此处要根据上面查询到的版本适当更改</span>
<span class="hljs-built_in">sudo</span> apt-get install mesa-common-dev  
<span class="hljs-built_in">sudo</span> apt-get install freeglut3-dev</code></pre>
<p>重启设备，进入系统后就可正常运行。</p>
<h1 id="坑3进入系统后没有亮度调节条无法调节亮度">坑3：进入系统后没有亮度调节条，无法调节亮度</h1>
<p>这种情况也是驱动的问题，如坑2那样操作之后就可以自由调节亮度了。</p>
<h1 id="坑4进入系统后无法识别无线网络无法联网">坑4：进入系统后无法识别无线网络，无法联网</h1>
<p>这种情况我在虚拟机下载的unbutu16.04版本安装过程中遇到过，按照网上说的方法瞎操作一通，配置静态动态ip，添加dns，都没用，我感觉还是iso镜像源的问题，与其浪费时间，不如<strong>换个镜像源</strong>试试，说不定就行了，后来我从官网上下载的镜像源安装好后就可以直接识别无线网，不需要手动配置了。</p>
<h1 id="坑5分区问题">坑5：分区问题</h1>
<p>总结了一下网上说的分区的误区和成功经验。分区是在安装的时候，系统询问是否和windows共存，<strong>千万不要点和windows共存</strong>，因为这样的不可控会导致ubuntu的空间可能会占据windows的空间，导致windows有很大几率打不开，选择最底下的<strong>其他选项</strong>，自己配置空间。</p>
<p>配置的方法网上基本上都一样，我这里记录下各个区的作用和大概分配的比例：</p>
<ul>
<li><strong>/boot</strong> ： 主分区，存放的是ubuntu的启动等关键程序，200M是肯定不够的，500M保底，如果你整体空间很多，1G也不为过</li>
<li><strong>swap</strong> ：交换分区，跟内存一样大或者大点都可以</li>
<li><strong>/</strong> ：根分区，存放系统软件和系统配置等，与C盘的作用有点类似，不过C盘也包含了/boot的功能，一般10到20G之间，同样整体很大的话30G也不为过</li>
<li><strong>/home</strong> ：用户分区，存放的是每个用户自己的数据，例如图片、文档、视频、软件等，一般是前三个分完之后剩下的空间作为该分区的空间</li>
</ul>
<h1 id="坑6最好别随意升级卡住警告">坑6：最好别随意升级！卡住警告！</h1>
<p>如果你选择的是16.04版本，进入系统后如果你有更新软件的操作，会弹出一个对话框告诉你发现了新版本18.04，问你是否升级，如果你点了立即升级，那么能不能升级成功就看你运气了，反正我是卡在了installing snap……那里，原因是snap的下载时间太长了。网上也有不少升级时卡住的例子，建议如果想升级到18.04，直接去官网下载安装，只要不把/home的内容格式化了基本没啥影响。</p>
<p>但是还是开头那句话，新的不一定最适合你。</p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……</title>
		<link>https://uzzz.org/article/2109.html</link>
				<pubDate>Wed, 29 Aug 2018 08:48:54 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[程序员]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2109.html</guid>
				<description><![CDATA[&#160; 来源：黑客网络技术与安全 朋友圈被一条信息刷屏：暗网中文论坛一个ID为 helen250 的发帖人发帖出售华住旗下所有酒店数据，包括汉庭酒店、美爵、禧玥、漫心、诺富特、美居、CitiGo、桔子、全季、星程、宜必思、怡莱、海友等，泄露数据总数更是近&#160;5亿！ &#160; 紫豹科技的情报专家通过技术手段验证了这批数据的真伪，称数据绝大部分为新泄露数据，而非老数据混杂售卖。 &#160; &#160; 售卖的数据包括三个部分： 1. 华住官网注册资料包括姓名、手机号、邮箱、身份证号、登录密码等，共&#160;53 G，大约&#160;1.23 亿条记录； 2. 酒店入住登记身份信息包括姓名、身份证号、家庭住址、生日、内部 ID 号，共&#160;22.3 G，约&#160;1.3 亿人身份证信息； 3. 酒店开房记录包括内部 id 号，同房间关联号、姓名、卡号、手机号、邮箱、入住时间、离开时间、酒店 id 号、房间号、消费金额等，共&#160;66.2 G，约&#160;2.4 亿条记录。 &#160; 本次事件疑似华住公司程序员将数据库连接方式上传至GitHub导致其泄露；黑客称在8月14日进行脱裤，此数据库连接方式在20天前上传至GitHub，时间上大致吻合。 &#160; 发帖人还称打包出售的价格总共是 8 个比特币，按照今天的汇率，1比特币是47081.67 元，换算成人民币为&#160;376477&#160;元 &#160; 对于这件事情华住酒店官方回应称：正在核实数据来源，并且已经报了警！ &#160; 详细声明如下： &#160; 若此次数据泄露事件属实，该事件或成国内近几年最严重的信息数据事件。为保险起见，如果你曾经在华住旗下的酒店开过房，请及时修改账号密码。 写在最后 大咖的话：“最近有很多想学习编程的朋友问我有没有什么好的编程资料！因为最近今年我都在认真搜集有价值的编程资料，技术资料，只为帮助那些想学习编程而不知道从哪开始的朋友。 下图就是（部分资料截图）： &#160; 以上价值5万元的资料，绝对比群里那些漫天飞的资料强多了。今天决定免费分享，用来感谢大家的支持。” 免费获取方式： 添加大咖Vx：“cquan123456”，即可免费领取最新价值5万元全栈开发视频资料！，一定要备注：“大咖，CSDN来的领资料”，否则不能通过！ 觉得不错请点赞，欢迎留言分享！]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p3.pstatp.com/large/pgc-image/15355312030220999d13b67"></p>
<p>&nbsp;</p>
<blockquote>
<p>来源：黑客网络技术与安全</p>
</blockquote>
<p>朋友圈被一条信息刷屏：暗网中文论坛一个ID为 helen250 的发帖人发帖出售华住旗下所有酒店数据，包括汉庭酒店、美爵、禧玥、漫心、诺富特、美居、CitiGo、桔子、全季、星程、宜必思、怡莱、海友等，泄露数据总数更是近&nbsp;<strong>5亿！</strong></p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/153553120289552e0890461"></p>
<p>&nbsp;</p>
<p>紫豹科技的情报专家通过技术手段验证了这批数据的真伪，称数据绝大部分为新泄露数据，而非老数据混杂售卖。</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/1535531202909e5600f0ed1"></p>
<p>&nbsp;</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p3.pstatp.com/large/pgc-image/1535531202919f0dd2b3c6b"></p>
<p>&nbsp;</p>
<p><strong>售卖的数据包括三个部分：</strong></p>
<p>1. 华住官网注册资料包括姓名、手机号、邮箱、身份证号、登录密码等，共<strong>&nbsp;53 G</strong>，大约<strong>&nbsp;1.23 亿</strong>条记录；</p>
<p>2. 酒店入住登记身份信息包括姓名、身份证号、家庭住址、生日、内部 ID 号，共&nbsp;<strong>22.3 G</strong>，约&nbsp;<strong>1.3 亿</strong>人身份证信息；</p>
<p>3. 酒店开房记录包括内部 id 号，同房间关联号、姓名、卡号、手机号、邮箱、入住时间、离开时间、酒店 id 号、房间号、消费金额等，共<strong>&nbsp;66.2 G</strong>，约<strong>&nbsp;2.4 亿</strong>条记录。</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/1535531203039a6b28f8e85"></p>
<p>&nbsp;</p>
<p>本次事件<strong>疑似华住公司程序员将数据库连接方式上传至GitHub导致其泄露</strong>；黑客称在8月14日进行脱裤，此数据库连接方式在20天前上传至GitHub，时间上大致吻合。</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/15355312030797a88db0733"></p>
<p>&nbsp;</p>
<p>发帖人还称打包出售的价格总共是 8 个比特币，按照今天的汇率，1比特币是47081.67 元，换算成人民币为&nbsp;<strong>376477</strong>&nbsp;元</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/1535531273654a428185a98"></p>
<p>&nbsp;</p>
<p>对于这件事情<strong>华住酒店官方回应称：</strong>正在核实数据来源，并且已经报了警！</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p99.pstatp.com/large/pgc-image/1535531203187d7ac335cab"></p>
<p>&nbsp;</p>
<p>详细声明如下：</p>
<p><img alt="程序员又要背锅！华住5亿开房记录被裸奔，也许就有你……" class="has" src="http://p3.pstatp.com/large/pgc-image/1535531203162ea02ad09b3"></p>
<p>&nbsp;</p>
<p>若此次数据泄露事件属实，该事件或成国内近几年最严重的信息数据事件。为保险起见，如果你曾经在华住旗下的酒店开过房，请及时修改账号密码。</p>
<h1><strong>写在最后</strong></h1>
<p><strong>大咖的话：</strong>“最近有很多想学习编程的朋友问我有没有什么好的编程资料！因为最近今年我都在认真搜集有价值的编程资料，技术资料，只为帮助那些想学习编程而不知道从哪开始的朋友。</p>
<p>下图就是（部分资料截图）：</p>
<p><img alt="程序媛去面试，HR只看了一眼便让她走了：键盘都看不到还来面试？" class="has" src="http://p99.pstatp.com/large/pgc-image/1535341935319cf62af3036"></p>
<p>&nbsp;</p>
<p>以上价值5万元的资料，绝对比群里那些漫天飞的资料强多了。今天决定免费分享，用来感谢大家的支持。”</p>
<p><strong>免费获取方式：</strong></p>
<blockquote>
<p>添加大咖Vx：“<strong>cquan123456</strong>”，即可免费领取最新价值<strong>5万元全栈开发</strong>视频资料！，一定要备注：“<strong>大咖，CSDN来的领资料</strong>”，否则不能通过！</p>
</blockquote>
<p>觉得不错请点赞，欢迎留言分享！</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>usaco总结</title>
		<link>https://uzzz.org/article/3280.html</link>
				<pubDate>Tue, 27 Feb 2018 08:28:22 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[AI]]></category>
		<category><![CDATA[程序员]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3280.html</guid>
				<description><![CDATA[咕噜~~ 这次usaco没有打上银组真是让我尴尬，第一次打usaco，有点紧张。。。 同组第一题的传送牛粪，虽不知道何必如此大费周章，但也是一代水题 题面是这样的： Farmer John最讨厌的农活是运输牛粪。为了精简这个过程，他制造了一个伟大的发明：便便传送门！与使用拖拉机拖着装满牛粪的大车从一个地点到另一个地点相比，他可以使用便便传送门将牛粪从一个地点瞬间传送到另一个地点。 Farmer John的农场沿着一条长直道路而建，所以他农场上的每个地点都可以简单地用该地点在道路上的位置来表示（相当于数轴上的一个点）。一个传送门可以用两个数xx和yy表示，被拖到地点xx的牛粪可以瞬间传送到地点yy，反之亦然。 Farmer John想要将牛粪从地点aa运输到地点bb，他建造了一个可能对这一过程有所帮助的传送门（当然，如果没有帮助，他也可以不用）。请帮助他求出他需要使用拖拉机运输牛粪的总距离的最小值。 &#160; 输入格式（文件名：teleport.in）： 输入仅包含一行，为四个用空格分隔的整数：aa和bb，表示起始地点和结束地点，后面是xx和yy，表示传送门。所有的位置都是范围为0…1000…100的整数，不一定各不相同。 &#160; 输出格式（文件名：teleport.out）： 输出一个整数，为Farmer John需要用拖拉机运输牛粪的最小距离。 &#160; 输入样例： 3 10 8 2 输出样例： 3 在这个样例中，最佳策略是将牛粪从位置3运到位置2，传送到位置8，再运到位置10。 所以需要用拖拉机的总距离为1 + 2 = 3。 这题我采用了模拟法，一遍过，代码如下 #include&#60;bits/stdc++.h&#62; using namespace std; int a,b,x,y,i,j; long long n=0,m=0; int main() { freopen("teleport.in","r",stdin); freopen("teleport.out","w",stdout); cin&#62;&#62;a&#62;&#62;b&#62;&#62;x&#62;&#62;y; if(b&#62;a) { n=b-a; if(x&#62;y) &#160;{ &#160; &#160;if(a&#62;y) &#160; &#160; &#160;m+=a-y; &#160; &#160;else &#160; &#160; &#160;m+=y-a; &#160; &#160;if(b&#62;x) &#160; &#160; &#160;m+=b-x; &#160; &#160;else &#160;m+=x-b; &#160; &#160; &#160; &#160;} else &#160;{ &#160; if(a&#62;x) &#160; &#160; m+=a-x; &#160; else &#160; &#160; m+=x-a; &#160; if(b&#62;y) &#160; &#160;m+=b-y; &#160; else &#160; &#160;m+=y-b; &#160;} } else { &#160;&#160; &#160; n=a-b; if(x&#62;y) &#160;{ &#160; if(a&#62;x) &#160; &#160; m+=a-x; &#160; else &#160; &#160; m+=x-a; &#160; if(b&#62;y) &#160; &#160;m+=b-y; &#160; else &#160; &#160;m+=y-b; } else &#160;{ &#160; &#160; &#160;if(a&#62;y) &#160; &#160; &#160;m+=a-y; &#160; &#160;else &#160; &#160; &#160;m+=y-a; &#160; &#160;if(b&#62;x) &#160; &#160; &#160;m+=b-x; &#160; &#160;else &#160;m+=x-b; &#160; &#160; &#160; &#160;} &#160; } if(n&#62;m) &#160;cout&#60;&#60;m; else &#160;cout&#60;&#60;n; fclose(stdin); fclose(stdout); return 0; } 很长，可以简洁很多，但这样写思路会更清晰，AC后也就没想过化简。 第二题，让我崩溃了两次，死循环了3次，wa了8个点，最终终于还是AC了； 为了准备即将到来的蹄球锦标赛，Farmer John正在训练他的NN头奶牛（方便起见，编号为1…N1…N，其中1≤N≤1001≤N≤100）进行传球。这些奶牛在牛棚一侧沿直线排列，第ii号奶牛位于距离牛棚xixi的地方(1≤xi≤10001≤xi≤1000)。每头奶牛都在不同的位置上。 在训练开始的时候，Farmer John会将若干个球传给不同的奶牛。当第ii号奶牛接到球时，无论是从Farmer John或是从另一头奶牛传来的，她会将球传给最近的奶牛（如果有多头奶牛与她距离相同，她会传给其中距左边最远的那头奶牛）。为了使所有奶牛都有机会练习到传球，Farmer John想要确保每头奶牛都持球至少一次。帮助他求出为了达到这一目的他开始时至少要传出的球的数量。假设他在开始的时候能将球传给最适当的一组奶牛。 &#160; 输入格式（文件名：hoofball.in）： 输入的第一行包含NN。第二行包含NN个用空格分隔的整数，其中第ii个整数为xixi。 &#160; 输出格式（文件名：hoofball.out）： 输出Farmer John开始的时候最少需要传出的球的数量，使得所有奶牛至少持球一次。 &#160; 输入样例： 5 7 1 3 11]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>咕噜~~</p>
<p>这次usaco没有打上银组真是让我尴尬，第一次打usaco，有点紧张。。。<img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180405111329866"></p>
<p>同组第一题的传送牛粪，虽不知道何必如此大费周章，但也是一代水题</p>
<p>题面是这样的：</p>
<p><span style="color:#000000;">Farmer John最讨厌的农活是运输牛粪。为了精简这个过程，他制造了一个伟大的发明：便便传送门！与使用拖拉机拖着装满牛粪的大车从一个地点到另一个地点相比，他可以使用便便传送门将牛粪从一个地点瞬间传送到另一个地点。</span></p>
<p>Farmer John的农场沿着一条长直道路而建，所以他农场上的每个地点都可以简单地用该地点在道路上的位置来表示（相当于数轴上的一个点）。一个传送门可以用两个数xx和yy表示，被拖到地点xx的牛粪可以瞬间传送到地点yy，反之亦然。</p>
<p>Farmer John想要将牛粪从地点aa运输到地点bb，他建造了一个可能对这一过程有所帮助的传送门（当然，如果没有帮助，他也可以不用）。请帮助他求出他需要使用拖拉机运输牛粪的总距离的最小值。</p>
<p>&nbsp;</p>
<p>输入格式（文件名：teleport.in）：</p>
<p>输入仅包含一行，为四个用空格分隔的整数：aa和bb，表示起始地点和结束地点，后面是xx和yy，表示传送门。所有的位置都是范围为0…1000…100的整数，不一定各不相同。</p>
<p>&nbsp;</p>
<p>输出格式（文件名：teleport.out）：</p>
<p>输出一个整数，为Farmer John需要用拖拉机运输牛粪的最小距离。</p>
<p>&nbsp;</p>
<p>输入样例：</p>
<pre class="has">
<code class="language-in">3 10 8 2
</code></pre>
<p>输出样例：</p>
<pre class="has">
<code class="language-out">3
</code></pre>
<p>在这个样例中，最佳策略是将牛粪从位置3运到位置2，传送到位置8，再运到位置10。 所以需要用拖拉机的总距离为1 + 2 = 3。</p>
<p>这题我采用了模拟法，一遍过，代码如下</p>
<pre class="has">
<code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a,b,x,y,i,j;
long long n=0,m=0;
int main()
{
freopen("teleport.in","r",stdin);
freopen("teleport.out","w",stdout);

cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;
if(b&gt;a)
{
n=b-a;
if(x&gt;y)
&nbsp;{
&nbsp; &nbsp;if(a&gt;y)
&nbsp; &nbsp; &nbsp;m+=a-y;
&nbsp; &nbsp;else
&nbsp; &nbsp; &nbsp;m+=y-a;
&nbsp; &nbsp;if(b&gt;x)
&nbsp; &nbsp; &nbsp;m+=b-x;
&nbsp; &nbsp;else
&nbsp;m+=x-b; &nbsp;
&nbsp; &nbsp; &nbsp;}
else
&nbsp;{
&nbsp; if(a&gt;x)
&nbsp; &nbsp; m+=a-x;
&nbsp; else
&nbsp; &nbsp; m+=x-a;
&nbsp; if(b&gt;y)
&nbsp; &nbsp;m+=b-y;
&nbsp; else
&nbsp; &nbsp;m+=y-b;
&nbsp;}
}
else
{ &nbsp;&nbsp;
&nbsp; n=a-b;
if(x&gt;y)
&nbsp;{
&nbsp; if(a&gt;x)
&nbsp; &nbsp; m+=a-x;
&nbsp; else
&nbsp; &nbsp; m+=x-a;
&nbsp; if(b&gt;y)
&nbsp; &nbsp;m+=b-y;
&nbsp; else
&nbsp; &nbsp;m+=y-b;
}
else
&nbsp;{
&nbsp;
&nbsp; &nbsp;if(a&gt;y)
&nbsp; &nbsp; &nbsp;m+=a-y;
&nbsp; &nbsp;else
&nbsp; &nbsp; &nbsp;m+=y-a;
&nbsp; &nbsp;if(b&gt;x)
&nbsp; &nbsp; &nbsp;m+=b-x;

&nbsp; &nbsp;else
&nbsp;m+=x-b; &nbsp;
&nbsp; &nbsp; &nbsp;} &nbsp;
}
if(n&gt;m)
&nbsp;cout&lt;&lt;m;
else
&nbsp;cout&lt;&lt;n;
fclose(stdin);
fclose(stdout);
return 0;

}</code></pre>
<p>很长，可以简洁很多，但这样写思路会更清晰，AC后也就没想过化简。</p>
<p>第二题，让我崩溃了两次，死循环了3次，wa了8个点，最终终于还是AC了；</p>
<p><span style="color:#000000;">为了准备即将到来的蹄球锦标赛，Farmer John正在训练他的</span><span style="color:#000000;">NN</span><span style="color:#000000;">头奶牛（方便起见，编号为</span><span style="color:#000000;">1…N1…N</span><span style="color:#000000;">，其中</span><span style="color:#000000;">1≤N≤1001≤N≤100</span><span style="color:#000000;">）进行传球。这些奶牛在牛棚一侧沿直线排列，第</span><span style="color:#000000;">ii</span><span style="color:#000000;">号奶牛位于距离牛棚</span><span style="color:#000000;">xixi</span><span style="color:#000000;">的地方(</span><span style="color:#000000;">1≤xi≤10001≤xi≤1000</span><span style="color:#000000;">)。每头奶牛都在不同的位置上。</span></p>
<p>在训练开始的时候，Farmer John会将若干个球传给不同的奶牛。当第ii号奶牛接到球时，无论是从Farmer John或是从另一头奶牛传来的，她会将球传给最近的奶牛（如果有多头奶牛与她距离相同，她会传给其中距左边最远的那头奶牛）。为了使所有奶牛都有机会练习到传球，Farmer John想要确保每头奶牛都持球至少一次。帮助他求出为了达到这一目的他开始时至少要传出的球的数量。假设他在开始的时候能将球传给最适当的一组奶牛。</p>
<p>&nbsp;</p>
<p>输入格式（文件名：hoofball.in）：</p>
<p>输入的第一行包含NN。第二行包含NN个用空格分隔的整数，其中第ii个整数为xixi。</p>
<p>&nbsp;</p>
<p>输出格式（文件名：hoofball.out）：</p>
<p>输出Farmer John开始的时候最少需要传出的球的数量，使得所有奶牛至少持球一次。</p>
<p>&nbsp;</p>
<p>输入样例：</p>
<pre class="has">
<code class="language-in">5
7 1 3 11 4
</code></pre>
<p>输出样例：</p>
<pre class="has">
<code class="language-out">2
</code></pre>
<p>在上面的样例中，Farmer John应该将球传给位于x=1x=1的奶牛和位于x=11x=11的奶牛。位于x=1x=1的奶牛会将她的球传给位于x=3x=3的奶牛，在此之后这个球会在位于x=3x=3的奶牛和位于x=4x=4的奶牛之间来回传递。位于x=11x=11的奶牛会将她的球传给位于x=7x=7的奶牛，然后球会被传给位于x=4x=4的奶牛，在此之后这个球也会在位于x=3x=3的奶牛和位于x=4x=4的奶牛之间来回传递。这样的话，所有的奶牛都会至少一次接到球（可能从Farmer John，也可能从另一头奶牛）。</p>
<p>可以看出，不存在这样一头奶牛，Farmer John可以将球传给她之后所有奶牛最终都能被传到球。</p>
<p>&nbsp;</p>
<p>供题：Dhruv Rohatgi</p>
<p>&nbsp;</p>
<p>主要代码如下</p>
<pre class="has">
<code class="language-cpp">sort(c+1,c+n+1,mycmp)//从大到小

n=c[1].r;

k=1;

x=2;

while(n&lt;a)



{

k++;

m=n;

for(i=x;i&lt;=a;i++)

{

if(c[i].l&gt;m+1)



{

x=i;

break;

}

else

if(c[i].r&gt;now) now=c[i].r;

}

}</code></pre>
<p>第三题，我就有点蒙了；</p>
<p>有时只A了两个点，有时只A了一个点。</p>
<p><span style="color:#000000;">一大清早，Farmer John就被木材破裂的声音吵醒了。是这些奶牛们干的，她们又逃出牛棚了！</span></p>
<p>Farmer John已经厌烦了奶牛在清晨出逃，他觉得受够了：是时候采取强硬措施了。他在牛棚的墙上钉了一个计数器，追踪从上次出逃开始经过的天数。所以如果某一天早上发生了出逃事件，这一天的计数器就为00；如果最近的出逃是33天前，计数器读数就为33。Farmer John一丝不苟地记录了每一天计数器的读数。</p>
<p>年末到了，Farmer John准备做一些统计。他说，你们这些奶牛会付出代价的！然而意想不到的是，他的记录的一些条目竟然丢失了！</p>
<p>Farmer John确信他是在发生出逃的某一天开始记录的。请帮助他确定，在所有与残留记录条目一致的事件序列中，基于记录的时间，最少和最多可能发生的出逃次数。</p>
<p>&nbsp;</p>
<p>输入格式（文件名：taming.in）：</p>
<p>输入的第一行包含一个整数NN（1≤N≤1001≤N≤100），表示从Farmer John开始对奶牛出逃计数器进行计数以来已经经过的天数。</p>
<p>第二行包含NN个空格分隔的整数。第ii个整数是−1−1，表示第ii天的记录丢失了，或者是一个非负整数aiai（不超过100100），表示在第ii天计数器的数字是aiai。</p>
<p>&nbsp;</p>
<p>输出格式（文件名：taming.out）：</p>
<p>如果没有事件序列与Farmer John的残留记录以及他所确定的奶牛在第11天清晨出逃这一事实相一致，输出一个整数−1−1。否则，输出两个空格分隔的整数mm和MM，其中mm为所有事件序列中出逃的最少次数，MM为最多次数。</p>
<p>&nbsp;</p>
<p>输入样例：</p>
<pre class="has">
<code class="language-in">4
-1 -1 -1 1
</code></pre>
<p>输出样例：</p>
<pre class="has">
<code class="language-out">2 3
</code></pre>
<p>在这个样例中，我们可以推断第3天必然有出逃发生。我们已经知道在第1天也发生了出逃，所以最后不确定的只有第2天是否发生了出逃。因此，总共发生了2至3次出逃。</p>
<p>&nbsp;</p>
<p>不知道思维的差错，听了高中大佬的解说我才有点理解，自己的垃圾代码我亮出来也只是个笑话，不如给你们看看大佬的解法吧</p>
<pre class="has">
<code class="language-cpp">a[1]=0;

b[1]=1;

for(i=1;i&lt;=n;++i)



{

&nbsp; if(a[i]&gt;=0)



{

&nbsp; b[i-a[i]]=1；

&nbsp; if(a[i]!=0)



{

&nbsp; for(j=i-a[i]+1;j&lt;=i;++j)



{

if(b[j]==1)



{

cout&lt;&lt;"-1";exit(0);)

b[j]=-1;

}}}}

}

if(b[1]==-2)



{

cout&lt;&lt;"-1";exit(0);

}

for(i=1;i&lt;=n;++i)



{

if(b[i]==1)

&nbsp; ans1++,ans2++;

if(b[i]==0)

&nbsp;ans2++;

}

cout&lt;&lt;ans1&lt;&lt;' '&lt;&lt;ans2;</code></pre>
<p>可能我错就错在-1没有判断好，才导致这样的差错吧</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>牛客华为机试题刷题笔记（一）</title>
		<link>https://uzzz.org/article/2978.html</link>
				<pubDate>Mon, 26 Jun 2017 13:03:29 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[程序员]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2978.html</guid>
				<description><![CDATA[马上华为提前批开始了，吓得我赶紧上牛客网刷题，记录如下： 所有代码都在github 1.字符串最后一个单词的长度 一段英文字符串中最后一个单词的长度。 题目比较简单，做法有很多： 比如， 可以放到stringstream里面split，拿到最后一个单词 也可以从后往前数到第一个空格为止。 让我觉得麻烦是第一次做这种要自己写输入的题， C++用cin是遇到空格停止的，因此要用getline读入一行 #include &#60;iostream&#62; #include &#60;string&#62; using namespace std; int main() { string str; getline(cin,str); int i=str.size()-1; int count=0; while(str[i]!=' '&#38;&#38;i&#62;=0) { ++count; --i; } cout&#60;&#60;count&#60;&#60;endl; return 0; } 2.计算字符个数 输入一个字符串和一个字符，统计该字符在该字符串中出现的次数。 for循环比较即可，没什么好说的 #include &#60;iostream&#62; #include &#60;string&#62; using namespace std; int main(int argc,char **argv) { string str; char c; getline(cin,str); cin&#62;&#62;c; int count=0; for(int i=0;i&#60;str.size();++i) { if(tolower(str[i])==tolower(c)) ++count; } cout &#60;&#60; count&#60;&#60;endl; return 0; } 3.明明的随机数 说是随机数，其实跟随机数没有半毛钱关系， 就是输入一串整数，整数去重，输出排好序的结果， C++使用std::sort、std::unique、vector::erase可以轻易做到 #include &#60;iostream&#62; #include &#60;vector&#62; #include &#60;iterator&#62; #include &#60;algorithm&#62; using namespace std; int main() { // input int n; while(cin&#62;&#62;n) { vector&#60;int&#62;v; v.reserve(1024); int j; for(int i=0;i&#60;n;++i) { cin &#62;&#62; j; v.push_back(j); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); if(v.capacity()&#60;1024) vector&#60;int&#62;(v).swap(v); //copy(v.begin(),v.end(),ostream_iterator&#60;int&#62;(cout,"\n")); for(int i=0;i&#60;v.size();++i) cout&#60;&#60;v[i]&#60;&#60;endl; } return 0; } 4.字符串分隔 给定一个字符串，对其等距（长度8）分隔，最后不足的补0 例如，123456789将分割成:12345678和90000000 方法也很多，比如可以用string::substr，考虑到最后如果不足8个字符，需要补0， 这里我先创建一个00000000然后用std::copy来做 #include &#60;iostream&#62; #include &#60;string&#62; using namespace std; int main(int argc, char ** argv) { string str1; string str2; cin&#62;&#62;str1&#62;&#62;str2; for(int i=0;i&#60;str1.size();i+=8) { string output("00000000"); int l=(i+8)&#60;str1.size()?8:(str1.size()-i); std::copy(str1.begin()+i,str1.begin()+i+l,output.begin()); cout&#60;&#60;output&#60;&#60;endl; } for(int i=0;i&#60;str2.size();i+=8) { string output("00000000"); int l=(i+8)&#60;str2.size()?8:(str2.size()-i); std::copy(str2.begin()+i,str2.begin()+i+l,output.begin()); cout&#60;&#60;output&#60;&#60;endl; } return 0; } 5.进制转换 16进制转成10进制，基础题没啥好说的， 做一个map把0~F映射进去，比较方便，或者写个if-else判断当前字符是数字还是字母 #include &#60;iostream&#62; #include &#60;string&#62; #include &#60;unordered_map&#62; #include &#60;cmath&#62; using namespace]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>马上华为提前批开始了，吓得我赶紧上牛客网刷题，记录如下： <br /> 所有代码都在<a href="https://github.com/NearXdu/huawei" rel="nofollow" data-token="0b6d7d5bd1920c2c37c80a4a22f5b581">github</a></p>
<h2 id="1字符串最后一个单词的长度"><strong>1.字符串最后一个单词的长度</strong></h2>
<p>一段英文字符串中最后一个单词的长度。 <br /> 题目比较简单，做法有很多： <br /> 比如， <br /> 可以放到stringstream里面split，拿到最后一个单词 <br /> 也可以从后往前数到第一个空格为止。</p>
<p>让我觉得麻烦是第一次做这种要自己写输入的题， <br /> C++用cin是遇到空格停止的，因此要用<code>getline</code>读入一行</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-built_in">string</span> str;
    getline(<span class="hljs-built_in">cin</span>,str);
    <span class="hljs-keyword">int</span> i=str.size()-<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(str[i]!=<span class="hljs-string">' '</span>&amp;&amp;i&gt;=<span class="hljs-number">0</span>)
    {
    ++count;
    --i;
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;count&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="2计算字符个数"><strong>2.计算字符个数</strong></h2>
<p>输入一个字符串和一个字符，统计该字符在该字符串中出现的次数。 <br /> for循环比较即可，没什么好说的</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">char</span> c;

    getline(<span class="hljs-built_in">cin</span>,str);
    <span class="hljs-built_in">cin</span>&gt;&gt;c;

    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();++i)
    {
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tolower</span>(str[i])==<span class="hljs-built_in">tolower</span>(c))
        ++count;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; count&lt;&lt;endl;


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="3明明的随机数"><strong>3.明明的随机数</strong></h2>
<p>说是随机数，其实跟随机数没有半毛钱关系， <br /> 就是输入一串整数，整数去重，输出排好序的结果， <br /> C++使用<code>std::sort</code>、<code>std::unique</code>、<code>vector::erase</code>可以轻易做到</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;iterator&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;


<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">// input </span>
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)
    {
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>v;
    v.reserve(<span class="hljs-number">1024</span>);
    <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)
    {
        <span class="hljs-built_in">cin</span> &gt;&gt; j;
        v.push_back(j);
    }
    sort(v.begin(),v.end());
    v.erase(unique(v.begin(),v.end()),v.end());
    <span class="hljs-keyword">if</span>(v.capacity()&lt;<span class="hljs-number">1024</span>)
        <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>(v).swap(v);

    <span class="hljs-comment">//copy(v.begin(),v.end(),ostream_iterator&lt;int&gt;(cout,"\n"));</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v.size();++i)
        <span class="hljs-built_in">cout</span>&lt;&lt;v[i]&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="4字符串分隔"><strong>4.字符串分隔</strong></h2>
<p>给定一个字符串，对其等距（长度8）分隔，最后不足的补0 <br /> 例如，<code>123456789</code>将分割成:<code>12345678</code>和<code>90000000</code></p>
<p>方法也很多，比如可以用<code>string::substr</code>，考虑到最后如果不足8个字符，需要补0， <br /> 这里我先创建一个<code>00000000</code>然后用<code>std::copy</code>来做</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)
{
    <span class="hljs-built_in">string</span> str1;
    <span class="hljs-built_in">string</span> str2;
    <span class="hljs-built_in">cin</span>&gt;&gt;str1&gt;&gt;str2;


    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str1.size();i+=<span class="hljs-number">8</span>)
    {
    <span class="hljs-built_in">string</span> output(<span class="hljs-string">"00000000"</span>);
    <span class="hljs-keyword">int</span> l=(i+<span class="hljs-number">8</span>)&lt;str1.size()?<span class="hljs-number">8</span>:(str1.size()-i);
    <span class="hljs-built_in">std</span>::copy(str1.begin()+i,str1.begin()+i+l,output.begin());
    <span class="hljs-built_in">cout</span>&lt;&lt;output&lt;&lt;endl;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str2.size();i+=<span class="hljs-number">8</span>)
    {
    <span class="hljs-built_in">string</span> output(<span class="hljs-string">"00000000"</span>);
    <span class="hljs-keyword">int</span> l=(i+<span class="hljs-number">8</span>)&lt;str2.size()?<span class="hljs-number">8</span>:(str2.size()-i);
    <span class="hljs-built_in">std</span>::copy(str2.begin()+i,str2.begin()+i+l,output.begin());
    <span class="hljs-built_in">cout</span>&lt;&lt;output&lt;&lt;endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<hr>
<h2 id="5进制转换"><strong>5.进制转换</strong></h2>
<p>16进制转成10进制，基础题没啥好说的， <br /> 做一个map把0~F映射进去，比较方便，或者写个if-else判断当前字符是数字还是字母</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;unordered_map&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-stl_container"><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt;</span>mmap;
    mmap[<span class="hljs-string">'0'</span>]=<span class="hljs-number">0</span>;
    mmap[<span class="hljs-string">'1'</span>]=<span class="hljs-number">1</span>;
    mmap[<span class="hljs-string">'2'</span>]=<span class="hljs-number">2</span>;
    mmap[<span class="hljs-string">'3'</span>]=<span class="hljs-number">3</span>;
    mmap[<span class="hljs-string">'4'</span>]=<span class="hljs-number">4</span>;
    mmap[<span class="hljs-string">'5'</span>]=<span class="hljs-number">5</span>;
    mmap[<span class="hljs-string">'6'</span>]=<span class="hljs-number">6</span>;
    mmap[<span class="hljs-string">'7'</span>]=<span class="hljs-number">7</span>;
    mmap[<span class="hljs-string">'8'</span>]=<span class="hljs-number">8</span>;
    mmap[<span class="hljs-string">'9'</span>]=<span class="hljs-number">9</span>;
    mmap[<span class="hljs-string">'a'</span>]=<span class="hljs-number">10</span>;
    mmap[<span class="hljs-string">'A'</span>]=<span class="hljs-number">10</span>;
    mmap[<span class="hljs-string">'b'</span>]=<span class="hljs-number">11</span>;
    mmap[<span class="hljs-string">'B'</span>]=<span class="hljs-number">11</span>;
    mmap[<span class="hljs-string">'c'</span>]=<span class="hljs-number">12</span>;
    mmap[<span class="hljs-string">'C'</span>]=<span class="hljs-number">12</span>;
    mmap[<span class="hljs-string">'d'</span>]=<span class="hljs-number">13</span>;
    mmap[<span class="hljs-string">'D'</span>]=<span class="hljs-number">13</span>;
    mmap[<span class="hljs-string">'e'</span>]=<span class="hljs-number">14</span>;
    mmap[<span class="hljs-string">'E'</span>]=<span class="hljs-number">14</span>;
    mmap[<span class="hljs-string">'F'</span>]=<span class="hljs-number">15</span>;
    mmap[<span class="hljs-string">'f'</span>]=<span class="hljs-number">15</span>;
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; str)
    {
    str=str.substr(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();++i)
    {
        sum*=<span class="hljs-number">16</span>;
        sum+=mmap[str[i]];
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;endl;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="6质数因子"><strong>6.质数因子</strong></h2>
<p>不知道有没有更高端的方法，我的理解就是，对于一个数来说，比如180 <br /> 从2开始遍历，如果能被2整除，那么180/=2，并且输出2，之后再拿90重复上述操作 <br /> 直到变成1为止</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">long</span> input;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;input)
    {
    <span class="hljs-keyword">while</span>(input&gt;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>))
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=input;++i)
        {
        <span class="hljs-keyword">if</span>(input%i==<span class="hljs-number">0</span>)
        {
            input/=i;
            <span class="hljs-built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">" "</span>;
            <span class="hljs-keyword">break</span>;
        }

        }
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="7取近似值"><strong>7.取近似值</strong></h2>
<p>输出一个浮点数四舍五入的值，C++标准库也有<code>round``floor``ceil</code>这样的函数， <br /> 我的办法比较土，转成string以后提出小数点第一位然后再判断：</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">double</span> f;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;f)
    {
    <span class="hljs-built_in">string</span> str(<span class="hljs-built_in">std</span>::to_string(f));
    <span class="hljs-keyword">int</span> pos=str.find(<span class="hljs-string">'.'</span>);
    <span class="hljs-keyword">int</span> v1=<span class="hljs-built_in">std</span>::stoi(str.substr(<span class="hljs-number">0</span>,pos));
    <span class="hljs-keyword">int</span> v2=str[pos+<span class="hljs-number">1</span>]-<span class="hljs-string">'0'</span>;
    <span class="hljs-built_in">cout</span>&lt;&lt; (v2&gt;<span class="hljs-number">4</span>?(v1+<span class="hljs-number">1</span>):v1)&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="8合并表记录"><strong>8.合并表记录</strong></h2>
<p>这题不复杂，就是麻烦，大概意思就是输入(key-value)对， <br /> key相同的要合并，合并就是将value加起来，最后将这些(key-value)对升序排行 <br /> 我的做法定义一个结构体，然后重写<code>operator==</code>和<code>std::sort</code>的比较函数，实际上定义一个<code>unordered_map&lt;int,int&gt;</code>会更简单吧。</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">struct</span> pair_
{
    <span class="hljs-keyword">int</span> key;
    <span class="hljs-keyword">int</span> value;

    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> pair_ &amp;x)
    {
    <span class="hljs-keyword">return</span> x.key==<span class="hljs-keyword">this</span>-&gt;key;
    }
};
<span class="hljs-keyword">typedef</span> <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;pair_&gt;</span> Pairs;
<span class="hljs-keyword">class</span> comp{
    <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> pair_&amp;a,<span class="hljs-keyword">const</span> pair_&amp;b)
    {
        <span class="hljs-keyword">return</span> a.key&lt;b.key;
    }
};
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)
{
    <span class="hljs-keyword">int</span> N;
    Pairs pairs;
    pairs.reserve(<span class="hljs-number">1024</span>);
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;N)
    {
    Pairs::iterator it;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;N;++i)
    {
        pair_ tmp;
        <span class="hljs-built_in">cin</span>&gt;&gt;tmp.key&gt;&gt;tmp.value;
<span class="hljs-preprocessor">#if 1</span>
        <span class="hljs-keyword">if</span>((it =find(pairs.begin(),pairs.end(),tmp))!=pairs.end())
        it-&gt;value+=tmp.value;
        <span class="hljs-keyword">else</span>
        pairs.push_back(tmp);
<span class="hljs-preprocessor">#endif</span>
    }
    sort(pairs.begin(),pairs.end(),comp());
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;pairs.size();++i)
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;pairs[i].key&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;pairs[i].value&lt;&lt;endl;

    }


    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<hr>
<h2 id="9提取不重复整数"><strong>9.提取不重复整数</strong></h2>
<p>简单粗暴的做法，定义一个<code>unordered_set</code>把出现过的放进去 <br /> 从后往前迭代一次就可以了。</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;unordered_set&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;n)
    {
    <span class="hljs-built_in">string</span> str=to_string(n);
    <span class="hljs-stl_container"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;</span>s;
    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=str.size()-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;--i)
    {
        <span class="hljs-keyword">if</span>(s.find(str[i])==s.end())
        {
        sum*=<span class="hljs-number">10</span>;
        sum+=(str[i]-<span class="hljs-string">'0'</span>);
        s.insert(str[i]);
        }
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;endl;;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
<h2 id="10字符个数统计"><strong>10.字符个数统计</strong></h2>
<p>统计ACSII码范围（0-127）的字符，重复的字符只统计一次 <br /> 比如<code>aaa</code>只统计为1</p>
<p>我的做法依然简单粗暴，用一个<code>unordered_set</code></p>
<p>其实只需要一个127大小的char数组，出现就赋值1，最后统计即可</p>
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;unordered_set&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-stl_container"><span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt;</span>s;
    <span class="hljs-built_in">std</span>::getline(<span class="hljs-built_in">cin</span>,str);

    <span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.size();++i)
    {
    <span class="hljs-keyword">if</span>(str[i]&lt;<span class="hljs-number">128</span>&amp;&amp;str[i]&gt;=<span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span>(s.find(str[i])==s.end())
        {
        ++count;
        s.insert(str[i]);
        }
    }
    }
    <span class="hljs-built_in">cout</span>&lt;&lt;count&lt;&lt;endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>网易互娱2017实习生招聘在线笔试(一)</title>
		<link>https://uzzz.org/article/2817.html</link>
				<pubDate>Fri, 18 Mar 2016 15:45:53 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[程序员]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2817.html</guid>
				<description><![CDATA[题目1 : 电子数字 时间限制: 10000ms 单点时限: 1000ms 内存限制: 256MB 描述 电子数字在生活中很常见，而许多的电子数字是由LED数码管制作而成。数字LED数码管一般由7个发光二极管封装在一起，组成&#8217;8&#8217;字型，引线在内部连接完成。如下图所示，我们可以对每个发光管进行编码从1到7。而数字0到数字9可以由这七根发光管的亮暗来表示。 对LED数码管的二极管进行编码 用LED数码管表示数字0-9 假设我们现在有从左到右排列好的K个LED数码管，并且我们已知每个数码管当前有哪些编号的二极管是亮着的，另外剩余的二极管由于某些原因，我们并不清楚它们的亮暗情况。由于已经有部分二极管是确定亮着的，所以每个LED数码管能表示的数字范围会有所缩小，譬如假设1号二极管已经确定是亮着的状态，那么这个LED数码管就不能表示数字1和4。 我们想知道的是，给定一个数N，在这K个LED数码管的当前亮暗的状态下，所有可能表示的数中，比N小的数有多少个。 注意，前导0是必须的，假设有4个数码管的话，&#8217;0000&#8217;表示0，&#8217;0123&#8217;表示123，即每个数的表示方法唯一。 输入 每个输入数据包含多个测试点。 第一行为测试点的个数 S ≤ 100。之后是 S 个测试点的数据。测试点之间无空行。 每个测试点的第一行为 K(1 ≤ K ≤ 5)和N(0 ≤ N ≤ 109)。之后是K行，每行表示对应数码管已点亮的二极管的情况。每行至少包含一个数字，表示对应点亮的二极管的编号，即每个数码管至少有一根二极管是点亮的。二极管编号的范围保证在1到7之间，且每行无重复编号。 注意表示数码管点亮情况的每行数字之间以及行首行末之间可能存在冗余空格，每行的字符总长度不超过100。 输出 对于每个测试点，对应的结果输出一行，表示这K个数码管在当前状态下，所有可能表示的数中，比N小的数有多少个。 样例解释 第一个样例中，只有&#8217;020&#8242;, &#8216;026&#8217;, &#8216;028&#8217;符合要求。 第三个样例中，只有&#8217;000&#8217;符合要求。 样例输入 3 3 50 3 1 1 4 5 1 5 6 7 4 100 1 2 3 4 5 6 7 1 1 7 样例输出 3 0 1 &#60;pre name="code" class="cpp"&#62;// wangyi.cpp : Defines the entry point for the console application. // #include &#60;iostream&#62; #include &#60;vector&#62; #include &#60;sstream&#62; using namespace std; void getNum(vector&#60;vector&#60;int&#62;&#62; numList, int deep, int temp, vector&#60;int&#62; &#38;totalNums); int main(void) { int deng[10][7] = { {1,1,1,0,1,1,1},//0 {0,0,1,0,0,1,0}, {1,0,1,1,1,0,1}, {1,0,1,1,0,1,1}, {0,1,1,1,0,1,0}, {1,1,0,1,0,1,1}, {1,1,0,1,1,1,1}, {1,0,1,0,0,1,0},//7 {1,1,1,1,1,1,1}, {1,1,1,1,0,1,1}//9 }; int S_test; //测试点的个数 int K_LED; //K个LED数码管 int compareNum; //给定每个测试点比较的数 cin&#62;&#62;S_test; int *endAnswer = new int[S_test]; //输出结果 for(int i=0;i&#60;S_test;i++) //测试用例 { cin&#62;&#62;K_LED&#62;&#62;compareNum; //K个LED数码管， 测试的数字 cin.ignore(); //忽略上一行的换行符！！！ vector&#60;vector&#60;int&#62;&#62;num_K_LED; //存储每个LED可能的数字 for (int j=0;j&#60;K_LED;j++) //多少LED数码管 就多少行 { char eachLine[100]; //每行表示对应数码管已点亮的二极管的情况 cin.getline(eachLine,100);//cin&#62;&#62;eachLine; //每行 int servenLight[7] = {0}; //单个LED的7个指示灯哪个亮 int idx = 0; //数组下标 for(int k=0;k&#60;strlen(eachLine);k++) //每行转为数字 { if(eachLine[k]!=' ') { servenLight[idx] = int(eachLine[k] -]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h3 class="panel-title">题目1 : 电子数字</h3>
</p>
<div id="tl-problem-content">
<div class="limit">
<div>
     时间限制:<br />
     <span style="margin-left:10px;">10000ms</span>
    </div>
<div>
     单点时限:<br />
     <span style="margin-left:10px;">1000ms</span>
    </div>
<div>
     内存限制:<br />
     <span style="margin-left:10px;">256MB</span>
    </div>
</p></div>
<div>
<h3>描述</h3>
<p>电子数字在生活中很常见，而许多的电子数字是由LED数码管制作而成。数字LED数码管一般由7个发光二极管封装在一起，组成&#8217;8&#8217;字型，引线在内部连接完成。如下图所示，我们可以对每个发光管进行编码从1到7。而数字0到数字9可以由这七根发光管的亮暗来表示。</p>
<p style="text-align:center;"><img src="http://media.hihocoder.com//problem_images/20160314/14579394929229.jpg" title="digit8.jpg" alt=""></p>
<p style="text-align:center;"><em>对LED数码管的二极管进行编码</em></p>
<p style="text-align:center;"><img src="http://media.hihocoder.com//problem_images/20160315/14580249187878.jpg" title="digit.jpg" alt=""></p>
<p style="text-align:center;"><em>用LED数码管表示数字0-9</em></p>
<p>假设我们现在有从左到右排列好的K个LED数码管，并且我们已知每个数码管当前有哪些编号的二极管是亮着的，另外剩余的二极管由于某些原因，我们并不清楚它们的亮暗情况。由于已经有部分二极管是确定亮着的，所以每个LED数码管能表示的数字范围会有所缩小，譬如假设1号二极管已经确定是亮着的状态，那么这个LED数码管就不能表示数字1和4。</p>
<p>我们想知道的是，给定一个数N，在这K个LED数码管的当前亮暗的状态下，所有可能表示的数中，比N小的数有多少个。</p>
<p>注意，前导0是必须的，假设有4个数码管的话，&#8217;0000&#8217;表示0，&#8217;0123&#8217;表示123，即每个数的表示方法唯一。</p>
<h3>输入</h3>
<p>每个输入数据包含多个测试点。</p>
<p>第一行为测试点的个数 <var>S</var> ≤ 100。之后是 <var>S</var> 个测试点的数据。测试点之间无空行。</p>
<p>每个测试点的第一行为 <var>K</var>(1 ≤ <var>K</var> ≤ 5)和<var>N</var>(0 ≤ <var>N </var>≤ 10<sup>9</sup>)。之后是K行，每行表示对应数码管已点亮的二极管的情况。每行至少包含一个数字，表示对应点亮的二极管的编号，即每个数码管至少有一根二极管是点亮的。二极管编号的范围保证在1到7之间，且每行无重复编号。</p>
<p>注意表示数码管点亮情况的每行数字之间以及行首行末之间可能存在冗余空格，每行的字符总长度不超过100。</p>
<h3>输出</h3>
<p>对于每个测试点，对应的结果输出一行，表示这K个数码管在当前状态下，所有可能表示的数中，比N小的数有多少个。</p>
<h3>样例解释</h3>
<p>第一个样例中，只有&#8217;020&#8242;, &#8216;026&#8217;, &#8216;028&#8217;符合要求。</p>
<p>第三个样例中，只有&#8217;000&#8217;符合要求。</p>
</p></div>
<p> 样例输入 </p>
<pre>3
3 50
3  1
  1  4  5  
1   5  6 7
4 100
1 2 3
   4   5
6
  7  
1 1
  7</pre>
<p> 样例输出 </p>
<pre>3
0
1</pre>
</p></div>
<p></p>
<pre><code class="language-cpp">&lt;pre name="code" class="cpp"&gt;// wangyi.cpp : Defines the entry point for the console application.
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
using namespace std;

void getNum(vector&lt;vector&lt;int&gt;&gt; numList, int deep, int temp, vector&lt;int&gt; &amp;totalNums);

int main(void)
{
	int deng[10][7] = { {1,1,1,0,1,1,1},//0
	{0,0,1,0,0,1,0},
	{1,0,1,1,1,0,1},
	{1,0,1,1,0,1,1},
	{0,1,1,1,0,1,0},
	{1,1,0,1,0,1,1},
	{1,1,0,1,1,1,1},
	{1,0,1,0,0,1,0},//7
	{1,1,1,1,1,1,1},
	{1,1,1,1,0,1,1}//9
	};

	int S_test; //测试点的个数
	int K_LED;    //K个LED数码管
	int compareNum; //给定每个测试点比较的数

	cin&gt;&gt;S_test;

	int *endAnswer = new int[S_test]; //输出结果

	for(int i=0;i&lt;S_test;i++) //测试用例
	{
		cin&gt;&gt;K_LED&gt;&gt;compareNum; //K个LED数码管， 测试的数字
		cin.ignore(); //忽略上一行的换行符！！！

		vector&lt;vector&lt;int&gt;&gt;num_K_LED; //存储每个LED可能的数字

		for (int j=0;j&lt;K_LED;j++) //多少LED数码管 就多少行
		{
			char eachLine[100]; //每行表示对应数码管已点亮的二极管的情况

			cin.getline(eachLine,100);//cin&gt;&gt;eachLine;      //每行

			int servenLight[7] = {0};   //单个LED的7个指示灯哪个亮
			int idx = 0; //数组下标
			for(int k=0;k&lt;strlen(eachLine);k++) //每行转为数字
			{				
				if(eachLine[k]!=' ')
				{
					servenLight[idx] = int(eachLine[k] - '0'); //取数字
					idx++;
					if(idx == 7)
					{
						break;
					}
				}
			}

			vector&lt;int &gt; num_eachLED; //记录单个LED中servenLight[7]中亮的可能是哪些数字？
			for (int deng_i = 0; deng_i &lt;10;deng_i ++) //循环0-9,符合的加入num_eachLED
			{
				bool rs = true;
				int idx = 0;

				while (servenLight[idx] !=0)  //所有亮的指示灯都在 这个数字中
				{
					if(deng[deng_i][ servenLight[idx] -1] != 1)
					{
						rs = false;						
						break;
					}
					idx++;
				}
				if(rs)
				{
					num_eachLED.push_back(deng_i);
				}								
			}

			num_K_LED.push_back(num_eachLED);
		}


		vector&lt;int&gt; totalNums; //记录所有组合出来的数字
		int deep =0; 
		int temp =0;
		getNum(num_K_LED, deep, temp, totalNums);
		
		stringstream ss;
		ss&lt;&lt;compareNum; 
		string N_string = ss.str();     //位数
		if(N_string.length() &gt; K_LED)  //位数大于K的话不用再一一比较，所有组合出来的都小于N
		{
			endAnswer[i] = totalNums.size();
		}
		else
		{
			int count = 0;
			for (int totalNums_i = 0; totalNums_i &lt; totalNums.size();totalNums_i++)
			{
				if(compareNum &gt;= totalNums[totalNums_i])
				{
					count++;
				}
			}
			endAnswer[i] = count;
		}		
	}

	for(int i = 0; i&lt;S_test; i++)
	{
		cout&lt;&lt;endAnswer[i]&lt;&lt;endl;
	}

	//system("pause");
	return 0;
}

void getNum(vector&lt;vector&lt;int&gt;&gt; numList, int deep, int temp, vector&lt;int&gt; &amp;totalNums)
{
	if(deep &lt; numList.size()-1)
	{
		for(int i=0; i &lt; numList[deep].size(); i++)
		{
			int newInt = temp + numList[deep][i] * pow(10,numList.size()- deep -1);
			getNum(numList, deep+1, newInt,totalNums);
		}
	}
	else if(deep == numList.size()-1)
	{
		for(int i=0; i &lt; numList[deep].size(); i++)
		{
			int newInt = temp + numList[deep][i] * pow(10,numList.size()- deep -1);
			totalNums.push_back(newInt);
		}
	}
}</code></pre>
<pre></pre>
<p></p>
<p>测试样例通过，但是不知道时间和内存是否超过。过了时间没法提交</p>
<p></p>
<p> 太水了，完全被碾压<br />
  <img alt="哭" src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/cry.gif"></p>
<p></p>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
