<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>数据结构 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/shujujiegou/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Sat, 18 Aug 2018 01:59:29 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>数据结构 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>今日头条试题：小明在抖音关注了n个主播，每个主播每天的开播时间是固定的，分别在时刻开始，ti时刻结束</title>
		<link>https://uzzz.org/article/3205.html</link>
				<pubDate>Sat, 18 Aug 2018 01:59:29 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[数据结构]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3205.html</guid>
				<description><![CDATA[作者：喵咪咪 链接：https://www.nowcoder.com/discuss/93459?type=0&#38;order=0&#38;pos=23&#38;page=0 来源：牛客网 5. 小明在抖音关注了n个主播，每个主播每天的开播时间是固定的，分别在时刻开始，ti时刻结束。小明无法同时看两个直播。一天被分为m个时间单位。请问小明每天最多能完整观看多少个直播？ 输入描述： 第一行一个整数，代表n 第二行一个整数，代表m 第三行空格分隔n*2个整数，代表s,t 输出描述： 一行一个整数，表示答案 输入： 3&#160; 10 0 3 3 7 7 0 输出 3 数据范围： 1 &#60;= n &#60;= 10^5 2 &#60;= m &#60;= 10^6 0 &#60;= si,ti &#60; m class Solution: def __init__(self): pass def conflict(self, state, next_tuple): if not state: return False if not next_tuple: return True for i in range(len(state)): if (next_tuple[0] &#60;= state[i][0] and next_tuple[1] &#62; state[i][0]) or (next_tuple[0] &#62;= state[i][0] and next_tuple[0] &#60; state[i][1]): return True return False def find_method(self, lst, array): if not lst: return array array.append([lst[0]]) length = len(array) for i in range(length): if not self.conflict(array[i], lst[0]): arr = array[i][:] arr.append(lst[0]) array.append(arr) self.find_method(lst[1:], array) return array def find_max(self, array): max = 0 lst = [] #print("length of array= %d" % len(array)) for i in range(len(array)): length = len(array[i]) if length &#62; max: max = length lst = array[i] print(max) print(lst) if __name__ == "__main__": ''' array contain all alternative result ''' so = Solution() lst = [[0, 3], [3, 7], [7, 10]] array = [] so.find_method(lst, array) so.find_max(array) &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<pre class="has">
<code class="hljs">作者：喵咪咪
链接：https://www.nowcoder.com/discuss/93459?type=0&amp;order=0&amp;pos=23&amp;page=0
来源：牛客网

5. 小明在抖音关注了n个主播，每个主播每天的开播时间是固定的，分别在时刻开始，ti时刻结束。小明无法同时看两个直播。一天被分为m个时间单位。请问小明每天最多能完整观看多少个直播？
输入描述：
第一行一个整数，代表n
第二行一个整数，代表m
第三行空格分隔n*2个整数，代表s,t
输出描述：
一行一个整数，表示答案
输入：
3&nbsp;
10
0 3 3 7 7 0
输出
3
数据范围：
1 &lt;= n &lt;= 10^5
2 &lt;= m &lt;= 10^6
0 &lt;= si,ti &lt; m</code></pre>
<pre class="has">
<code class="hljs language-python">class Solution:
    def __init__(self):
        pass

    def conflict(self, state, next_tuple):
        if not state:
            return False
        if not next_tuple:
            return True
        for i in range(len(state)):
            if (next_tuple[0] &lt;= state[i][0] and next_tuple[1] &gt; state[i][0]) or (next_tuple[0] &gt;= state[i][0] and next_tuple[0] &lt; state[i][1]):
                return True
        return False

    def find_method(self, lst, array):
        if not lst:
            return array
        array.append([lst[0]])
        length = len(array)
        for i in range(length):
            if not self.conflict(array[i], lst[0]):
                arr = array[i][:]
                arr.append(lst[0])
                array.append(arr)
        self.find_method(lst[1:], array)
        return array

    def find_max(self, array):
        max = 0
        lst = []
        #print("length of array= %d" % len(array))
        for i in range(len(array)):
            length = len(array[i])
            if length &gt; max:
                max = length
                lst = array[i]
        print(max)
        print(lst)

if __name__ == "__main__":
    '''
    array contain all alternative result
    '''
    so = Solution()
    lst = [[0, 3], [3, 7], [7, 10]]
    array = []
    so.find_method(lst, array)
    so.find_max(array)
</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Socket TCP协议 实时通信的粘包处理 Java与C++实现</title>
		<link>https://uzzz.org/article/2369.html</link>
				<pubDate>Sat, 12 Aug 2017 01:46:45 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[开发]]></category>
		<category><![CDATA[数据结构]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2369.html</guid>
				<description><![CDATA[原理： （经典）tcp粘包分析 场景： 此项目是处理实时监测数据，一旦tcp socket建立连接，会不间断实时发送数据，峰值输数据量在3M/秒，这样的数据量必然会造成数据粘包。 目的： TCP连接面向流，读取网络的一包数据不一定正好是协议里定义的完整的一包，有可能是多包，有可能是半包，也有可能是一包半，现在要将每次读取的数据进行分包，也就是粘包处理，提取出完整的一包数据供上层使用，上层需要将完整的一包数据里的数据根据协议定义的格式提取出来。 实现： 将收到的数据copy到缓存区，在缓存区里循环从起始位按照协议找出完整的一包数据提取出来。 关键点在于根据协议找出完整一包数据的长度。 从网络读取数据后拷贝到缓存区 判断：缓存区里数据占位，长度小于某个值n，return再次读取网络数据。这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 循环：如果缓存区长度大于解析出来的完整一包的长度 执行： 取出完整一包数据后，然后剔除这包，将缓存区剩余数据放置起始位 循环里再次判断： 长度小于某个值n，return再次读取网络数据。 这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理 如果协议定义了帧头，可以在取包的长度之前校验帧头，确保数据正确。 这里说明定义缓冲区buffer的长度大小：必须要大于可能收到的最大数据包的长度加上read读取一次网络最大数据长度 原因是缓冲区里可能剩下不到一包数据，下一次读取网络数据后要将数据copy至缓冲区，如果超过缓冲区大小就无法进行处理。可在copy时加一层判断，如果超过缓存区，就直接返回，断开连接。代表这种数据包不能进行处理。如果缓存区设计合理，不会出现此种情况。read读取一次网络最大数据长度是在read到的buffer定义的长度。缓冲区的buffer不要设置过大，占用太多内存。 数据源说明：第一位固定#。第二位表示之后有几位代表了之后的数据的长度，比如第一条数据的第二位4，代表之后的四位3350是从0：开始共有3350个字节长度的数据。之后的数据跟业务相关。 主要代码： Java实现： 不可用于生产环境，理解思想后根据业务数据处理粘包 private static int MAXDATALEN = 500000; //处理数据缓冲池的长度 private static int RECEIVEDATALEN = 200000;//读取网络数据包最大长度 private int SiglePackageLen = 0;//提取出包的长度 private int SequenceLen = 0;//当前缓冲区内数据长度 private byte BuffSequencePackage[] = new byte[MAXDATALEN];//数据缓冲池 public void readData() { //读取网络数据长度 int RecvLen; //缓存区 byte ReceiveData[] = new byte[RECEIVEDATALEN]; try { while (AdapterManager.getInstance().isFlag()) { if (mSocket.isConnected()) { if (!mSocket.isInputShutdown()) { if ((RecvLen = inputstream.read(ReceiveData)) != 0) { NetNum++; // Log.i("Read", "&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;&#62;第" + NetNum + "次读取网络数据 共" + RecvLen + "字节&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;&#60;"); if (RecvLen &#60;= 0) { ToastUtils.showShortSafe(ERROR_Device); Log.i(TAG, "设备断开连接，RecvLen: " + RecvLen); return; } ReceivedPackage(RecvLen,ReceiveData); } } } } } catch (SocketTimeoutException e) { e.printStackTrace(); Log.i(TAG, "网络异常断开，收取数据超时"); ToastUtils.showShortSafe(ERROR_NetBreak); } catch (SocketException e) { e.printStackTrace(); Log.i(TAG, "停止任务，断开连接"); } catch (Exception e) { e.printStackTrace(); Log.i(TAG, "读取数据异常"); } } /** * 粘包处理 * */ public void ReceivedPackage(int RecvLen,byte[] ReceiveData) throws Exception { pakageNum = 0; //将收到的数据copy至缓冲区 System.arraycopy(ReceiveData, 0, BuffSequencePackage, SequenceLen, RecvLen); //记录缓冲区usedlength SequenceLen += RecvLen; //这一步保证后续操作能解析出这一包数据的长度 if (SequenceLen &#60;10) { return; } int lentemp = BuffSequencePackage[1]]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h3 id="原理">原理：</h3>
<p><a href="http://blog.csdn.net/zhangxinrun/article/details/6721495" rel="nofollow noopener noreferrer" target="_blank" data-token="cb9b2f7abd0dbebca5d6e5022496b4a3">（经典）tcp粘包分析</a></p>
<h3 id="场景">场景：</h3>
<p>此项目是处理实时监测数据，一旦tcp socket建立连接，会不间断实时发送数据，峰值输数据量在3M/秒，这样的数据量必然会造成数据粘包。</p>
<h3 id="目的">目的：</h3>
<p>TCP连接面向流，读取网络的一包数据不一定正好是协议里定义的完整的一包，有可能是多包，有可能是半包，也有可能是一包半，现在要将每次读取的数据进行分包，也就是粘包处理，提取出完整的一包数据供上层使用，上层需要将完整的一包数据里的数据根据协议定义的格式提取出来。</p>
<h3 id="实现">实现：</h3>
<p>将收到的数据copy到缓存区，在缓存区里循环从起始位按照协议找出完整的一包数据提取出来。 <br /> <strong>关键点在于根据协议找出完整一包数据的长度</strong>。</p>
<ol>
<li>从网络读取数据后拷贝到缓存区</li>
<li>判断：缓存区里数据占位，长度小于某个值n，return再次读取网络数据。这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理</li>
<li>循环：如果缓存区长度大于解析出来的完整一包的长度</li>
<li>执行： 取出完整一包数据后，然后剔除这包，将缓存区剩余数据放置起始位</li>
<li>循环里再次判断： 长度小于某个值n，return再次读取网络数据。 这个值n长度的数据内要能解析出单个完整包的长度，以便后续处理</li>
</ol>
<p>如果协议定义了帧头，可以在取包的长度之前校验帧头，确保数据正确。</p>
<p><strong>这里说明定义缓冲区buffer的长度大小：必须要大于可能收到的最大数据包的长度加上read读取一次网络最大数据长度</strong> <br /> 原因是缓冲区里可能剩下不到一包数据，下一次读取网络数据后要将数据copy至缓冲区，如果超过缓冲区大小就无法进行处理。可在copy时加一层判断，如果超过缓存区，就直接返回，断开连接。代表这种数据包不能进行处理。如果缓存区设计合理，不会出现此种情况。read读取一次网络最大数据长度是在read到的buffer定义的长度。缓冲区的buffer不要设置过大，占用太多内存。 <br /> <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170807182740473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWmMwOTA4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="数据源" title=""></p>
<p>数据源说明：第一位固定#。第二位表示之后有几位代表了之后的数据的长度，比如第一条数据的第二位4，代表之后的四位3350是从0：开始共有3350个字节长度的数据。之后的数据跟业务相关。</p>
<h3 id="主要代码"><strong>主要代码：</strong></h3>
<p>Java实现： <br /> 不可用于生产环境，理解思想后根据业务数据处理粘包</p>
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAXDATALEN = <span class="hljs-number">500000</span>; <span class="hljs-comment">//处理数据缓冲池的长度</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> RECEIVEDATALEN = <span class="hljs-number">200000</span>;<span class="hljs-comment">//读取网络数据包最大长度</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> SiglePackageLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//提取出包的长度</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> SequenceLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//当前缓冲区内数据长度</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span> BuffSequencePackage[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[MAXDATALEN];<span class="hljs-comment">//数据缓冲池</span></code></pre>
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span>() {
    <span class="hljs-comment">//读取网络数据长度</span>
        <span class="hljs-keyword">int</span> RecvLen;
        <span class="hljs-comment">//缓存区</span>
        <span class="hljs-keyword">byte</span> ReceiveData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[RECEIVEDATALEN];
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">while</span> (AdapterManager.getInstance().isFlag()) {
                <span class="hljs-keyword">if</span> (mSocket.isConnected()) {
                    <span class="hljs-keyword">if</span> (!mSocket.isInputShutdown()) {
                        <span class="hljs-keyword">if</span> ((RecvLen = inputstream.read(ReceiveData)) != <span class="hljs-number">0</span>) {
                            NetNum++;
<span class="hljs-comment">// Log.i("Read", "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;第" + NetNum + "次读取网络数据 共" + RecvLen + "字节&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;");</span>
                            <span class="hljs-keyword">if</span> (RecvLen &lt;= <span class="hljs-number">0</span>) {
                                ToastUtils.showShortSafe(ERROR_Device);
                                Log.i(TAG, <span class="hljs-string">"设备断开连接，RecvLen: "</span> + RecvLen);
                                <span class="hljs-keyword">return</span>;
                            }
                            ReceivedPackage(RecvLen,ReceiveData);
                        }
                    }
                }
            }

        } <span class="hljs-keyword">catch</span> (SocketTimeoutException e) {
            e.printStackTrace();
            Log.i(TAG, <span class="hljs-string">"网络异常断开，收取数据超时"</span>);
            ToastUtils.showShortSafe(ERROR_NetBreak);
        } <span class="hljs-keyword">catch</span> (SocketException e) {
            e.printStackTrace();
            Log.i(TAG, <span class="hljs-string">"停止任务，断开连接"</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
            Log.i(TAG, <span class="hljs-string">"读取数据异常"</span>);
        }

    }</code></pre>
<pre class="prettyprint"><code class=" hljs java">     <span class="hljs-javadoc">/** * 粘包处理 * */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReceivedPackage</span>(<span class="hljs-keyword">int</span> RecvLen,<span class="hljs-keyword">byte</span>[] ReceiveData) <span class="hljs-keyword">throws</span> Exception {
        pakageNum = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//将收到的数据copy至缓冲区</span>
        System.arraycopy(ReceiveData, <span class="hljs-number">0</span>, BuffSequencePackage, SequenceLen, RecvLen);
        <span class="hljs-comment">//记录缓冲区usedlength</span>
        SequenceLen += RecvLen;
        <span class="hljs-comment">//这一步保证后续操作能解析出这一包数据的长度</span>
        <span class="hljs-keyword">if</span> (SequenceLen &lt;<span class="hljs-number">10</span>) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">int</span> lentemp = BuffSequencePackage[<span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>;
        SiglePackageLen = Integer.parseInt(<span class="hljs-keyword">new</span> String(Arrays.copyOfRange(BuffSequencePackage, <span class="hljs-number">2</span>, lentemp + <span class="hljs-number">2</span>))) + <span class="hljs-number">2</span> + lentemp;
        <span class="hljs-comment">//缓存区长度大于等于下一包的长度，说明缓冲区里还有完整的一包数据</span>
        <span class="hljs-keyword">while</span> (SiglePackageLen &lt;= SequenceLen) {
            <span class="hljs-comment">//判断任务是否结束。如果网络不佳或程序没有及时处理数据导致网络中的数据缓存过多，一次read读取数据就会将read的ReceiveData沾满，如果read的ReceiveData长度定义很大，将这些数据copy至缓存区，则这个循环会执行一段时间， 如果没有这层判断，即使任务结束，这个循环还在执行。</span>
            <span class="hljs-keyword">if</span> (!AdapterManager.getInstance().isFlag()) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">//取出第一包数据分析</span>
            <span class="hljs-keyword">byte</span> SiglePackage[] = Arrays.copyOfRange(BuffSequencePackage, <span class="hljs-number">2</span> + lentemp, SiglePackageLen);
            AnalyseReceivedPackage(SiglePackage);
            <span class="hljs-comment">//剔除缓冲区第一包数据</span>
            <span class="hljs-keyword">byte</span> temp[] = Arrays.copyOfRange(BuffSequencePackage, SiglePackageLen, SequenceLen);
            <span class="hljs-comment">//记录缓冲区usedlength</span>
            SequenceLen = SequenceLen - SiglePackageLen;
            <span class="hljs-comment">//清空缓存区</span>
            resumeSequence();
            <span class="hljs-comment">//将剩余数据copy至缓冲区，从头部开始</span>
            System.arraycopy(temp, <span class="hljs-number">0</span>, BuffSequencePackage, <span class="hljs-number">0</span>, temp.length);
            <span class="hljs-comment">//再次进行验证，剩余的长度是否能提取出下一包数据的长度</span>
            <span class="hljs-keyword">if</span> (SequenceLen &lt; <span class="hljs-number">10</span>) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-comment">//提取下一包数据长度</span>
            lentemp = BuffSequencePackage[<span class="hljs-number">1</span>] - <span class="hljs-string">'0'</span>;
            SiglePackageLen = Integer.parseInt(<span class="hljs-keyword">new</span> String(Arrays.copyOfRange(BuffSequencePackage, <span class="hljs-number">2</span>, lentemp + <span class="hljs-number">2</span>))) + <span class="hljs-number">2</span> + lentemp;

        }

    }</code></pre>
<p>c++实现：</p>
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//s_plocalStationData是从队列里申请的缓存区，length是缓存区有效数据的长度，MessageHead是帧头结构体</span>
    LocalStationDataInfo<span class="hljs-subst">*</span> info <span class="hljs-subst">=</span> pContext<span class="hljs-subst">-&gt;</span>m_Array<span class="hljs-subst">-&gt;</span>s_plocalStationData;
    <span class="hljs-comment">//将数据copy到缓存区</span>
    memcpy(info<span class="hljs-subst">-&gt;</span>pdata<span class="hljs-subst">+</span>info<span class="hljs-subst">-&gt;</span>length , pOverlapBuff<span class="hljs-subst">-&gt;</span>GetBuffer(),nSize);
    info<span class="hljs-subst">-&gt;</span>length <span class="hljs-subst">=</span>nSize <span class="hljs-subst">+</span> info<span class="hljs-subst">-&gt;</span>length;
    <span class="hljs-keyword">if</span>(info<span class="hljs-subst">-&gt;</span>length<span class="hljs-subst">&lt;</span>sizeof(MessageHead)){
        <span class="hljs-keyword">return</span>;
    }
    unsigned long singlePakageLength <span class="hljs-subst">=</span> FindPackagetLength(info<span class="hljs-subst">-&gt;</span>pdata);
    <span class="hljs-keyword">while</span>(singlePakageLength <span class="hljs-subst">&lt;=</span> (info<span class="hljs-subst">-&gt;</span>length)){
        <span class="hljs-comment">//将完整的一包提取出来分析</span>
        AnalyseReceivedPackage(info<span class="hljs-subst">-&gt;</span>pdata,singlePakageLength);
        info<span class="hljs-subst">-&gt;</span>length <span class="hljs-subst">=</span>info<span class="hljs-subst">-&gt;</span>length <span class="hljs-subst">-</span> singlePakageLength;
        <span class="hljs-comment">//剔除缓存区第一包数据</span>
        memmove(info<span class="hljs-subst">-&gt;</span>pdata,info<span class="hljs-subst">-&gt;</span>pdata<span class="hljs-subst">+</span>singlePakageLength,info<span class="hljs-subst">-&gt;</span>length);
        <span class="hljs-comment">//确保缓存区剩余数据长度可以提取出下一包数据的包长</span>
        <span class="hljs-keyword">if</span>(info<span class="hljs-subst">-&gt;</span>length <span class="hljs-subst">&lt;</span> sizeof(MessageHead)){ 
            <span class="hljs-keyword">return</span>;
        }
        singlePakageLength <span class="hljs-subst">=</span> FindPackagetLength(info<span class="hljs-subst">-&gt;</span>pdata);
    }</code></pre>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>网络编程之：TCP服务器的简单实现</title>
		<link>https://uzzz.org/article/2435.html</link>
				<pubDate>Mon, 08 Aug 2016 13:10:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[数据结构]]></category>
		<category><![CDATA[网络安全]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2435.html</guid>
				<description><![CDATA[说到TCP服务器，就不得不提socket编程，我们知道，在TCP/IP协议中,“IP地址+TCP或UDP端口号”唯一标识⽹络通讯中的唯一一个进程,“IP地址+端口号”就称为socket。 在TCP协议中,建立连接的两个进程各自有一个socket来标识,那么这两个socket组成 的socket pair就唯一标识一个连接。socket本身有“插座”的意思,因此⽤来描述网络连接的一 对⼀的关 系。&#160; TCP/IP协议最早在BSD UNIX上实现,为TCP/IP协议设计的应用层编程接口称为socket API。 TCP/IP协议规定:网络数据流规定应采用大端字节序，即低地址存储高位数据，因此网络数据流的地址是由低到高的，此处应包括收取哈发送数据两个过程。 &#160;1.socket数据类型及其相关函数 socket API是一层抽象的⽹网络编程接口,适⽤用于各种底层⽹网络协议,如IPv4、IPv6,以及UNIX Domain Socket。然⽽,各种网络协议的地址格式并不相同,如下图所示: sockaddr数据结构： 可以看到，各种sockaddr的地址结构前16位都是一样的，都表示整个结构体的长度，IPv4、IPv6和UNIX Domain Socket的地 址类型分别定义为常数AF_INET、AF_INET6、AF_UNI，这样,只要取 得某种sockaddr结构体的 ⾸首地址,不需要知道具体是哪种类型的sockaddr结构体,就可以根据地 址类型字段确定结构体中的内容。因此,socket API可以接受各种类型的sockaddr结构体指针做参数,例如bind、accept、connect等函数,这些函数的参数应该设计成void *类型以便接受各 种类型的指 针,但是sock API的实现早于ANSI C标准化,那时还没有void *类型,因此这些函数的参数都用struct sockaddr *类型表示,在传递参数之前要强制类型转换⼀下。 举个例子：bind(listen_sock,(struct sockaddr*)&#38;local,sizeof(local)) 下面是基于TCP协议服务器/客户端的一般流程： 服务器调用socket()&#8212;创建套接字、bind()&#8212;绑定、listen()&#8212;监听， 完成初始化后,调⽤accept()阻塞等待,处于监听端口的状态,客户端调用socket()初始化后,调用connect()发出SYN段并阻塞等待服务器应答,服务器应答一个SYN-ACK段,客户端收到后从connect()返回,同时应答一个ACK段,服务器收到后从accept()返回。 数据传输的过程：&#160;建立连接后,TCP协议提供全双工的通信服务,但是一般的客户端/服务器程序的流程是由客户端主动发起请求,服务器被动处理请求,一问一答的⽅方式。因此,服务器accept()返回后立刻调用read(),读socket就像读管道一样,如果没有数据到达就阻塞等待,这时客户端调用write()发送请求给服务器,服务器收到后从read()返回,对客户端的请求进行处理,在此 期间客户端调用read()阻塞等待服务器的应答,服务器调用write()将处理结果发回给客户端,再次调⽤用read()阻塞 等待下一条请求,客户端收到后从read()返回,发送下一条请求,如此循环下去。&#160; 如果客户端没有更多的请求了,就调用close() 关闭连接,就像写端关闭的管道⼀样,服务器 的 read()返回0,这样服务器就知道客户端关闭了连接,也调⽤用close()关闭连接。注意,任何⼀方close()后,连接的两个传输⽅方向都关闭,不能再发送数据了。如果⼀方调用shutdown() 则连接处于半关闭状态,仍可接收对⽅方发来的数据。 下面就来看一下这个服务器和客户端是如何实现的： 首先来到目录下创建server.c和client.c两个文件，在编写一下Makefile文件，然后正式编写server.c： &#160; &#160; 以上就是server的编写，下面是client 的编写： 好了，现在服务器和客户端已将编写好了，我们来测试一下： 我们在另一个终端进入到目标目录里运行client，并输入文字： 然后来看看客户端是否可以收到client发过来的消息： server已经成功收到了消息，并且TCP服务器只能被动的接受处理client发起的请求，所以只能是server接受client发来的消息，server并不能给client发消息。 好啦，这就是我编写的简单的TCP服务器/客户端啦，希望各种小伙伴们指出问题，共同学习~]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
  <span></span> </p>
<div>
   <span style="font-size:16px;">说到TCP服务器，就不得不提socket编程，我们知道，在TCP/IP协议中,“IP地址+TCP或UDP端口号”唯一标识⽹络通讯中的唯一一个进程,“<strong>IP地址+端口号</strong>”就称为<strong>socket</strong>。</span>
  </div>
<div>
   <span style="font-size:16px;">在TCP协议中,建立连接的两个进程各自有一个socket来标识,那么这两个socket组成 的socket pair就唯一标识一个连接。socket本身有“插座”的意思,因此⽤来描述网络连接的一 对⼀的关 系。&nbsp;</span>
  </div>
<div>
   <span style="font-size:16px;">TCP/IP协议最早在BSD UNIX上实现,为TCP/IP协议设计的应用层编程接口称为socket API</span>。
  </div>
<div>
   <span style="font-size:16px;">TCP/IP协议规定:<span style="color:rgb(235,0,115);">网络数据流规定应采用大端字节序，即低地址存储高位数据，因此网络数据流的地址是由低到高的，此处应包括收取哈发送数据两个过程。</span></span>
  </div>
<div>
   <span style="font-size:16px;">&nbsp;1.socket数据类型及其相关函数</span>
  </div>
<div>
   <span style="font-size:18px;"><span>socket API是一层抽象的⽹网络编程接口,适⽤用于各种底层⽹网络协议,如IPv4、IPv6,以及UNIX Domain Socket。然⽽,各种网络协议的地址格式并不相同,如下图所示:</span></span>
  </div>
<div>
   <span style="font-size:18px;"><span>sockaddr数据结构：</span></span>
  </div>
<div>
   <span style="font-size:18px;"><span><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205132630?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span></span>
  </div>
<div></div>
<div>
   <span style="font-size:18px;"><span>可以看到，各种sockaddr的地址结构前16位都是一样的，都表示整个结构体的长度，IPv4、IPv6和UNIX Domain Socket的地 址类型分别定义为常数AF_INET、AF_INET6、AF_UNI，这样,只要取 得某种sockaddr结构体的 ⾸首地址,不需要知道具体是哪种类型的sockaddr结构体,就可以根据地 址类型字段确定结构体中的内容。因此,socket API可以接受各种类型的sockaddr结构体指针做参数,例如bind、accept、connect等函数,这些函数的参数应该设计成void *类型以便接受各 种类型的指 针,但是sock API的实现早于ANSI C标准化,那时还没有void *类型,因此这些函数的参数都用struct sockaddr *类型表示,在传递参数之前要强制类型转换⼀下。</span></span>
  </div>
<div>
   <span style="font-size:16px;">举个例子：bind(listen_sock,(struct sockaddr*)&amp;local,sizeof(local))</span>
  </div>
<div align="left">
   
  </div>
<div align="left">
   
  </div>
<div align="left">
   <span style="font-size:16px;">下面是基于TCP协议服务器/客户端的一般流程：</span>
  </div>
<div align="left">
   <span style="font-size:16px;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205156924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span>
  </div>
<div align="left"></div>
<div align="left">
   <span style="font-size:16px;">服务器调用socket()&#8212;创建套接字、bind()&#8212;绑定、listen()&#8212;监听， 完成初始化后,调⽤accept()阻塞等待,处于监听端口的状态,客户端调用socket()初始化后,调用connect()发出SYN段并阻塞等待服务器应答,服务器应答一个SYN-ACK段,客户端收到后从connect()返回,同时应答一个ACK段,服务器收到后从accept()返回。</span>
  </div>
<div align="left">
   <span style="font-size:16px;"><br /></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span><strong>数据传输的过程</strong>：&nbsp;建立连接后,TCP协议提供<span style="color:rgb(235,0,115);">全双工</span>的通信服务,但是一般的客户端/服务器程序的流程是由<span style="color:rgb(235,0,115);">客户端主动发起请求</span>,<span style="color:rgb(235,0,115);">服务器被动处理请求</span>,一问一答的⽅方式。因此,服务器accept()返回后立刻调用read(),读socket就像读管道一样,如果没有数据到达就阻塞等待,这时客户端调用write()发送请求给服务器,服务器收到后从read()返回,对客户端的请求进行处理,在此 期间客户端调用read()阻塞等待服务器的应答,服务器调用write()将处理结果发回给客户端,再次调⽤用read()阻塞 等待下一条请求,客户端收到后从read()返回,发送下一条请求,如此循环下去。&nbsp;</span></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span>如果客户端没有更多的请求了,就调用close() 关闭连接,就像写端关闭的管道⼀样,服务器 的 read()返回0,这样服务器就知道客户端关闭了连接,也调⽤用close()关闭连接。注意,任何⼀方close()后,连接的两个传输⽅方向都关闭,不能再发送数据了。如果⼀方调用shutdown() 则连接处于半关闭状态,仍可接收对⽅方发来的数据。</span></span>
  </div>
<div align="left">
   <span style="font-size:16px;"><br /></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span>下面就来看一下这个服务器和客户端是如何实现的：</span></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span>首先来到目录下创建server.c和client.c两个文件，在编写一下Makefile文件，然后正式编写server.c：</span></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205224175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205551207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span></span>
  </div>
<div align="left">
   <span style="font-size:18px;"><span>&nbsp;<img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205609161?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205622544?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808205639013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span></span>
  </div>
<div align="left">
   <span style="font-size:16px;">&nbsp;</span>
  </div>
<div align="left">
   <span style="font-size:16px;">以上就是server的编写，下面是client 的编写：</span>
  </div>
<div align="left">
   <span style="font-size:16px;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808210025863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span>
  </div>
<div align="left">
   <span style="font-size:16px;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808210044382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span>
  </div>
<div align="left">
   <span style="font-size:16px;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808210106663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span>
  </div>
<div align="left">
   <span style="font-size:16px;"><br /></span>
  </div>
<div align="left">
   <span style="font-size:16px;">好了，现在服务器和客户端已将编写好了，我们来测试一下：</span>
  </div>
<div>
   
  </div>
<div>
   <span style="font-size:14px;">我们在另一个终端进入到目标目录里运行client，并输入文字：</span>
  </div>
<div>
   <span style="font-size:14px;"><img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808210437994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"></span>
  </div>
<p>  <span style="font-size:16px;"></span> </p>
<div>
   
  </div>
<div align="left">
   然后来看看客户端是否可以收到client发过来的消息：
  </div>
<div align="left">
   <img alt="" src="https://uzshare.com/_p?https://img-blog.csdn.net/20160808210648528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
  </div>
<div align="left">
   server已经成功收到了消息，并且TCP服务器只能被动的接受处理client发起的请求，所以只能是server接受client发来的消息，server并不能给client发消息。
  </div>
<div align="left">
   好啦，这就是我编写的简单的TCP服务器/客户端啦，希望各种小伙伴们指出问题，共同学习~<br />
   
  </div>
<div>
   <span style="font-size:16px;"><br /></span>
  </div>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
