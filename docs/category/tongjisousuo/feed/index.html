<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>统计搜索 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/tongjisousuo/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Wed, 16 Oct 2019 03:12:40 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>统计搜索 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Deferred Deep Linking in iOS</title>
		<link>https://uzzz.org/article/1648.html</link>
				<pubDate>Wed, 16 Oct 2019 03:12:40 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[前端]]></category>
		<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1648.html</guid>
				<description><![CDATA[Deep Linking 其实 deep linking 并不是一个新名词，在 web 开发领域，区别于指向首页的链接（http://tech.glowing.com/），deep linking 是指向具体内容页的链接（http://tech.glowing.com/cn/advices-to-junior-developers/）。在移动开发领域，deep linking 则是指 mobile app 在 handle 特定 URI 的时候可以直接跳转到对应的内容页或触发特定逻辑，而不仅仅是启动 app。比如&#160;dianping://shopinfo?id=1859284，如果你的手机上装了大众点评的话点击这个链接可以直接跳转到商铺页面。这样做的好处主要有： 在 web 和 app 的切换过程中保留上下文 App 间带上下文切换（用于实现 app 间参数的传递，如授权协议，分享 API 等） Web 页可以被搜索引擎索引，可以通过 SEO 增加访问量从而提高 app 下载量和开启率 目前处理 deep linking，主要有两种方式： Custom URL Scheme 在 universal links 出现之前的很长一段时间里，iOS 上主要通过 custom URL scheme 来实现 deep linking，以及 app 间的通信。 在 info plist 里设置了自定义 URL 后，handle URL 的入口是 app delegate 方法&#160;application:openURL:sourceApplication:annotation:（iOS 9 开始被 deprecate）或&#160;application:openURL:options:（iOS 9 引入，但如果没有实现这个方法，在 iOS 9 上还是会向前兼容 call 老方法，所以一般还是实现老方法）。 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { BOOL handled = NO; // code to handle the URL return handled; } 一个比较完整的&#160;NSURL&#160;可以包含以下部分：scheme://user:password@host:port/path?query#fragment。但对于 deep linking 来说大部分时候只需要&#160;scheme://host/path?query。有时候会省去&#160;path&#160;部分，把&#160;host&#160;直接作为 command，如上文提到的点评的 link；也有些 app 会省去&#160;query&#160;部分，用&#160;path&#160;传参，更接近 RESTful API 的风格。这取决于具体业务逻辑复杂程度以及 handler 的实现方式。有一点需要注意的是，规范的 URL 是 percentage encoded 的，所以取出来的参数需要用&#160;stringByReplacingPercentEscapesUsingEncoding:&#160;或&#160;stringByRemovingPercentEncoding（iOS 7+）方法 decode。反之，拼 URL 的时候应该使用&#160;stringByAddingPercentEscapesUsingEncoding:&#160;或&#160;stringByAddingPercentEncodingWithAllowedCharacters:（iOS 7+）方法 encode。 在 iOS 7+ 上处理&#160;query&#160;的时候也可以配合使用&#160;NSURLComponents&#160;类。 具体 handle URL 的时候，对于需要处理的业务逻辑较少的 app 来说，可以简单地通过字符串比较来区分业务逻辑。对于业务逻辑相对复杂，特别是在跨团队共同维护 URL handler 的时候，则需要引入 router 来分发请求。关于 router 已经有很多文章涉及，GitHub 上也有很多开源代码可供参考或使用，比如： DeepLinkKit JLRoutes Routable HHRouter 具体选型或自己实现 router 的时候主要考虑一些问题比如：用 code 注册还是配置文件；是否需要去中心化；如何传参；以 view controller 还是 block (closure) 为单位来注册 handler；是否需要像淘宝一样做 web 版的 failover 等等…… 这里不再展开。 相关文档：Using URL Schemes to Communicate with Apps Universal Links Apple 在 iOS 9 上引入了 universal links，相较 custom URL]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h2 id="deeplinking">Deep Linking</h2>
<p>其实 deep linking 并不是一个新名词，在 web 开发领域，区别于指向首页的链接（<a href="http://tech.glowing.com/" rel="nofollow" data-token="efff885cd38466b8978dc7a2d9c8e4d4">http://tech.glowing.com/</a>），deep linking 是指向具体内容页的链接（<a href="http://tech.glowing.com/cn/advices-to-junior-developers/" rel="nofollow" data-token="6d8445426865d1ebfab7c34c761767e2">http://tech.glowing.com/cn/advices-to-junior-developers/</a>）。在移动开发领域，deep linking 则是指 mobile app 在 handle 特定 URI 的时候可以直接跳转到对应的内容页或触发特定逻辑，而不仅仅是启动 app。比如&nbsp;<a>dianping://shopinfo?id=1859284</a>，如果你的手机上装了大众点评的话点击这个链接可以直接跳转到商铺页面。这样做的好处主要有：</p>
<ul>
<li>在 web 和 app 的切换过程中保留上下文</li>
<li>App 间带上下文切换（用于实现 app 间参数的传递，如授权协议，分享 API 等）</li>
<li>Web 页可以被搜索引擎索引，可以通过 SEO 增加访问量从而提高 app 下载量和开启率</li>
</ul>
<p>目前处理 deep linking，主要有两种方式：</p>
<h3 id="customurlscheme">Custom URL Scheme</h3>
<p>在 universal links 出现之前的很长一段时间里，iOS 上主要通过 custom URL scheme 来实现 deep linking，以及 app 间的通信。</p>
<p>在 info plist 里设置了自定义 URL 后，handle URL 的入口是 app delegate 方法&nbsp;<code>application:openURL:sourceApplication:annotation:</code>（iOS 9 开始被 deprecate）或&nbsp;<code>application:openURL:options:</code>（iOS 9 引入，但如果没有实现这个方法，在 iOS 9 上还是会向前兼容 call 老方法，所以一般还是实现老方法）。</p>
<pre class="has">
<code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
        sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {
    BOOL handled = NO;
    // code to handle the URL
    return handled;
}
</code></pre>
<p>一个比较完整的&nbsp;<code>NSURL</code>&nbsp;可以包含以下部分：<code>scheme://user:password@host:port/path?query#fragment</code>。但对于 deep linking 来说大部分时候只需要&nbsp;<code>scheme://host/path?query</code>。有时候会省去&nbsp;<code>path</code>&nbsp;部分，把&nbsp;<code>host</code>&nbsp;直接作为 command，如上文提到的点评的 link；也有些 app 会省去&nbsp;<code>query</code>&nbsp;部分，用&nbsp;<code>path</code>&nbsp;传参，更接近 RESTful API 的风格。这取决于具体业务逻辑复杂程度以及 handler 的实现方式。有一点需要注意的是，规范的 URL 是 percentage encoded 的，所以取出来的参数需要用&nbsp;<code>stringByReplacingPercentEscapesUsingEncoding:</code>&nbsp;或&nbsp;<code>stringByRemovingPercentEncoding</code>（iOS 7+）方法 decode。反之，拼 URL 的时候应该使用&nbsp;<code>stringByAddingPercentEscapesUsingEncoding:</code>&nbsp;或&nbsp;<code>stringByAddingPercentEncodingWithAllowedCharacters:</code>（iOS 7+）方法 encode。</p>
<p>在 iOS 7+ 上处理&nbsp;<code>query</code>&nbsp;的时候也可以配合使用&nbsp;<code>NSURLComponents</code>&nbsp;类。</p>
<p>具体 handle URL 的时候，对于需要处理的业务逻辑较少的 app 来说，可以简单地通过字符串比较来区分业务逻辑。对于业务逻辑相对复杂，特别是在跨团队共同维护 URL handler 的时候，则需要引入 router 来分发请求。关于 router 已经有很多文章涉及，GitHub 上也有很多开源代码可供参考或使用，比如：</p>
<ul>
<li><a href="https://github.com/usebutton/DeepLinkKit" rel="nofollow" data-token="3e0a67656caa2f3027e17d35b13fcfb1">DeepLinkKit</a></li>
<li><a href="https://github.com/joeldev/JLRoutes" rel="nofollow" data-token="6aa1fff80a4b01bab7ab2a0b013fa624">JLRoutes</a></li>
<li><a href="https://github.com/clayallsopp/routable-ios" rel="nofollow" data-token="32e006e6a6fa5b7019964f00fe63b9df">Routable</a></li>
<li><a href="https://github.com/Huohua/HHRouter" rel="nofollow" data-token="6625a9b89125f8dece54634ece6991ec">HHRouter</a></li>
</ul>
<p>具体选型或自己实现 router 的时候主要考虑一些问题比如：用 code 注册还是配置文件；是否需要去中心化；如何传参；以 view controller 还是 block (closure) 为单位来注册 handler；是否需要像淘宝一样做 web 版的 failover 等等…… 这里不再展开。</p>
<p>相关文档：<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW1" rel="nofollow" data-token="bf36d2a82aa333fd52b2e4b88bad47f1">Using URL Schemes to Communicate with Apps</a></p>
<h3 id="universallinks">Universal Links</h3>
<p>Apple 在 iOS 9 上引入了 universal links，相较 custom URL scheme，universal links 有以下好处：</p>
<ul>
<li>Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性。</li>
<li>不同的 app 是可以定义相同的 custom URL scheme 的，所以会存在抢占或冲突的问题，而 universal links 是从 server 查询由哪个 app 打开的，所以不存在上述问题。</li>
<li>Universal links 支持从其他 app 的 MKWebView 或 UIWebView 中跳转到目标 app。</li>
<li>Universal links 本身可以被搜索引擎索引。</li>
</ul>
<p>Universal links 的具体实现可以参考官方文档：<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW1" rel="nofollow" data-token="a18ae2e5a4207c610a62860d64f4fa58">Support Universal Links</a>。简单来说你需要：</p>
<ul>
<li>添加一个&nbsp;<code>apple-app-site-association</code>&nbsp;文件到你的网站来描述 URL 和 app 的关联。</li>
<li>添加&nbsp;<code>com.apple.developer.associated-domains</code>&nbsp;entitlement 来指定要从哪些域名查询 universal links support。</li>
<li>在 app delegate 的&nbsp;<code>application:continueUserActivity:restorationHandler:</code>&nbsp;方法中 handle&nbsp;<code>userActivity.webpageURL</code>。</li>
</ul>
<p>处理 URL 本身的方法跟前面处理 custom URL 类似，不再赘述。</p>
<h2 id="deferreddeeplinking">Deferred Deep Linking</h2>
<p>顾名思义，deferred deep linking 是指用户打开一个 web page 的时候并没有安装对应的 app，希望用户在安装 app 以后可以 deep link 到对应内容。这里有三个需要解决的问题：</p>
<ol>
<li>判断是否已经安装了 app，如果已经安装了直接 deep link 到 app，否则跳转 App Store。</li>
<li>用户匹配（user matching），如何把一个 install 对应到某一次 web page view 或者某一次 click。</li>
<li>Deep linking</li>
</ol>
<h3 id="1">问题 1</h3>
<p><strong>以前</strong>在使用 custom URL 的时候一般用类似这样的一段 JS 处理：</p>
<pre class="has">
<code>window.location = 'lexie://';  
setTimeout(function() {  
    window.location = 'itms-apps://itunes.apple.com/us/app/eve-by-glow-period-tracker/id1002275138'
}, 250);
</code></pre>
<p>这是因为在 iOS 9.2 以前，Safari 里是否用 app 打开 custom URL 的提示是 blocking JS 的，所以如果用户同意用 app 打开链接以后就不会跳转 App Store，反之，用户选择取消或者并没有安装 app 的时候，会跳转 App Store。iOS 9.2 Apple 做了一个更新就是这个提示不再 block JS，所以无论如何都会跳转 App Store。因此现在会推荐使用 universal links 来实现这样的逻辑，对于需要强制安装 app 后才能浏览的内容，可以提供一个直接跳转 App Store 的中转页面，如果装了 app，iOS 会自动跳转到 app 内处理。</p>
<p><strong>2016-01-06 更新：</strong></p>
<p>经过 @zyg 的提醒和测试，这里的逻辑在 iOS 9.2 上还分两种情况：</p>
<p><a href="http://tech.glowing.com/cn/content/images/deeplink.html" rel="nofollow" data-token="5f174422cdb26d64931a1ccd67309cd3">http://tech.glowing.com/cn/content/images/deeplink.html</a><br /><a href="http://tech.glowing.com/cn/content/images/deeplink2.html" rel="nofollow" data-token="b673395aec2296e447690d73f72a84c9">http://tech.glowing.com/cn/content/images/deeplink2.html</a></p>
<p>代码的区别：前者是 link 触发 JS；后者是 onload 时候直接触发。<br /> 结果的区别：前者会直接跳转 App Store；后者不会。</p>
<p>原因：Safari 里，点击事件触发跳转 App Store 没有是否在 App Store 打开的确认提示；非用户操作触发的跳转会有确认提示。所以 9.2 点击 link 时，跳转 App Store 的事件因为没有被 block 所以会直接跳转（区别于 9.1 及以前因为被 block 所以不会跳转）。而直接触发的跳转（比如 onload）因为 App Store 的确认提示被前一个用 app 打开的提示 block 了，所以虽然和之前 work 的原理（blocking JS）不一样，但至少是部分 work 的。</p>
<h3 id="2">问题 2</h3>
<p>这曾经是个老大难的问题，受系统所限，在 iOS 上很难追踪到一个安装的来源，但是这样的需求又很多，主要的场景有：</p>
<ul>
<li>追踪广告效果</li>
<li>追踪用户推荐 / 邀请链接</li>
<li>在 app 内保持网页浏览的上下文，如登录信息，购物车等</li>
</ul>
<p>对于这个问题，在 iOS 9 以前常见的做法是猜，没错，就是用猜的。在访问特定页面或点击特定链接的时候记录用户特征，如 IP，系统版本，手机型号，语言等等。然后在打开 app 的时候发送这些特征到服务器，查询一段时间内（如 1 小时内）有可以匹配的用户点击过的链接，然后处理这个链接。这样做的缺点很明显，因为是通过特征模糊匹配的，所以很容易匹配不到或匹配到错误的上下文。但是其实大部分第三方服务会从不同来源收集更多信息，所以这个准确率其实比想象中高很多，尤其是在打开了 IDFA 的情况下。</p>
<p>这个问题却在 iOS 9 引入&nbsp;<code>SFSafariViewController</code>&nbsp;以后得到了很好的解决，因为&nbsp;<code>SFSafariViewController</code>&nbsp;和 Safari 的 cookies 是互通的！所以理论上可以做到 100% 的 match。解决方案也很简单，本地生成一个&nbsp;<code>UUID</code>&nbsp;并通过一个隐藏的&nbsp;<code>SFSafariViewController</code>&nbsp;传回给 server，server 就可以把这个&nbsp;<code>UUID</code>&nbsp;跟之前的 session 对应起来，然后通过一般的 API call 查询更多跟这个 session 有关的信息。具体的 code 可以参考&nbsp;<a href="https://github.com/BranchMetrics/iOS-Deferred-Deep-Linking-SDK/blob/master/Branch-SDK/Branch-SDK/BNCStrongMatchHelper.m#L69" rel="nofollow" data-token="05929d7f3b2e48ab7706df9d277770b5">Branch SDK 的实现</a>。</p>
<h3 id="3">问题 3</h3>
<p>上个章节已经提到，不再赘述，只是处理 URL 的入口换成了某个 API 请求的 callback 里。</p>
<h2 id="branchsdk">Branch SDK</h2>
<p>有很多第三方提供了 deep linking 和 deferred deep linking 的服务，比如&nbsp;<a href="https://www.appsflyer.com/" rel="nofollow" data-token="1e4cf2a4b4084cf244952000a86740d7">AppsFlyer</a>&nbsp;和&nbsp;<a href="https://bnc.lt/m/ZMP20tqkKp" rel="nofollow" data-token="fc5b8e4cfec7d76e18eea29ab951862c">Branch</a>。目前在 Glow 的 app 里这两个 SDK 都有用到。</p>
<p>其中 AppsFlyer 的优势在于他们跟很多公司有合作关系，比如 Facebook，所以用于追踪 Facebook 广告效果表现较好。另外 AppsFlyer 支持很多第三方服务的 server callback，可以方便集成很多第三方服务。缺点是 AppsFlyer 按 non-organic install 量收费。而且 AppsFlyer 的 SDK 和 API doc 写的不是很好，在 track 安装以后的后续 deep link 的时候感觉有很多 bug。</p>
<p><a href="https://bnc.lt/m/ZMP20tqkKp" rel="nofollow" data-token="fc5b8e4cfec7d76e18eea29ab951862c">Branch</a>&nbsp;的优势在于免费，SDK 和 API doc 都写的比较好，而且有一些特殊的功能比如用户邀请及奖励之类的，适合做一些运营活动。另外 Branch 可以实现一个 link 根据平台自动跳转不同 Store，甚至可以在 desktop 上通过短信发送可以追踪的链接。缺点是 Branch 运营时间不久，服务稳定性有待验证，dashboard 的功能也还比较轻量。</p>
<p>总的来说 AppsFlyer 更适合 track 广告效果，Branch 更适合实现 feature。必须一提的是，因为这两个服务都是主要面向海外市场的，所以曾经都遇到过国内短暂抽风的现象，所以国内的 app 如果要用的话风险自担 <img src="https://s.w.org/images/core/emoji/12.0.0-1/72x72/1f642.png" alt="🙂" class="wp-smiley" style="height: 1em; max-height: 1em;" /> 如果国内有类似的服务的话也欢迎留言补充。</p>
<p>Branch 的集成比较简单，参见<a href="https://dev.branch.io/recipes/add_the_sdk/" rel="nofollow" data-token="82f74a84468672295871dff7c6848676">官方文档</a>。一个需要注意的是，自己实现的时候在 handle URL 或者 user activity 的时候可以直接处理 URL，但是用 Branch 的时候，第一级的 URL 是 Branch 的 URL，所以要通过&nbsp;<code>[[Branch getInstance] handleDeepLink:url]</code>&nbsp;和 / 或&nbsp;<code>[[Branch getInstance] continueUserActivity:userActivity]</code>&nbsp;交由 Branch 处理，然后在 init Branch 时传入的 block (closure) 中处理<a href="https://dev.branch.io/recipes/add_the_sdk/#branch-provided-data-parameters-in-callback" rel="nofollow" data-token="33ccf825214ea8dc9514514c8de12bdd">各类参数</a>：</p>
<pre class="has">
<code>[branch initSessionWithLaunchOptions:launchOptions andRegisterDeepLinkHandler:^(NSDictionary *params, NSError *error) {
    if (!error) {
        // params are the deep linked params associated with the link that the user clicked -&gt; was re-directed to this app
        // params will be empty if no data found
        // ... insert custom logic here ...
        NSLog(@"params: %@", params.description);
    }
}];
</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>《Learning Deep Structured Semantic Models for Web Search using Clickthrough Data 》论文总结</title>
		<link>https://uzzz.org/article/1578.html</link>
				<pubDate>Tue, 12 Mar 2019 14:14:10 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[统计搜索]]></category>
		<category><![CDATA[论文]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1578.html</guid>
				<description><![CDATA[1.背景 DSSM是Deep Structured Semantic Model的缩写，即我们通常说的基于深度网络的语义模型，其核心思想是将query和doc映射到到共同维度的语义空间中，通过最大化query和doc语义向量之间的余弦相似度，从而训练得到隐含语义模型，达到检索的目的。DSSM有很广泛的应用，比如：搜索引擎检索，广告相关性，问答系统，机器翻译等。 2. DSSM 2.1简介 DSSM [1]（Deep Structured Semantic Models）的原理很简单，通过搜索引擎里 Query 和 Title 的海量的点击曝光日志，用 DNN 把 Query 和 Title 表达为低纬语义向量，并通过 cosine 距离来计算两个语义向量的距离，最终训练出语义相似度模型。该模型既可以用来预测两个句子的语义相似度，又可以获得某句子的低纬语义向量表达。 DSSM 从下往上可以分为三层结构：输入层、表示层、匹配层 典型的DNN结构是将原始的文本特征映射为在语义空间上表示的特征。DNN在搜索引擎排序中主要是有下面2个作用： 将query中term的高维向量映射为低维语义向量 根据语义向量计算query与doc之间的相关性分数 通常， x用来表示输入的term向量， y表示输出向量， l_{i}，i=1,&#8230;,N-1 表示隐藏层， Wi表示第 i层的参数矩 阵， bi表示 第 i个偏置项。 我们使用 tanh作为输出层和隐藏层的激活函数，有下列公式。 在搜索排序中，我们使用 Q来表示一个query， D来表示一个doc，那么他们的相关性分数可以用下面的公式衡量： 其中， yQ与 yD是query与doc的语义向量。在搜索引擎中，给定一个query，会返回一些按照相关性分数排序的文档。 通常情况下，输入的term向量使用最原始的bag of words特征，通过one-hot进行编码。但是在实际场景中，词典的大小将会非常大，如果直接将该数据输入给DNN，神经网络是无法进行训练和预测的。因此，在DSSM中引入了word hashing的方法，并且作为DNN中的第一层。 2.2 word hashing word hashing方法是用来减少输入向量的维度，该方法基于字母的 -gram。给定一个单词（good），我们首先增加词的开始和结束部分（#good#），然后将该词转换为字母 -gram的形式（假设为trigrams：#go，goo，ood，od#）。最后该词使用字母&#160; -gram的向量来表示。 这种方法的问题在于有可能造成冲突，因为两个不同的词可能有相同的 -gram向量来表示。下图显示了word hashing在2个词典中的统计。与原始的ont-hot向量表示的词典大小相比，word hashing明显降低了向量表示的维度。 2.3 DSSM的学习 点击日志里通常包含了用户搜索的query和用户点击的doc，可以假定如果用户在当前query下对doc进行了点击，则该query与doc是相关的。通过该规则，可以通过点击日志构造训练集与测试集。 首先，通过softmax 函数可以把query 与样本 doc 的语义相似性转化为一个后验概率： 其中 gamma是一个softmax函数的平滑因子， D表示被排序的候选文档集合，在实际中，对于正样本，每一个（query， 点击doc）对，使用 (Q, D^{+}) 表示；对于负样本，随机选择4个曝光但未点击的doc。 在训练阶段，通过极大似然估计来最小化损失函数： 其中 表示神经网络的参数。模型通过随机梯度下降（SGD）来进行优化，最终可以得到各网络层的参数 。 &#160; 3.总结 DSSM的提出主要有下面的优点： 解决了LSA、LDA、Autoencoder等方法存在的一个最大的问题：字典爆炸（导致计算复杂度非常高），因为在英文单词中，词的数量可能是没有限制的，但是字母 -gram的数量通常是有限的 基于词的特征表示比较难处理新词，字母的 -gram可以有效表示，鲁棒性较强 使用有监督方法，优化语义embedding的映射问题 省去了人工的特征工程 传统的输入层是用 Embedding 的方式（如 Word2Vec 的词向量）或者主题模型的方式（如 LDA 的主题向量）来直接做词的映射，再把各个词的向量累加或者拼接起来，由于 Word2Vec 和 LDA 都是无监督的训练，这样会给整个模型引入误差，DSSM 采用统一的有监督训练，不需要在中间过程做无监督模型的映射，因此精准度会比较高。 缺点： word hashing可能造成冲突 DSSM采用了词袋模型，损失了上下文信息 在排序中，搜索引擎的排序由多种因素决定，由于用户点击时doc的排名越靠前，点击的概率就越大，如果仅仅用点击来判断是否为正负样本，噪声比较大，难以收敛(DSSM 是弱监督模型) DSSM 是端到端的模型，虽然省去了人工特征转化、特征工程和特征组合，但端到端的模型有个问题就是效果不可控。 对于中文而言，处理方式与英文有很多不一样的地方。中文往往需要进行分词，但是我们可以仿照英文的处理方式，将中文的最小粒度看作是单字（在某些文献里看到过用偏旁部首，笔画，拼音等方法）。因此，通过这种word hashing方式，可以将向量空间大大降低。 &#160; &#160; &#160; &#160; &#160; &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h2><strong>1.背景</strong></h2>
<p>DSSM是Deep Structured Semantic Model的缩写，即我们通常说的基于深度网络的语义模型，其核心思想是将query和doc映射到到共同维度的语义空间中，通过最大化query和doc语义向量之间的余弦相似度，从而训练得到隐含语义模型，达到检索的目的。DSSM有很广泛的应用，比如：搜索引擎检索，广告相关性，问答系统，机器翻译等。</p>
<h2><a name="t3"></a>2. DSSM</h2>
<p><strong>2.1简介</strong></p>
<p>DSSM [1]（Deep Structured Semantic Models）的原理很简单，通过搜索引擎里 Query 和 Title 的海量的点击曝光日志，用 DNN 把 Query 和 Title 表达为低纬语义向量，并通过 cosine 距离来计算两个语义向量的距离，最终训练出语义相似度模型。该模型既可以用来预测两个句子的语义相似度，又可以获得某句子的低纬语义向量表达。</p>
<p>DSSM 从下往上可以分为三层结构：输入层、表示层、匹配层</p>
<p><img alt="" class="has" src="https://blog-10039692.file.myqcloud.com/1501555296606_1048_1501555297548.png"></p>
<p>典型的DNN结构是将原始的文本特征映射为在语义空间上表示的特征。DNN在搜索引擎排序中主要是有下面2个作用：</p>
<ol>
<li>将query中term的高维向量映射为低维语义向量</li>
<li>根据语义向量计算query与doc之间的相关性分数</li>
</ol>
<p>通常， x用来表示输入的term向量， y表示输出向量， l_{i}，i=1,&#8230;,N-1 表示隐藏层， Wi表示第 i层的参数矩</p>
<p>阵， bi表示 第 i个偏置项。</p>
<p><img alt="" class="has" height="131" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019031221392816.png" width="425"></p>
<p>我们使用 tanh作为输出层和隐藏层的激活函数，有下列公式。</p>
<p><img alt="" class="has" height="72" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312214010171.png" width="186"></p>
<p>在搜索排序中，我们使用 Q来表示一个query， D来表示一个doc，那么他们的相关性分数可以用下面的公式衡量：</p>
<p><img alt="" class="has" height="86" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312214109619.png" width="436"></p>
<p>其中， yQ与 yD是query与doc的语义向量。在搜索引擎中，给定一个query，会返回一些按照相关性分数排序的文档。</p>
<p>通常情况下，输入的term向量使用最原始的bag of words特征，通过one-hot进行编码。但是在实际场景中，词典的大小将会非常大，如果直接将该数据输入给DNN，神经网络是无法进行训练和预测的。因此，在DSSM中引入了word hashing的方法，并且作为DNN中的第一层。</p>
<p><strong>2.2 word hashing</strong></p>
<p>word hashing方法是用来减少输入向量的维度，该方法基于字母的 <img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram。给定一个单词（good），我们首先增加词的开始和结束部分（#good#），然后将该词转换为字母 <img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram的形式（假设为trigrams：#go，goo，ood，od#）。最后该词使用字母&nbsp; <img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram的向量来表示。</p>
<p>这种方法的问题在于有可能造成冲突，因为两个不同的词可能有相同的<img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram向量来表示。下图显示了word hashing在2个词典中的统计。与原始的ont-hot向量表示的词典大小相比，word hashing明显降低了向量表示的维度。</p>
<p><img alt="" class="has" height="203" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312214630343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODUyNjMwNg==,size_16,color_FFFFFF,t_70" width="637"></p>
<p><strong>2.3 DSSM的学习</strong></p>
<p>点击日志里通常包含了用户搜索的query和用户点击的doc，可以假定如果用户在当前query下对doc进行了点击，则该query与doc是相关的。通过该规则，可以通过点击日志构造训练集与测试集。</p>
<p>首先，通过softmax 函数可以把query 与样本 doc 的语义相似性转化为一个后验概率：</p>
<p><img alt="" class="has" height="83" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312214822961.png" width="450"></p>
<p>其中 gamma是一个softmax函数的平滑因子， D表示被排序的候选文档集合，在实际中，对于正样本，每一个（query， 点击doc）对，使用 (Q, D^{+}) 表示；对于负样本，随机选择4个曝光但未点击的doc。</p>
<p>在训练阶段，通过极大似然估计来最小化损失函数：</p>
<p><img alt="" class="has" height="88" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312215302794.png" width="315"></p>
<p>其中 <img alt="" class="has" height="30" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312215352600.png" width="20">表示神经网络的参数。模型通过随机梯度下降（SGD）来进行优化，最终可以得到各网络层的参数 <img alt="" class="has" height="25" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190312215414301.png" width="50">。</p>
<p>&nbsp;</p>
<h2><strong>3.总结</strong></h2>
<p>DSSM的提出主要有下面的优点：</p>
<ul>
<li>解决了LSA、LDA、Autoencoder等方法存在的一个最大的问题：字典爆炸（导致计算复杂度非常高），因为在英文单词中，词的数量可能是没有限制的，但是字母 <img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram的数量通常是有限的</li>
<li>基于词的特征表示比较难处理新词，字母的 <img alt="n" class="has" src="http://www.zhihu.com/equation?tex=n"> -gram可以有效表示，鲁棒性较强</li>
<li>使用有监督方法，优化语义embedding的映射问题</li>
<li>省去了人工的特征工程</li>
<li>传统的输入层是用 Embedding 的方式（如 Word2Vec 的词向量）或者主题模型的方式（如 LDA 的主题向量）来直接做词的映射，再把各个词的向量累加或者拼接起来，由于 Word2Vec 和 LDA 都是无监督的训练，这样会给整个模型引入误差，DSSM 采用统一的有监督训练，不需要在中间过程做无监督模型的映射，因此精准度会比较高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>word hashing可能造成冲突</li>
<li>DSSM采用了词袋模型，损失了上下文信息</li>
<li>在排序中，搜索引擎的排序由多种因素决定，由于用户点击时doc的排名越靠前，点击的概率就越大，如果仅仅用点击来判断是否为正负样本，噪声比较大，难以收敛(DSSM 是弱监督模型)</li>
<li>DSSM 是端到端的模型，虽然省去了人工特征转化、特征工程和特征组合，但端到端的模型有个问题就是效果不可控。</li>
</ul>
<p>对于中文而言，处理方式与英文有很多不一样的地方。中文往往需要进行分词，但是我们可以仿照英文的处理方式，将中文的最小粒度看作是单字（在某些文献里看到过用偏旁部首，笔画，拼音等方法）。因此，通过这种word hashing方式，可以将向量空间大大降低。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>leaflet地图概念框架图</title>
		<link>https://uzzz.org/article/2918.html</link>
				<pubDate>Tue, 26 Feb 2019 08:44:40 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2918.html</guid>
				<description><![CDATA[很多计算机接触地图开发的时候觉得很苦恼各种概念，leaflet官网的关系图已经写得很清楚了 各人经过理解后再次精简，写一些通俗易懂的话以供初学者理解。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>很多计算机接触地图开发的时候觉得很苦恼各种概念，leaflet官网的关系图已经写得很清楚了</p>
<p>各人经过理解后再次精简，写一些通俗易懂的话以供初学者理解。</p>
<p><img alt="" class="has" height="803" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190226164429887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0E4NzMwNTQyNjc=,size_16,color_FFFFFF,t_70" width="1106"></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>面对大量的用户数据泄露事件，普通用户该如何保护个人的网络信息安全？</title>
		<link>https://uzzz.org/article/2246.html</link>
				<pubDate>Tue, 11 Sep 2018 13:49:52 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[前端]]></category>
		<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2246.html</guid>
				<description><![CDATA[我们经常会在新闻里看到或听到关于用户数据泄露的事件，这些用户数据的泄露会对网站或服务的使用者产生非常严重的安全威胁。作为一个网络用户，您对用户数据泄露的严重程度和这些用户数据泄露事件背后的具体细节，又了解多少呢？ 谈到数据泄露，就不得不介绍一下与之相关的几个常用的黑客术语。在与数据泄露事件相关的报道中，经常可以听到拖库，洗库和撞库这几个词。拖库指的是黑客入侵有价值的网站，把注册用户的资料数据库全部盗走的行为。洗库是指在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现。撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户信息列表。由于很多用户习惯在不同网站使用相同的帐号密码，因此黑客可以通过获取用户在A网站的账户信息去尝试登录B网址，这就可以理解为撞库攻击。 黑客获取用户数据的手段（拖库/data breaches） 黑客获取用户数据的手段主要分为社工手段和技术手段。社工手段主要是利用人的心理学特点，通过欺骗或冒充等手段获取信息，比如利用邮件、钓鱼网站等手段获取用户信息。技术手段则是指利用系统本身的漏洞直接侵入目标系统获取用户信息。在实际攻击过程中，黑客往往会混合使用这两种方法。 为了说明拖库，洗库和撞库这三者之间的关系，以下选用了启明星辰安星web 安全运维团队在总结2011大规模数据泄露研究报告中的一张图。这张图非常清楚地说明了这三个环节之间的相互关系。 那么，到底目前网络用户信息泄露问题有多严重呢？ 在国内，2016年以前有一个专门曝光用户数据泄露事件的网站叫乌云网。如果留意看新闻的人应该还记得，在2016年之前经常有关于在乌云网上报出的用户数据泄露事件。乌云网曾经曝光的携程支付漏洞和12306网站用户数据泄露事件，目前在百度百科上还可以搜到。但这个由“白帽子们”发起的可以用来衡量网络安全程度的安全问题曝光网站，在2016年被强制关闭了。对于这一事件的评价有着非常极端的两面性，赞同关闭的人认为数据泄露事件曝光后，会有更多的黑客利用被曝光的漏洞进行攻击。反对的人则认为，没有这样的网站，服务提供商不会那么重视网络服务的安全，在提供更多服务的同时，会产生更多的系统漏洞，从而会给网络用户带来更多的危险。但不管怎样，乌云网被关闭的事件说明，黑客使用技术手段大量获取用户资料不是偶发事件，而几乎是网络安全的常态。 当失去乌云网后，网络用户是否真的无法知道当前的用户数据泄露问题有多严重了呢？ 其实不然，在这方面比乌云网更出名的类似网站还有”Have I been Pwned?”（HIBP）。2013年底，网络安全专家Troy Hunt意识到当时的用户数据泄露已经达到了无法控制的地步，所以他决定与其让黑客独享这些数据，不如把所能获取到的数据制作成可以搜索的数据库，让普通用户也可以很容易地知道自己的资料是否已经泄露了。如果您还没有听说过这个网站，建议您可以去这个网站上检查一下自己账号的安全性。HIBP网站的网址是：https://haveibeenpwned.com。如下图HIBP网首页站所显示，到目前为止HIBP所记录的被泄露的用户数已高达50多亿。 除了可以自行去HIBP网站查找自己的用户名和密码是否被泄露以外，目前很多网络服务其实也在使用HIBP的数据来帮助用户提高账号的安全程度。比如，作者本人就曾在登陆GitHub时收到过下图所示的警告信息。 这个警告信息是说，您的账号目前已经可以在HIBP的数据库中找到了，建议更改和使用更高强度的密码。 当您去HIBP中查找后，若发现资料已被泄露，HIBP还能很贴心地告诉您，您的资料是在哪次数据泄露事件中被搜集的，您的什么资料可以在HIBP数据库中找到，如下图所示。 用户数据的利用（洗库） 前面我们谈到的是用户数据是如何被泄露的，以及目前用户数据的泄露问题有多严重。那么，当黑客获取到某个网站的用户数据后，这些数据是如何被利用的呢？基本上，被盗取的数据分成两部分：第一部分是以明文形式存储的用户信息，比如，姓名、电话号码、邮件地址等，更严重的可能还包括身份证号码、信用卡、银行账号等敏感信息。黑客可以把这些信息打包出售给不同的非法使用者。第二部分就是加密过的用户密码。为了最大程度地保护用户信息安全，大多数网站一般都是采用加密方式来存储用户密码，而不是明文存储。前面提到的HIBP网站上已泄露的用户密码就是存储的密码Hash值而不是明文。如果您想了解更多关于Hash算法的介绍，可以参考另一篇文章网络信息安全领域中常见的几个概念。黑客需要破解经Hash算法加密后的密码才能使用这一部分数据。用于破解密码Hash值的主要方法是碰撞攻击（Collision attack），维基百科上对Collision attack有非常详细的介绍。当黑客利用Collision attack将破解了的用户密码和用户名配对制成一张表格后，黑客就可以利用这张表来进行第二轮攻击了。 用户数据的再次利用（撞库） 如果不考虑社工手段，黑客使用技术手段获取的用户数据，主要是利用系统漏洞攻击那些防护措施薄弱的网站所得到的。当黑客把用户数据整理成一张可以再次使用的表格时，非常多的网站都可能被攻陷了。这主要是由于用户往往会使用同样的用户名和密码来注册不同的网络服务，这样黑客就可以利用已知的用户信息来获取其他网站同一用户的资料。这也就是为什么很多的用户数据泄露是通过撞库攻击所得到的。 如何保护自己的网络信息安全 所谓道高一尺，魔高一丈。网络上的攻防战争是永远没有结束那一天的。信息安全是服务提供方和用户本身双方的责任。做为网络用户，我们应该怎么办？其实，有很多方法是可以提高网络信息安全水平的，但讲多了，大多数人无法做到。这里只提最重要的三点供参考： 1. 不要使用同一用户名和密码来注册所有的网络服务。这无疑是最不安全的做法； 2. 提高密码的复杂程度。建议使用8位以上，数字、字母和符号的组合密码； 3. 对于重要的账号开启多重验证方法，如密码加短信，密码加OTP验证等。 以上第一、第二点，相信大家已经听过无数遍了。如果做到这两点，就会极大程度地增加黑客的工作量。要知道，黑客的时间也是很宝贵的，当您的防范措施比其他人复杂得多时，黑客可能就会选择放弃，而去尝试下一条数据了。 对于第三点多重验证，这本来是用于对安全性要求很高的网络服务所提供的安全措施，但随着用户数据泄露问题越来越严重，多重验证也逐渐被主流的网络服务所采用了。 什么是多重验证？多重验证是指，当用户在使用网络服务时，需要通过两种以上的认证机制之后才可以使用网络服务。这里讲的认证机制是指相互独立的验证手段。比如，当用户输入了用户名和密码后，系统提示还需要输入短信验证码。通常，当用户在陌生或新设备上登陆账户时，系统就会要求两种以上的认证机制。多重验证能更有效地保护用户账号安全。 多重验证根据复杂程度可以分成很多种，比如安全性最高的基于不对称加密算法的U盾，被广泛应用在银行业中。在一般的多重验证手段中，更常用的是邮件、短信、密码器、软件密码器或基于常用设备的应用推送等。这些常用的验证手段多数是基于一次性密码（OTP）的验证方法。随着国内互联网行业的飞速发展，一些具有创新性的多重验证方法也逐渐在国内流行开来。比如基于常用设备的二维码识别，这本来是微信和支付宝率先使用的验证和支付手段，目前很多国内银行的网银登陆也开始支持二维码扫描登陆了。除了二维码外，比较特别的验证方法还有，微信支持声纹验证，支付宝和百度支持面部识别等。由于多重验证方法种类繁多，无法逐一介绍，下表例举了一些常用网络服务所支持的多重验证方法供参考。 随着多重验证的使用和用户账号管理的复杂程度越来越高，国内的领先互联网服务提供商开始使用一站式的安全应用来专门用作账户管理。其中具有代表性的有QQ安全中心、百度账号管家和网易账号管家等。这些应用通常要求用户将应用与常用设备绑定，然后通过绑定后的应用来管理用户的账户设置。这样的一站式应用可以提供更多元的账户管理功能，比如账户功能的开启和关闭，被盗账号的找回等等。 现在，您一定对互联网账户的安全有了进一步的了解。是否很想去HIBP网站上查一下自己的资料有没有被泄露？如果在HIBP的数据库里能查找到您的账号，以上提及的三点就是您必须要立即采取的防范措施，否则理论上说，所有人都可能通过HIBP找到您的用户名和密码，登录您的账号了。 PassXYZ是一款跨平台的密码管理软件，可以运行在安卓和苹果手机以及Windows 10上。 PassXYZ基于著名的开源软件KeePass开发，所以兼容KeePass数据格式。PassXYZ的核心代码可以在开源社区GitHub上获取。PassXYZ最大的特点是通过提供大量的个人信息记录模板来分享和传递良好的使用习惯。PassXYZ个人信息管理软件和PassXYZ公众号的目标是通过两者的结合来推动和提高公众的个人信息管理水平。 您可以通过苹果应用商店，微软应用商店，Google Play和华为应用商店搜索关键字PassXYZ来下载该应用。如果您想获得更多模板或对个人信息安全及管理有兴趣，可以搜索关键字PassXYZ关注公众号。您也可以通过微信号passxyz_kpclib来添加此公众号。PassXYZ公众号专注于个人信息安全及管理的相关知识。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<p>我们经常会在新闻里看到或听到关于用户数据泄露的事件，这些用户数据的泄露会对网站或服务的使用者产生非常严重的安全威胁。作为一个网络用户，您对用户数据泄露的严重程度和这些用户数据泄露事件背后的具体细节，又了解多少呢？</p>
<p>谈到数据泄露，就不得不介绍一下与之相关的几个常用的黑客术语。在与数据泄露事件相关的报道中，经常可以听到<strong>拖库</strong>，<strong>洗库</strong>和<strong>撞库</strong>这几个词。<strong>拖库</strong>指的是黑客入侵有价值的网站，把注册用户的资料数据库全部盗走的行为。<strong>洗库</strong>是指在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现。<strong>撞库</strong>是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户信息列表。由于很多用户习惯在不同网站使用相同的帐号密码，因此黑客可以通过获取用户在A网站的账户信息去尝试登录B网址，这就可以理解为撞库攻击。</p>
<h2 id="黑客获取用户数据的手段拖库data-breaches">黑客获取用户数据的手段（拖库/data breaches）</h2>
<p>黑客获取用户数据的手段主要分为社工手段和技术手段。社工手段主要是利用人的心理学特点，通过欺骗或冒充等手段获取信息，比如利用邮件、钓鱼网站等手段获取用户信息。技术手段则是指利用系统本身的漏洞直接侵入目标系统获取用户信息。在实际攻击过程中，黑客往往会混合使用这两种方法。 <br /> 为了说明拖库，洗库和撞库这三者之间的关系，以下选用了启明星辰安星web 安全运维团队在总结2011大规模数据泄露研究报告中的一张图。这张图非常清楚地说明了这三个环节之间的相互关系。</p>
<p><img src="https://passxyz.github.io/images/PxCollisionAttack/flowchart01.png" alt="flowchart01" title=""></p>
<p>那么，到底目前网络用户信息泄露问题有多严重呢？</p>
<p>在国内，2016年以前有一个专门曝光用户数据泄露事件的网站叫乌云网。如果留意看新闻的人应该还记得，在2016年之前经常有关于在乌云网上报出的用户数据泄露事件。乌云网曾经曝光的携程支付漏洞和12306网站用户数据泄露事件，目前在百度百科上还可以搜到。但这个由“白帽子们”发起的可以用来衡量网络安全程度的安全问题曝光网站，在2016年被强制关闭了。对于这一事件的评价有着非常极端的两面性，赞同关闭的人认为数据泄露事件曝光后，会有更多的黑客利用被曝光的漏洞进行攻击。反对的人则认为，没有这样的网站，服务提供商不会那么重视网络服务的安全，在提供更多服务的同时，会产生更多的系统漏洞，从而会给网络用户带来更多的危险。但不管怎样，乌云网被关闭的事件说明，黑客使用技术手段大量获取用户资料不是偶发事件，而几乎是网络安全的常态。</p>
<p>当失去乌云网后，网络用户是否真的无法知道当前的用户数据泄露问题有多严重了呢？</p>
<p>其实不然，在这方面比乌云网更出名的类似网站还有”Have I been Pwned?”（HIBP）。2013年底，网络安全专家Troy Hunt意识到当时的用户数据泄露已经达到了无法控制的地步，所以他决定与其让黑客独享这些数据，不如把所能获取到的数据制作成可以搜索的数据库，让普通用户也可以很容易地知道自己的资料是否已经泄露了。如果您还没有听说过这个网站，建议您可以去这个网站上检查一下自己账号的安全性。HIBP网站的网址是：<a href="https://haveibeenpwned.com/" rel="nofollow" data-token="185953c7815ffd21aa08ba931e17cff8">https://haveibeenpwned.com</a>。如下图HIBP网首页站所显示，到目前为止HIBP所记录的被泄露的用户数已高达50多亿。</p>
<p><img src="https://passxyz.github.io/images/PxCollisionAttack/hibp01.png" alt="hibp01" title=""></p>
<p>除了可以自行去HIBP网站查找自己的用户名和密码是否被泄露以外，目前很多网络服务其实也在使用HIBP的数据来帮助用户提高账号的安全程度。比如，作者本人就曾在登陆GitHub时收到过下图所示的警告信息。</p>
<p><img src="https://passxyz.github.io/images/PxCollisionAttack/github01.png" alt="github01" title=""></p>
<p>这个警告信息是说，您的账号目前已经可以在HIBP的数据库中找到了，建议更改和使用更高强度的密码。 <br /> 当您去HIBP中查找后，若发现资料已被泄露，HIBP还能很贴心地告诉您，您的资料是在哪次数据泄露事件中被搜集的，您的什么资料可以在HIBP数据库中找到，如下图所示。</p>
<p><img src="https://passxyz.github.io/images/PxCollisionAttack/hibp02.png" alt="hibp02" title=""> </p>
<h2 id="用户数据的利用洗库">用户数据的利用（洗库）</h2>
<p>前面我们谈到的是用户数据是如何被泄露的，以及目前用户数据的泄露问题有多严重。那么，当黑客获取到某个网站的用户数据后，这些数据是如何被利用的呢？基本上，被盗取的数据分成两部分：第一部分是以明文形式存储的用户信息，比如，姓名、电话号码、邮件地址等，更严重的可能还包括身份证号码、信用卡、银行账号等敏感信息。黑客可以把这些信息打包出售给不同的非法使用者。第二部分就是加密过的用户密码。为了最大程度地保护用户信息安全，大多数网站一般都是采用加密方式来存储用户密码，而不是明文存储。前面提到的HIBP网站上已泄露的用户密码就是存储的密码Hash值而不是明文。如果您想了解更多关于Hash算法的介绍，可以参考另一篇文章<a href="https://blog.csdn.net/qq_29953771/article/details/81293142" rel="nofollow" data-token="8c6eae7ae89e5203d9f0cbc6a5495f02">网络信息安全领域中常见的几个概念</a>。黑客需要破解经Hash算法加密后的密码才能使用这一部分数据。用于破解密码Hash值的主要方法是碰撞攻击（Collision attack），维基百科上对Collision attack有非常详细的介绍。当黑客利用Collision attack将破解了的用户密码和用户名配对制成一张表格后，黑客就可以利用这张表来进行第二轮攻击了。</p>
<h2 id="用户数据的再次利用撞库">用户数据的再次利用（撞库）</h2>
<p>如果不考虑社工手段，黑客使用技术手段获取的用户数据，主要是利用系统漏洞攻击那些防护措施薄弱的网站所得到的。当黑客把用户数据整理成一张可以再次使用的表格时，非常多的网站都可能被攻陷了。这主要是由于用户往往会使用同样的用户名和密码来注册不同的网络服务，这样黑客就可以利用已知的用户信息来获取其他网站同一用户的资料。这也就是为什么很多的用户数据泄露是通过撞库攻击所得到的。</p>
<h2 id="如何保护自己的网络信息安全">如何保护自己的网络信息安全</h2>
<p>所谓道高一尺，魔高一丈。网络上的攻防战争是永远没有结束那一天的。信息安全是服务提供方和用户本身双方的责任。做为网络用户，我们应该怎么办？其实，有很多方法是可以提高网络信息安全水平的，但讲多了，大多数人无法做到。这里只提最重要的三点供参考： <br /> 1. 不要使用同一用户名和密码来注册所有的网络服务。这无疑是最不安全的做法； <br /> 2. 提高密码的复杂程度。建议使用8位以上，数字、字母和符号的组合密码； <br /> 3. 对于重要的账号开启多重验证方法，如密码加短信，密码加OTP验证等。</p>
<p>以上第一、第二点，相信大家已经听过无数遍了。如果做到这两点，就会极大程度地增加黑客的工作量。要知道，黑客的时间也是很宝贵的，当您的防范措施比其他人复杂得多时，黑客可能就会选择放弃，而去尝试下一条数据了。</p>
<p>对于第三点多重验证，这本来是用于对安全性要求很高的网络服务所提供的安全措施，但随着用户数据泄露问题越来越严重，多重验证也逐渐被主流的网络服务所采用了。</p>
<p>什么是<strong>多重验证</strong>？多重验证是指，当用户在使用网络服务时，需要通过两种以上的认证机制之后才可以使用网络服务。这里讲的认证机制是指相互独立的验证手段。比如，当用户输入了用户名和密码后，系统提示还需要输入短信验证码。通常，当用户在陌生或新设备上登陆账户时，系统就会要求两种以上的认证机制。多重验证能更有效地保护用户账号安全。</p>
<p>多重验证根据复杂程度可以分成很多种，比如安全性最高的基于不对称加密算法的U盾，被广泛应用在银行业中。在一般的多重验证手段中，更常用的是邮件、短信、密码器、软件密码器或基于常用设备的应用推送等。这些常用的验证手段多数是基于一次性密码（OTP）的验证方法。随着国内互联网行业的飞速发展，一些具有创新性的多重验证方法也逐渐在国内流行开来。比如基于常用设备的二维码识别，这本来是微信和支付宝率先使用的验证和支付手段，目前很多国内银行的网银登陆也开始支持二维码扫描登陆了。除了二维码外，比较特别的验证方法还有，微信支持声纹验证，支付宝和百度支持面部识别等。由于多重验证方法种类繁多，无法逐一介绍，下表例举了一些常用网络服务所支持的多重验证方法供参考。</p>
<p><img src="https://passxyz.github.io/images/PxCollisionAttack/mfa01.png" alt="mfa01" title=""> </p>
<p>随着多重验证的使用和用户账号管理的复杂程度越来越高，国内的领先互联网服务提供商开始使用一站式的安全应用来专门用作账户管理。其中具有代表性的有QQ安全中心、百度账号管家和网易账号管家等。这些应用通常要求用户将应用与常用设备绑定，然后通过绑定后的应用来管理用户的账户设置。这样的一站式应用可以提供更多元的账户管理功能，比如账户功能的开启和关闭，被盗账号的找回等等。 <br /> 现在，您一定对互联网账户的安全有了进一步的了解。是否很想去HIBP网站上查一下自己的资料有没有被泄露？如果在HIBP的数据库里能查找到您的账号，以上提及的三点就是您必须要立即采取的防范措施，否则理论上说，所有人都可能通过HIBP找到您的用户名和密码，登录您的账号了。</p>
<hr>
<p><a href="https://passxyz.github.io/" rel="nofollow" data-token="e7a2e751ea00413753f474ddc07f3ec7">PassXYZ</a>是一款跨平台的密码管理软件，可以运行在安卓和苹果手机以及Windows 10上。 <br /> PassXYZ基于著名的开源软件KeePass开发，所以兼容KeePass数据格式。PassXYZ的核心代码可以在开源社区GitHub上获取。PassXYZ最大的特点是通过提供大量的个人信息记录模板来分享和传递良好的使用习惯。PassXYZ个人信息管理软件和PassXYZ公众号的目标是通过两者的结合来推动和提高公众的个人信息管理水平。</p>
<p>您可以通过<a href="https://itunes.apple.com/us/app/passxyz/id1402887274?ls=1&amp;mt=8" rel="nofollow" data-token="5d3e110d66a33b91d646f2fb0d322f8c">苹果应用商店</a>，<a href="https://www.microsoft.com/store/apps/9P8GC4XP8NLB" rel="nofollow" data-token="b83b641f8b9a919d23ae3f498fffa1fe">微软应用商店</a>，<a href="https://play.google.com/store/apps/details?id=com.passxyz.PassXYZ" rel="nofollow" data-token="4ead375788494c3cff5a87287cf9c86c">Google Play</a>和<a href="http://app.hicloud.com/app/C100313505" rel="nofollow" data-token="ec0dec03997e9793bf2edd8bb47181f5">华为应用商店</a>搜索关键字PassXYZ来下载该应用。如果您想获得更多模板或对个人信息安全及管理有兴趣，可以搜索关键字PassXYZ关注公众号。您也可以通过微信号passxyz_kpclib来添加此公众号。PassXYZ公众号专注于个人信息安全及管理的相关知识。</p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>黑暗搜素引擎工具&#8212;shodan</title>
		<link>https://uzzz.org/article/2921.html</link>
				<pubDate>Tue, 14 Aug 2018 10:29:52 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[linux]]></category>
		<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2921.html</guid>
				<description><![CDATA[简介 shodan是互联网上最强大的一个搜索引擎工具，该工具不是在网上搜索网址，而是直接搜索服务器，相当于一款“黑暗”谷歌，一直不停的在寻找着所有和互联网连接的服务器、摄像头、打印机、路由器等。 官网：https://www.shodan.io/ 如搜索思科路由器 在该界面可以单击任何IP地址，直接找到该设备。 可以使用过滤器通过缩小搜索范围快速的查询需要的东西。 过滤器命令 -city和country命令(缩小搜索的地理位置） 表示从美国进行搜索 country:US 从孟菲斯城市搜索 city:Memphis 结合使用 country:US city：Memphis -hostname命令（通过指定主机名来扫描整个域名） 搜索google主机 hostname:google -net命令（扫描单个ip或一个网络范围） 扫描主机192.168.1.10 net：192.168.1.10 扫描192.168.1.0/24网络内所有主机 net：192.168.1.0/24 -title命令（搜索项目） 搜索服务器机房信息 title："Server Romm" -关键字搜索（如果知道目标系统使用得服务器类型或嵌入式服务器名，来搜索一个web页面也比较容易 搜索所有apache服务器正在运行得2.2.8版本，且仅搜索打开的站点 apache/2.2.8 200 ok 跳过显示401的非法页或302删除页 apache/2.2.8 -401 -302 -组合搜索 搜索在波士顿所有正在运行IIS/7.0的Microsoft服务器 IIS/7.0 hostname:YourCompany.com city:Boston 在某台主机中标题为camera的信息 Title:camera hostname:YourComany.com 使用坐标轴（经度33.5，纬度36.3）的形式搜索Linux操作系统 geo:33.5.36.3 os:Linux -其他搜索术语 通过端口号搜索 Port 通过操作系统搜索 OS 使用时间搜索服务 After或Before -使用Metasploit实现Shodan搜索 (1)在shodanhq.com网站注册一个免费的账户 (2)登录，获取API key。 (3)启动MSF终端 (4)选择auxiliary/gather/shodan_search模块 ，查看该模块下可配置的选项参数 &#62;use auxiliary/gather/shodan_search &#62;show options (5)配置QUERY和SHODAN_APIKEY选项参数 &#62;set SHODAN_APIKEY duV9vwgCmo0oDfWqfWafax8sj0ZUa5BU（你账户的APIkey） &#62;set QUERY iomega (6)启动搜索引擎 &#62;run]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<ul>
<li>简介 <br /> shodan是互联网上最强大的一个搜索引擎工具，该工具不是在网上搜索网址，而是直接搜索服务器，相当于一款“黑暗”谷歌，一直不停的在寻找着所有和互联网连接的服务器、摄像头、打印机、路由器等。 <br /> 官网：<a href="https://www.shodan.io/" rel="nofollow" data-token="62180080d7ded489d4f1475a9da62008">https://www.shodan.io/</a> <br /> <img title="" alt="这里写图片描述" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180814163420304?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzkxMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> <br /> 如搜索思科路由器 <br /> <img title="" alt="这里写图片描述" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180814163444912?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzkxMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> <br /> 在该界面可以单击任何IP地址，直接找到该设备。 <br /> 可以使用过滤器通过缩小搜索范围快速的查询需要的东西。</li>
<li>过滤器命令 <br /> -city和country命令(缩小搜索的地理位置）</li>
</ul>
<p>表示从美国进行搜索</p>
<blockquote>
<p>country:US </p>
</blockquote>
<p>从孟菲斯城市搜索</p>
<blockquote>
<p>city:Memphis</p>
</blockquote>
<p>结合使用</p>
<blockquote>
<p>country:US city：Memphis</p>
</blockquote>
<p>-hostname命令（通过指定主机名来扫描整个域名） <br /> 搜索google主机</p>
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">hostname</span><span class="hljs-pseudo">:google</span></code></pre>
<p>-net命令（扫描单个ip或一个网络范围） <br /> 扫描主机192.168.1.10</p>
<pre class="prettyprint"><code class=" hljs dos"><span class="hljs-winutils">net</span>：<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span></code></pre>
<p>扫描192.168.1.0/24网络内所有主机</p>
<pre class="prettyprint"><code class=" hljs dos"><span class="hljs-winutils">net</span>：<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span></code></pre>
<p>-title命令（搜索项目） <br /> 搜索服务器机房信息</p>
<pre class="prettyprint"><code class=" hljs bash">title：<span class="hljs-string">"Server Romm"</span></code></pre>
<p>-关键字搜索（如果知道目标系统使用得服务器类型或嵌入式服务器名，来搜索一个web页面也比较容易 <br /> 搜索所有apache服务器正在运行得2.2.8版本，且仅搜索打开的站点</p>
<pre class="prettyprint"><code class=" hljs erlang-repl"><span class="hljs-function_or_atom">apache</span>/<span class="hljs-number">2.2</span>.<span class="hljs-number">8</span> <span class="hljs-number">200</span> <span class="hljs-ok">ok</span></code></pre>
<p>跳过显示401的非法页或302删除页</p>
<pre class="prettyprint"><code class=" hljs ">apache/2.2.8 -401 -302</code></pre>
<p>-组合搜索 <br /> 搜索在波士顿所有正在运行IIS/7.0的Microsoft服务器</p>
<pre class="prettyprint"><code class=" hljs profile">IIS/<span class="hljs-number">7.0</span> hostname:<span class="hljs-filename">YourCompany.com city</span>:Boston</code></pre>
<p>在某台主机中标题为camera的信息</p>
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">Title</span><span class="hljs-pseudo">:camera</span> <span class="hljs-tag">hostname</span><span class="hljs-pseudo">:YourComany</span><span class="hljs-class">.com</span></code></pre>
<p>使用坐标轴（经度33.5，纬度36.3）的形式搜索Linux操作系统</p>
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">geo</span><span class="hljs-pseudo">:33</span><span class="hljs-class">.5</span><span class="hljs-class">.36</span><span class="hljs-class">.3</span> <span class="hljs-tag">os</span><span class="hljs-pseudo">:Linux</span></code></pre>
<p>-其他搜索术语 <br /> 通过端口号搜索</p>
<pre class="prettyprint"><code class=" hljs vhdl"><span class="hljs-keyword">Port</span></code></pre>
<p>通过操作系统搜索</p>
<pre class="prettyprint"><code class=" hljs ">OS</code></pre>
<p>使用时间搜索服务</p>
<pre class="prettyprint"><code class=" hljs mathematica"><span class="hljs-keyword">After</span>或<span class="hljs-keyword">Before</span></code></pre>
<p>-使用Metasploit实现Shodan搜索 <br /> (1)在shodanhq.com网站注册一个免费的账户 <br /> (2)登录，获取API key。 <br /> (3)启动MSF终端 <br /> <img title="" alt="这里写图片描述" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180815164210707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzkxMDAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"> <br /> (4)选择auxiliary/gather/shodan_search模块 ，查看该模块下可配置的选项参数</p>
<pre class="prettyprint"><code class=" hljs rust">&gt;<span class="hljs-keyword">use</span> auxiliary/gather/shodan_search
&gt;show options</code></pre>
<p>(5)配置QUERY和SHODAN_APIKEY选项参数</p>
<pre class="prettyprint"><code class=" hljs bash">&gt;<span class="hljs-keyword">set</span> SHODAN_APIKEY duV9vwgCmo0oDfWqfWafax8sj0ZUa5BU（你账户的APIkey）
&gt;<span class="hljs-keyword">set</span> QUERY iomega</code></pre>
<p>(6)启动搜索引擎</p>
<pre class="prettyprint"><code class=" hljs applescript">&gt;<span class="hljs-command">run</span></code></pre>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>ArcGIS教程之DEM(高程)的应用（坡度坡向、提等高线）</title>
		<link>https://uzzz.org/article/3286.html</link>
				<pubDate>Fri, 03 Aug 2018 08:56:19 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图像处理]]></category>
		<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3286.html</guid>
				<description><![CDATA[ArcGIS教程之DEM(高程)的应用（坡度坡向、提等高线） 发布时间：2018-01-17 版权： &#160; 相关教程： DEM水文分析（一） Arcgis下DEM水文分析（二） &#160;&#160;&#160;&#160;&#160;&#160; DEM的应用包括：坡度：Slope、坡向：Aspect、提取等高线、算地形表面的阴影图、可视性分析、地形剖面、水文分析等，其中涉及的知识点有： &#160;&#160;&#160; &#160;a)掌握根据DEM 计算坡度、坡向的方法。 &#160;&#160;&#160;&#160; b)理解基于DEM数据进行水文分析的基本原理。 &#160;&#160; &#160;&#160;c)利用ArcGIS的提供的水文分析工具进行水文分析的基本方法和步骤。 第一步：需要的工具 &#160;&#160;&#160;&#160;&#160; 1. BIGEMPA地图下载器（全能版已授权）&#160; 下载地址：http://download.bigemap.com/bmsetup.rar &#160;&#160;&#160;&#160;&#160; 2. Global Mapper 14.&#160;&#160;&#160;&#160;&#160;下载地址：Global&#160;Mapper 14.1汉化版.rar &#160;&#160;&#160;&#160;&#160; 3. ARCGIS下载地址：http://www.bigemap.com/helps/doc2018011754.html 第二步骤：通过BIGEMAP下载高程数据 &#160;&#160;&#160;&#160;&#160;&#160; 1. 启动BIGEMAP地图下载器软件，查看左上角是否显示【已授权：所有地图】，如果没有该显示，请联系我们的客服人员。如下图所示： &#160;&#160;&#160;&#160;&#160;&#160; 2. 选择左上角属性选项，选择【高程】，如下图： &#160;&#160; &#160; &#160; &#160; 3. 选在你要的区域，双击下载，如下图所示： &#160;&#160;&#160;&#160;&#160; 4. 选择下载的级别，建议尽量下载16级的，16级为最好级别。如果16级不能勾选，请选择下载小一点的范围，高程为矢量数据，超过20M大小，一般电脑都很难处理生成的等高线。下载之后的数据为tiff格式，实际为dem高程数据。 &#160;&#160;&#160;&#160;&#160;&#160;6. 启动安装好的Global Mapper软件，启动中文版在安装好的目录下有个chs或则chinese的启动图标，如下图所示： &#160;&#160;&#160; 7. 将下载好的高程数据（下载目录下的后缀为tiff格式）拖入到global mapper中，如下图所示： &#160; 修改下载的高程数据的投影为【UTM】 &#160;在Global mapper中选择：工具-&#62;设置，弹出对话框，如下： &#160;&#160;&#160;&#160;&#160; 然后另存为【DEM】格式，如下图： &#160;&#160;&#160;&#160;在弹出的对话框中选择【DEM】格式，如下图: &#160;&#160;&#160; &#160;&#160;&#160;点击【确定】，保存。 &#160;&#160;&#160;DEM应用之坡度：Slope &#160;&#160;&#160;打开ArcMap软件，选择添加按钮，将刚才保存的DEM文件打开，如下图： &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;在ArcMap中，需要打开【扩展模块】功能，如下图： &#160;&#160;&#160;&#160;&#160;弹出的对话框中勾选所有选项，如下图： &#160;&#160;&#160;&#160;&#160;&#160;点击【关闭】。 &#160;&#160;&#160;&#160; 2)&#160;在【ArcToolbox】中，执行命令[3D Analyst工具]——[栅格表面]——[坡度]， 如下图所示，指定各参数： &#160;&#160; 执行后，得到坡度栅格Slope_tingri1：坡度栅格中，栅格单元的值在[0 -82] 度间变化，如下图： &#160;&#160;右键点击图层[Slope_TinGrid]，执行[属性命令]，设置图层[符号系统]，重新调整坡度分级。将类别调整为5，点[分类]按钮，用手动分级法，将中断值调整为：8，15，25，35，90。 &#160;确定后，如下： 【下面计算剖面曲率】 &#160;&#160;&#160; 在【ArcToolbox】中，执行命令[3D Analyst工具]——[栅格表面]————[坡度]。按如下所示，指定各参数。得到剖面曲率栅格：[Slope _Slope]，如下图： &#160; &#160; &#160; &#160;&#160;&#160;&#160;DEM应用之坡向：Aspect &#160;&#160;&#160; 打开【ArcToolbox】，执行命令[3D Analyst工具]——[栅格表面]——[坡向]，按下图所示，指定各参数： 执行结果为（得到坡向栅格：[Aspect_tgrid]）： 【以下计算平面曲率】： 在【ArcToolbox】中，执行命令[3D Analyst工具]——&#62;[栅格表面]——&#62;[坡度]，按下图所示，指定各参数，按下图所示指定各参数： 执行后生成平面曲率栅格[Slope_Aspect]： DEM应用之提取等高线 &#160;加载DEM数据，如下图： &#160; 然后在【ArcToolbox】中，执行命令[3DAnalyst工具]——&#62;[栅格表面]——&#62;[等值线]，按下图所示指定各参数： 执行后生成等高线矢量图层：如下图： &#160;DEM应用之计算地形表面的阴影图 &#160;在【ArcToolbox】工具箱中，执行命令[3D Analyst工具]——&#62;[栅格表面]——&#62; [山体阴影]，按下图所示指定各参数： &#160;执行后生成地表阴影栅格，如下图： &#160; 下面进行【DEM渲染】： 关闭除[tingrid] 和 [Hillsha_ting]以外所有图层的显示，并将[tingrid ] 置于[Hillsha_ting] 之上，右键点击[tingrid] ，在出现的右键菜单中执行[属性]，在[图层属性]对话框中，参照下图所示设置[符号系统]选项页中颜色。如图： 在工具栏空白处右键，打开工具栏[效果]，如下图所示，设置栅格图层[tingrid]的透明度为：[45%]左右，结果如图： &#160; &#160; DEM应用之可视性分析 &#160; （一）【通视性分析】 数据使用上一步骤的结果！在上一步的基础上进行。 打开[3D Analyst] 工具栏，从工具栏选择[创建通视线](Line of sight)工具，如图： &#160; &#160;&#160;&#160; 在出现的[通视分析]对话框中输入[观察者偏移量]&#160;和&#160;[目标偏移量], 即距地面的距离，如图： 在地图显示区中从某点[A]沿不同方向绘制多条直线，可以得到观察点[A]到不同目标点的通视性： &#160; （二）【可视区分析：移动发射基站信号覆盖分析】 &#160; (1)在上一步基础上进行，在内容列表区[TOC]中关闭除[tingrid]之外的所有图层，加载移动基站数据－矢量图层：[移动基站.shp] （数据后边会提高给大家下载） (2)在【ArcToolbox】中，执行命令[3D Analyst工具]——&#62;[栅格表面]——&#62;[视域]，按下图所示指定各参数： (其中绿色表示现有发射基站信号已覆盖的区域，淡红色表示，无法接收到手机信号的区域) DEM应用之地形剖面 &#160; 本步骤同样是在上一步骤的结果下进行的： 在上一步基础上进行，打开[3D Analyst]工具栏，点击[线插值]工具，跟踪一条线段，这条线段可以从DEM:[TINGRID] 中得到高程值 点击[剖面图 ] 按钮，得到上一步所生成的3D线段的剖面图：]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h2><a href="http://www.bigemap.com/helps/doc2018011737.html" rel="nofollow" data-token="e73dd931689f79e8fc8a2003391e1abe">ArcGIS教程之DEM(高程)的应用（坡度坡向、提等高线）</a></h2>
<p>发布时间：2018-01-17 版权：</p>
<p>&nbsp;</p>
<p><strong>相关教程：</strong></p>
<p><a href="http://www.bigemap.com/helps/doc2018011738.html" rel="nofollow" data-token="ac30d2d3e1cfd204c8de0add22623040"><strong>DEM水文分析（一）</strong></a></p>
<p><a href="http://www.bigemap.com/helps/doc2018011739.html" rel="nofollow" data-token="dacbf17ce29475513e2decb300a0d8eb"><strong>Arcgis下DEM水文分析（二）</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEM的应用包括：坡度：Slope、坡向：Aspect、提取等高线、算地形表面的阴影图、可视性分析、地形剖面、水文分析等，其中涉及的知识点有：</p>
<p> &nbsp;&nbsp;&nbsp; &nbsp;a)掌握根据DEM 计算坡度、坡向的方法。<br /> &nbsp;&nbsp;&nbsp;&nbsp; b)理解基于DEM数据进行水文分析的基本原理。<br /> &nbsp;&nbsp; &nbsp;&nbsp;c)利用ArcGIS的提供的水文分析工具进行水文分析的基本方法和步骤。</p>
<p>第一步：需要的工具</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. BIGEMPA地图下载器（全能版已授权）&nbsp; 下载地址：<a href="http://download.bigemap.com/bmsetup.rar" rel="nofollow" data-token="3479a340685f599fd7007e48c4e59a9a">http://download.bigemap.com/bmsetup.rar</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. Global Mapper 14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载地址：<a href="http://bigemap.com/Uploads/file/20150804/globalmapper14.rar" rel="nofollow" data-token="cf34c5f28b3f506d183832ae1ce57d68">Global&nbsp;Mapper 14.1汉化版.rar</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. ARCGIS下载地址：<a href="http://www.bigemap.com/helps/doc2018011754.html" rel="nofollow" data-token="7f68ef3c9c59ebcccdf4b6b24adfa87a">http://www.bigemap.com/helps/doc2018011754.html</a></p>
<p>第二步骤：通过BIGEMAP下载高程数据</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. 启动BIGEMAP地图下载器软件，查看左上角是否显示【已授权：所有地图】，如果没有该显示，请联系我们的客服人员。如下图所示：</p>
<p><img alt="aba.png" class="has" height="330" src="http://www.bigemap.com/Uploads/image/20150830/1440927480684807.png" width="1000"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. 选择左上角属性选项，选择【高程】，如下图：</p>
<p><img alt="gc142.png" class="has" height="373" src="http://www.bigemap.com/Uploads/image/20150910/1441866209128936.png" width="787">&nbsp;&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; 3. 选在你要的区域，双击下载，如下图所示：</p>
<p><img alt="gcc1.png" class="has" height="735" src="http://www.bigemap.com/Uploads/image/20150904/1441364979131711.png" width="1200"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4. 选择下载的级别，建议尽量下载16级的，16级为最好级别。如果16级不能勾选，请选择下载小一点的范围，高程为矢量数据，超过20M大小，一般电脑都很难处理生成的等高线。下载之后的数据为tiff格式，实际为<a href="http://baike.baidu.com/view/264103.htm" rel="nofollow" data-token="39abcc662dfd73b6c6e8d3e6dc3c35f5">dem高程数据</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 启动安装好的Global Mapper软件，启动中文版在安装好的目录下有个chs或则chinese的启动图标，如下图所示：</p>
<p><img alt="ad.png" class="has" src="http://www.bigemap.com/Uploads/image/20150830/1440927981708303.png"></p>
<p>&nbsp;&nbsp;&nbsp; 7. 将下载好的高程数据（下载目录下的后缀为tiff格式）拖入到global mapper中，如下图所示：</p>
<p><img alt="zz11.png" class="has" height="461" src="http://www.bigemap.com/Uploads/image/20150923/1442989225343049.png" width="853"></p>
<p>&nbsp; 修改下载的高程数据的投影为【UTM】</p>
<p>&nbsp;在Global mapper中选择：工具-&gt;设置，弹出对话框，如下：</p>
<p><img alt="utm.png" class="has" height="638" src="http://www.bigemap.com/upload/images/20180511/1511417674129482.png" width="794">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>然后另存为【DEM】格式，如下图：</p>
<p><img alt="aa3.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1464762925518575.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在弹出的对话框中选择【DEM】格式，如下图:</p>
<p><img alt="aa4.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1464762991101249.png">&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;点击【确定】，保存。</p>
<p>&nbsp;&nbsp;&nbsp;<strong>DEM应用之坡度：Slope</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;打开ArcMap软件，选择添加按钮，将刚才保存的DEM文件打开，如下图：</strong></p>
<p><img alt="110.png" class="has" src="http://www.bigemap.com/Uploads/image/20160321/1458544173305095.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在ArcMap中，需要打开【扩展模块】功能，如下图：</p>
<p><img alt="aa5.png" class="has" src="http://www.bigemap.com/Uploads/image/20160601/1464763647912876.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;弹出的对话框中勾选所有选项，如下图：</p>
<p><img alt="aa6.png" class="has" src="http://www.bigemap.com/Uploads/image/20160601/1464763701659763.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点击【关闭】。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 2)&nbsp;在【ArcToolbox】中，执行命令[3D Analyst工具]——[栅格表面]——[坡度]， 如下图所示，指定各参数：</p>
<p><img alt="111.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544199716048.png"></p>
<p>&nbsp;&nbsp; 执行后，得到坡度栅格Slope_tingri1：坡度栅格中，栅格单元的值在[0 -82] 度间变化，如下图：</p>
<p><img alt="112.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544272121358.png"></p>
<p>&nbsp;&nbsp;右键点击图层[Slope_TinGrid]，执行[属性命令]，设置图层[符号系统]，重新调整坡度分级。将类别调整为5，点[分类]按钮，用手动分级法，将中断值调整为：8，15，25，35，90。</p>
<p><img alt="113.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544392159733.png"></p>
<p>&nbsp;确定后，如下：</p>
<p><img alt="114.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544413901085.png"></p>
<p>【下面计算剖面曲率】</p>
<p>&nbsp;&nbsp;&nbsp; 在【ArcToolbox】中，执行命令<strong>[3D Analyst工具]——[栅格表面]————[坡度]</strong>。按如下所示，指定各参数。得<strong>到剖面曲率栅格：[Slope _Slope]，</strong>如下图：</p>
<p><img alt="115.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544780136479.png"></p>
<p>&nbsp;<img alt="116.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544797135674.png"></p>
<p>&nbsp;</p>
<p><img alt="117.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458544815310388.png"></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>DEM应用之坡向：Aspect</strong><br /> &nbsp;&nbsp;&nbsp; 打开【ArcToolbox】，执行命令[3D Analyst工具]——[栅格表面]——[坡向]，按下图所示，指定各参数：</p>
<p><img alt="117.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545373152461.png"></p>
<p>执行结果为（<em>得</em><em>到</em><strong>坡向栅格：[Aspect_tgrid]</strong>）：</p>
<p><img alt="118.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545434350924.png"></p>
<p>【以下计算平面曲率】：</p>
<p>在【ArcToolbox】中，执行命令<strong>[3D Analyst工具]——&gt;[栅格表面]——&gt;[坡度]</strong>，按下图所示，指定各参数，按下图所示指定各参数：</p>
<p><img alt="119.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545525129224.png"></p>
<p>执行后生成<strong>平面曲率栅格</strong><strong>[Slope_Aspect]</strong>：</p>
<p><img alt="120.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545625661914.png"></p>
<p><img alt="121.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545690582176.png"></p>
<p><strong>DEM应用之提取等高线</strong></p>
<p>&nbsp;<strong>加载DEM数据，如下图：</strong></p>
<p><img alt="110.png" class="has" src="http://www.bigemap.com/Uploads/image/20160321/1458544173305095.png"></p>
<p>&nbsp;</p>
<p>然后在【ArcToolbox】中，执行命令<strong>[3DAnalyst工具]——&gt;[栅格表面]——&gt;[等值线</strong><strong>]</strong>，按下图所示指定各参数：</p>
<p><img alt="122.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458545989703569.png"></p>
<p>执行后生成<strong>等高线矢量图层：如下图：</strong></p>
<p><strong><img alt="123.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546056100763.png"></strong></p>
<p><strong>&nbsp;DEM应用之计算地形表面的阴影图</strong></p>
<p>&nbsp;在【ArcToolbox】工具箱中，执行命令<strong>[3D Analyst工具]——&gt;[栅格表面]——&gt; [山体阴影]</strong>，按下图所示指定各参数：</p>
<p><img alt="124.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546149106034.png"></p>
<p>&nbsp;执行后生成<strong>地表阴影栅格，如下图：</strong></p>
<p><strong><img alt="125.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546204138252.png"></strong></p>
<p>&nbsp;</p>
<p><strong>下</strong><strong>面进行【DEM渲染】</strong>：</p>
<p><strong>关闭除[tingrid] 和 [Hillsha_ting]以外所有图层的显示</strong>，并将[tingrid ] 置于[Hillsha_ting] 之上，右键点击[tingrid] ，在出现的右键菜单中执行[属性]，在[图层属性]对话框中，参照下图所示设置[符号系统]选项页中颜色。如图：</p>
<p><strong><img alt="126.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546334120355.png"></strong></p>
<p><strong><img alt="127.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546354143080.png"></strong></p>
<p><strong><strong>在工具栏空白处右键，打开工具栏[效果]</strong>，如下图所示，<strong>设置栅格图层[tingrid]的透明度为：[45%]左右，结果如图：</strong></strong></p>
<p><strong><img alt="128.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546509537897.png"></strong></p>
<p>&nbsp;</p>
<p><strong><img alt="129.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546526805038.png"></strong></p>
<p>&nbsp;</p>
<p><strong><img alt="130.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546725167824.png"></strong></p>
<p><strong>DEM应用之可视性分析</strong></p>
<p>&nbsp;</p>
<p><strong>（一）【通视性分析】</strong></p>
<p><strong>数据使用上一步骤的结果！在上一步的基础上进行。</strong></p>
<p>打开[3D Analyst] 工具栏，从工具栏选择[创建通视线](Line of sight)工具，如图：</p>
<p><strong><img alt="131.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546829126130.png"></strong></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 在出现的[通视分析]对话框中输入<strong>[观察者偏移量]</strong>&nbsp;和&nbsp;<strong>[目标偏移量]</strong>, 即距地面的距离，如图：</p>
<p><img alt="132.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458546906125450.png"></p>
<p>在地图显示区中从某点[A]沿不同方向绘制多条直线，可以得到观察点[A]到不同目标点的通视性：</p>
<p>&nbsp;</p>
<p><strong>（二）【可视区分析：移动发射基站信号覆盖分析】</strong></p>
<p>&nbsp;</p>
<p>(1)在上一步基础上进行，在内容列表区[TOC]中关闭除[tingrid]之外的所有图层，加载移动基站数据－矢量图层：<strong>[移动基站.shp]</strong></p>
<p>（<strong>数据后边会提高给大家下载</strong>）</p>
<p><strong><img alt="133.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458547016294982.png"></strong></p>
<p>(2)在【ArcToolbox】中，执行命令<strong>[3D Analyst工具]——&gt;[栅格表面]——&gt;[视域]</strong>，按下图所示指定各参数：</p>
<p>(<strong>其中绿色表示现有发射基站信号已覆盖的区域，淡红色表示，无法接收到手机信号的区域</strong>)</p>
<p><strong><img alt="133.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458547077188823.png"><img alt="134.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458547095311334.png"></strong></p>
<p><strong>DEM应用之地形剖面</strong></p>
<p>&nbsp;</p>
<p><strong>本步骤同样是在上一步骤的结果下进行的：</strong></p>
<p>在上一步基础上进行，打开<strong>[3D Analyst]</strong>工具栏，点击<strong>[线插值]</strong>工具，跟踪一条线段，这条线段可以从<strong>DEM:[TINGRID] 中得到高程值</strong></p>
<p><strong><img alt="135.png" class="has" src="http://www.bigemap.com/upload/images/20180511/1458547256126892.png"></strong></p>
<p><strong>点击[剖面图 ] 按钮，得到上一步所生成的3D线段的剖面图：</strong></p>
<p><strong><img alt="136.png" class="has" height="509" src="http://www.bigemap.com/upload/images/20180511/1458547351128742.png" width="806"></strong></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Multi-Segment应用——VTEP位于TOR交换机上</title>
		<link>https://uzzz.org/article/1126.html</link>
				<pubDate>Wed, 30 May 2018 11:55:56 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[darknet]]></category>
		<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1126.html</guid>
				<description><![CDATA[VXLAN的实现模型如下图： 在这个实现模型中，VTEP（VXLAN Tunnel End Point）是位于计算节点的br-tun上，但是在实际应用中，VTEP也有位于TOR交换机的情形。 VTEP位于TOR上，而不是Host内的br-tun。我们把这一段组网抽象成下图： 从用户视角，这是一个VXLAN网络，所以Neutron对外暴露的接口（模型）仍然是Network。但是在具体实现时，VTEP位于TOR上，而且，TOR还需要做VNI（VXLAN ID）到VLAN ID的映射（VLAN1、VLAN2、VLAN3、VLAN4）。这个映射并不能随意映射，因为TOR交换机上的VLAN ID，也不能任意取值，需要经过规划。所以Neutron就有了如下模型： segment实际上是一个列表，这个列表的元素是[provider:physical_network,provider:network_type,provider:segmentation_id],Neutron正是通过这三个字段描述了需要描述的信息（比如VLAN ID，即provider:segmentation_id）。 说到这里，你可能会问，那个VXLAN网络的VNI，在哪里输入？这个VNI的赋值，由Neutron内部自动生成，而它生成的方法是根据配置文件的规则。 通过上述的这个场景（VTEP位于TOR上），我们可以总结出Network模型中的segments字段的用途： 1 使用场景：主要是VTEP位于TOR上。 2 用户体验：用户感觉到的只是一个普通租户，感觉不到实现细节。 3 字段用途：由于VTEP位于TOR上，Neutron内部还需要做一个网络ID的二次转换。TOR的VLAN ID是一个提前规划好的值，不能任意取值。此时，segments字段就承担这个作用，它的取值表达的就是这些提前规划好的值。 在这里，Network模型本身的网络ID相对于外部网络ID，segment字段里的网络ID相当于内部网络ID。Network本身的网络类型是VXLAN，segments字段里的网络类型是VLAN。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<div>
   VXLAN的实现模型如下图：
  </div>
<div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180530195505465" alt="">
  </div>
<div>
   在这个实现模型中，VTEP（VXLAN Tunnel End Point）是位于计算节点的br-tun上，但是在实际应用中，VTEP也有位于TOR交换机的情形。
  </div>
<div>
   VTEP位于TOR上，而不是Host内的br-tun。我们把这一段组网抽象成下图：
  </div>
<div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180530195516437" alt="">
  </div>
<div>
   从用户视角，这是一个VXLAN网络，所以Neutron对外暴露的接口（模型）仍然是Network。但是在具体实现时，VTEP位于TOR上，而且，TOR还需要做VNI（VXLAN ID）到VLAN ID的映射（VLAN1、VLAN2、VLAN3、VLAN4）。这个映射并不能随意映射，因为TOR交换机上的VLAN ID，也不能任意取值，需要经过规划。所以Neutron就有了如下模型：
  </div>
<div>
   <img src="https://uzshare.com/_p?https://img-blog.csdn.net/20180530195526259" alt="">
  </div>
<div>
   segment实际上是一个列表，这个列表的元素是[provider:physical_network,provider:network_type,provider:segmentation_id],Neutron正是通过这三个字段描述了需要描述的信息（比如VLAN ID，即provider:segmentation_id）。
  </div>
<div>
   说到这里，你可能会问，那个VXLAN网络的VNI，在哪里输入？这个VNI的赋值，由Neutron内部自动生成，而它生成的方法是根据配置文件的规则。
  </div>
<div>
   通过上述的这个场景（VTEP位于TOR上），我们可以总结出Network模型中的segments字段的用途：
  </div>
<div>
   1 使用场景：主要是VTEP位于TOR上。
  </div>
<div>
   2 用户体验：用户感觉到的只是一个普通租户，感觉不到实现细节。
  </div>
<div>
   3 字段用途：由于VTEP位于TOR上，Neutron内部还需要做一个网络ID的二次转换。TOR的VLAN ID是一个提前规划好的值，不能任意取值。此时，segments字段就承担这个作用，它的取值表达的就是这些提前规划好的值。
  </div>
<div>
   在这里，Network模型本身的网络ID相对于外部网络ID，segment字段里的网络ID相当于内部网络ID。Network本身的网络类型是VXLAN，segments字段里的网络类型是VLAN。
  </div>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>VTk显示样式设置</title>
		<link>https://uzzz.org/article/2944.html</link>
				<pubDate>Tue, 04 Apr 2017 03:15:16 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2944.html</guid>
				<description><![CDATA[显示样式 　　在vtk中，显示样式是通过vtkProperty来控制的。这里介绍三种基本的属性设置方式：点方式，网格方式和面方式。其设置方法为 actor-&#62;GetProperty()-&#62;SetRepresentationToPoints() actor-&#62;GetProperty()-&#62;SetRepresentationToWireframe() actor-&#62;GetProperty()-&#62;SetRepresentationToSurface() 示例说明 CMakeLists.txt文件代码如下： CMAKE_MINIMUM_REQUIRED(VERSION 2.6) PROJECT( Representation ) FIND_PACKAGE(VTK REQUIRED) INCLUDE(${VTK_USE_FILE}) ADD_EXECUTABLE(Representation Representation.cpp) TARGET_LINK_LIBRARIES(Representation ${VTK_LIBRARIES}) Representation.cpp文件代码如下： #include &#60;vtkConeSource.h&#62; #include &#60;vtkPolyData.h&#62; #include &#60;vtkSmartPointer.h&#62; #include &#60;vtkPolyDataMapper.h&#62; #include &#60;vtkActor.h&#62; #include &#60;vtkRenderWindow.h&#62; #include &#60;vtkRenderer.h&#62; #include &#60;vtkRenderWindowInteractor.h&#62; #include &#60;vtkProperty.h&#62; #include &#60;iostream&#62; int main(int argc, char *argv[]) { vtkSmartPointer&#60;vtkConeSource&#62; coneSource = vtkSmartPointer&#60;vtkConeSource&#62;::New(); coneSource-&#62;Update(); vtkSmartPointer&#60;vtkPolyData&#62; cone = coneSource-&#62;GetOutput(); int nPoints = cone-&#62;GetNumberOfPoints(); int nCells = cone-&#62;GetNumberOfCells(); std::cout&#60;&#60;"Points number:"&#60;&#60;nPoints&#60;&#60;std::endl; std::cout&#60;&#60;"Cells number:"&#60;&#60;nCells&#60;&#60;std::endl; vtkSmartPointer&#60;vtkPolyDataMapper&#62; mapper = vtkSmartPointer&#60;vtkPolyDataMapper&#62;::New(); mapper-&#62;SetInputData(cone); vtkSmartPointer&#60;vtkActor&#62; actor = vtkSmartPointer&#60;vtkActor&#62;::New(); actor-&#62;SetMapper(mapper); actor-&#62;GetProperty()-&#62;SetColor(1.0, 0, 0); //设置颜色属性 actor-&#62;GetProperty()-&#62;SetRepresentationToPoints(); //点方式 //actor-&#62;GetProperty()-&#62;SetRepresentationToWireframe(); //网格方式 //actor-&#62;GetProperty()-&#62;SetRepresentationToSurface(); //默认设置，面方式 vtkSmartPointer&#60;vtkRenderer&#62; renderer = vtkSmartPointer&#60;vtkRenderer&#62;::New(); renderer-&#62;AddActor(actor); renderer-&#62;SetBackground(0.0,0.0,0.0); vtkSmartPointer&#60;vtkRenderWindow&#62; renderWindow = vtkSmartPointer&#60;vtkRenderWindow&#62;::New(); renderWindow-&#62;AddRenderer(renderer); renderWindow-&#62;SetSize( 640, 480 ); renderWindow-&#62;Render(); renderWindow-&#62;SetWindowName("Representation"); vtkSmartPointer&#60;vtkRenderWindowInteractor&#62; renderWindowInteractor = vtkSmartPointer&#60;vtkRenderWindowInteractor&#62;::New(); renderWindowInteractor-&#62;SetRenderWindow(renderWindow); renderWindow-&#62;Render(); renderWindowInteractor-&#62;Start(); return EXIT_SUCCESS; } 运行结果：]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atom-one-dark">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<h1 id="显示样式">显示样式</h1>
<p>　　在vtk中，显示样式是通过vtkProperty来控制的。这里介绍三种基本的属性设置方式：点方式，网格方式和面方式。其设置方法为</p>
<ul>
<li>actor-&gt;GetProperty()-&gt;SetRepresentationToPoints()</li>
<li>actor-&gt;GetProperty()-&gt;SetRepresentationToWireframe()</li>
<li>actor-&gt;GetProperty()-&gt;SetRepresentationToSurface()</li>
</ul>
<h1 id="示例说明">示例说明</h1>
<h2 id="cmakeliststxt文件代码如下">CMakeLists.txt文件代码如下：</h2>
<pre class="prettyprint"><code class=" hljs cmake"><span class="hljs-keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="hljs-number">2.6</span>)
<span class="hljs-keyword">PROJECT</span>( Representation )
<span class="hljs-keyword">FIND_PACKAGE</span>(VTK REQUIRED)
<span class="hljs-keyword">INCLUDE</span>(<span class="hljs-envvar">${VTK_USE_FILE}</span>)
<span class="hljs-keyword">ADD_EXECUTABLE</span>(Representation Representation.cpp)
<span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(Representation <span class="hljs-envvar">${VTK_LIBRARIES}</span>)</code></pre>
<h2 id="representationcpp文件代码如下">Representation.cpp文件代码如下：</h2>
<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;vtkConeSource.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkPolyData.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkSmartPointer.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkPolyDataMapper.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkActor.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkRenderWindow.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkRenderer.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkRenderWindowInteractor.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;vtkProperty.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])
{
    vtkSmartPointer&lt;vtkConeSource&gt; coneSource =
        vtkSmartPointer&lt;vtkConeSource&gt;::New();
    coneSource-&gt;Update();

    vtkSmartPointer&lt;vtkPolyData&gt; cone = coneSource-&gt;GetOutput();
    <span class="hljs-keyword">int</span> nPoints = cone-&gt;GetNumberOfPoints();
    <span class="hljs-keyword">int</span> nCells  = cone-&gt;GetNumberOfCells();

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Points number:"</span>&lt;&lt;nPoints&lt;&lt;<span class="hljs-built_in">std</span>::endl;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Cells number:"</span>&lt;&lt;nCells&lt;&lt;<span class="hljs-built_in">std</span>::endl;

    vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper =
        vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
    mapper-&gt;SetInputData(cone);

    vtkSmartPointer&lt;vtkActor&gt; actor =
        vtkSmartPointer&lt;vtkActor&gt;::New();
    actor-&gt;SetMapper(mapper);
    actor-&gt;GetProperty()-&gt;SetColor(<span class="hljs-number">1.0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//设置颜色属性</span>
    actor-&gt;GetProperty()-&gt;SetRepresentationToPoints();      <span class="hljs-comment">//点方式</span>
    <span class="hljs-comment">//actor-&gt;GetProperty()-&gt;SetRepresentationToWireframe(); //网格方式</span>
    <span class="hljs-comment">//actor-&gt;GetProperty()-&gt;SetRepresentationToSurface(); //默认设置，面方式</span>

    vtkSmartPointer&lt;vtkRenderer&gt; renderer =
        vtkSmartPointer&lt;vtkRenderer&gt;::New();
    renderer-&gt;AddActor(actor);
    renderer-&gt;SetBackground(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>);

    vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow =
        vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
    renderWindow-&gt;AddRenderer(renderer);
    renderWindow-&gt;SetSize( <span class="hljs-number">640</span>, <span class="hljs-number">480</span> );
    renderWindow-&gt;Render();
    renderWindow-&gt;SetWindowName(<span class="hljs-string">"Representation"</span>);

    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renderWindowInteractor =
        vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
    renderWindowInteractor-&gt;SetRenderWindow(renderWindow);

    renderWindow-&gt;Render();
    renderWindowInteractor-&gt;Start();

    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}</code></pre>
<h2 id="运行结果">运行结果：</h2>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170404111346825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Viemh1Y2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170404111408755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Viemh1Y2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170404111431333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2Viemh1Y2U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Namp新增脚本 tor-consensus-checker</title>
		<link>https://uzzz.org/article/1160.html</link>
				<pubDate>Mon, 27 Jul 2015 03:25:05 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[统计搜索]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1160.html</guid>
				<description><![CDATA[Namp新增脚本 tor-consensus-checker Nmap脚本引擎提供了大量的脚本，可以用来自动地进行远程系统扫描。目前，又增加了一个脚本tor-consensus-check。该脚本主要用来检测目标主机是否是一个知名的Tor节点。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<h1 class="entry-title" style="text-align:center;border:0px;vertical-align:baseline;clear:both;line-height:1.2;font-weight:normal;"> Namp新增脚本 tor-consensus-checker</h1>
<div class="entry-content" style="border:0px;vertical-align:baseline;">
<div style="text-align:center;">
    <span style="font-family:'Open Sans', Helvetica, Arial, sans-serif;color:#444444;"><span style="font-size:14px;line-height:24px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20150727112605127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br /></span></span>
   </div>
<p style="color:rgb(68,68,68);font-family:'Open Sans', Helvetica, Arial, sans-serif;font-size:14px;line-height:1.714285714;border:0px;vertical-align:baseline;"> Nmap脚本引擎提供了大量的脚本，可以用来自动地进行远程系统扫描。目前，又增加了一个脚本tor-consensus-check。该脚本主要用来检测目标主机是否是一个知名的Tor节点。</p>
</p></div>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
