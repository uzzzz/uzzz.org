<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>算法 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/category/suanfa/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Thu, 07 Mar 2019 03:14:57 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>算法 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>低照度图像增强之卷积神经网络RetinexNet</title>
		<link>https://uzzz.org/article/2336.html</link>
				<pubDate>Thu, 07 Mar 2019 03:14:57 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[DeepLearning]]></category>
		<category><![CDATA[算法]]></category>
		<category><![CDATA[计算机]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2336.html</guid>
				<description><![CDATA[转载请标注：https://blog.csdn.net/weixin_38285131 &#160; 目录 一丶Retinex理论——图像分解 二丶RetinexNet卷积神经网络 1.训练数据说明 2.分解网络——Decom 3.增强网络——Relight 4.结果展示 &#160; &#160; &#160; &#160;&#160;&#160;低照度图像增强一直是计算机视觉领域的一个热门研究方向，之前传统的基于Retinex理论的研究方法已经出现很多，比如：MSR,MSRCR,MSRCP等，这些方法在低照度图像增强方面效果有明显提升，上一篇博客主要介绍了基于Retinex理论的集中图像增强方法，并给出了python代码。博客链接如下： &#160;&#160;[图像增强Retinex算法之python实现——MSR,MSRCR,MSRCP,autoMSRCR](https://blog.csdn.net/weixin_38285131/article/details/88097771) &#160; &#160; &#160; &#160; 但是基于传统的图像图像处理方法处理每一张图像会比较耗时，一副4000*8000的图像需要耗时十几分钟，这样就没法批量处理低照度图像，因此本文介绍一种基于Retinex理论的卷积神经网络模型——RetinexNet,该模型是北大的童鞋在2018年发表在BMVC上的，论文名字是——Deep Retinex Decomposition for Low-Light Enhancement &#160; &#160; &#160;[论文PDF] &#160; &#160; RetinexNet项目介绍，数据集，PPT等 一丶Retinex理论——图像分解 这个理论在上一篇博客中已有介绍，任何一幅图像可以分解为光照图像（illumination）和反射图像（reflectance），反射图像是物体的本身性质决定的即为不变的部分，光照图则受外界影响比较到，可以去除光照影响或者对光照图像进行校正，则可以达到增强图像的目的。如下图所示： 左边即为低照度图像，中间即为光照图，右边即为反射图像，原图S（x,y）=I(x,y)*R(x,y),将图像变换到log域则变成了相减，然后将光照图像减去即可达到增强图像的目的。 二丶RetinexNet卷积神经网络 摘抄自论文摘要： Retinex理论是一种有效的微光图像增强工具。假设观测图像可以分解为反射图像和照度图像。大多数现有的基于Retinex卢纶的方法都为这种高度不适定的分解精心设计了手工约束和参数，当应用于各种场景时，这些约束和参数可能会受到模型容量的限制。Retinex包括一个用于分解的分解网络（Decom）和一个用于照明调节（Relight）的增强网络。在分解网络的训练过程中，没有分解反射和光照的地面真值。该网络的学习只有关键的约束条件，包括低/正常光图像共享的一致反射率，以及光照的平滑度。在分解的基础上，利用增强网络增强网对光照进行后续的亮度增强，联合去噪对反射率进行去噪操作。视网膜网是端到端可训练的，学习分解的性质有利于亮度的调节。 理论整体路线即为下图所示： 输入:低照度图像 分解网络（Decom）：对图像进行分解 增强网络（Relight）：对图像进行增强和调整 输出：校正之后的图像 1.训练数据说明 数据主要是利用单反相机不同的光圈值和感光度拍摄同一个场景，作为图像对进行训练，也就是说同一场景拍摄一个低照度图像，然后在拍摄一个正常图像进行训练，具体数据如下图所示： 作图为正常拍摄图像，右图为低照度图像，大概拍摄了500张图像对作为训练数据 2.分解网络——Decom 文中的分解网络应该是一个五层的卷积神经网络，代码中是利用relu函数进行激活，没有什么特别的处理，具体结构如下： 可以看到将图像对中的低照度图像和正常图像作为输入数据送入卷积神经网络进行分解，最后得到光照图像和反射图像，根据Retinex理论反射图像基本接近，但是两者光照图像相差很大，这样把每一张训练图像进行分解，然后再送入后面的增强网络进行训练。 3.增强网络——Relight 增强网络，我看代码应该是一个九层的卷积神经网络，利用relu进行激活，中间还进行最邻近差值的resize操作，具体如下图： 对刚才分解的反射图像进行去噪音操作，他中间用了平滑，但是我觉得用了平滑之后降低了图像本身的锐度，图像变得模糊，个人觉得这一步还应该做一下增强处理，回头看看能不能修改一下这个中间处理操作。应该可以用拉普拉斯进行一下图像恢复吧，我觉得这一步降低图像锐度不太好，重建图像稍显模糊。 4.结果展示 中间即为校正之后的，右边为正常光照图像，虽然和正常图像比不了，但是已经很不错了， 最后与其他算法做了一些对比工作，感觉各有千秋吧，不过都有一定的亮度提升，还是很值得研究一哈的&#160;做一下改进。 下一步，我准备用这个神经网络训练一下自己的数据，然后测试一下增强效果。 数据集百度网盘地址 github地址 &#160; 转载请注明地址：https://blog.csdn.net/weixin_38285131 &#160; &#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p>转载请标注：<a href="https://blog.csdn.net/weixin_38285131" rel="nofollow" data-token="80fb09a8d7a278708c96af0751400ca6">https://blog.csdn.net/weixin_38285131</a></p>
<p>&nbsp;</p>
<p id="main-toc"><strong>目录</strong></p>
<p id="**%E4%B8%80%E4%B8%B6Retinex%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%88%86%E8%A7%A3**-toc" style="margin-left:0px;"><a href="#**%E4%B8%80%E4%B8%B6Retinex%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%88%86%E8%A7%A3**" rel="nofollow" data-token="6015e61e9a12442bb5ad4e3b1d8c15ad">一丶Retinex理论——图像分解</a></p>
<p id="%E4%BA%8C%E4%B8%B6RetinexNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E4%B8%B6RetinexNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" rel="nofollow" data-token="5e6b61dcaeb5becd0e2f0e2179cf15b3">二丶RetinexNet卷积神经网络</a></p>
<p id="1.%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E" rel="nofollow" data-token="8f8c35233fe3727f1c1b42733b229737">1.训练数据说明</a></p>
<p id="2.%E5%88%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Decom-toc" style="margin-left:40px;"><a href="#2.%E5%88%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Decom" rel="nofollow" data-token="ca9569f6354592fdf13ca16deb22517e">2.分解网络——Decom</a></p>
<p id="3.%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Relight-toc" style="margin-left:40px;"><a href="#3.%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Relight" rel="nofollow" data-token="ac2c9595bc8f466bd180e77dec6fd99e">3.增强网络——Relight</a></p>
<p id="4.%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#4.%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA" rel="nofollow" data-token="403a0550cfbde01ac556b50304fb8ade">4.结果展示</a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;低照度图像增强一直是计算机视觉领域的一个热门研究方向，之前传统的基于Retinex理论的研究方法已经出现很多，比如：MSR,MSRCR,MSRCP等，这些方法在低照度图像增强方面效果有明显提升，上一篇博客主要介绍了基于Retinex理论的集中图像增强方法，并给出了python代码。博客链接如下： &nbsp;&nbsp;<br /><a href="https://blog.csdn.net/weixin_38285131/article/details/88097771" rel="nofollow" data-token="696c9959ed1320933cad101d04427e22">[图像增强Retinex算法之python实现——MSR,MSRCR,MSRCP,autoMSRCR]</a>(https://blog.csdn.net/weixin_38285131/article/details/88097771)<br /> &nbsp; &nbsp; &nbsp; &nbsp; 但是基于传统的图像图像处理方法处理每一张图像会比较耗时，一副4000*8000的图像需要耗时十几分钟，这样就没法批量处理低照度图像，因此本文介绍一种基于Retinex理论的卷积神经网络模型——RetinexNet,该模型是北大的童鞋在2018年发表在BMVC上的，论文名字是——<span style="color:#f33b45;">Deep Retinex Decomposition for Low-Light Enhancement</span><br /> &nbsp; &nbsp; <a href="http://arxiv.org/pdf/1808.04560" rel="nofollow" data-token="936cf138e9e4e57f87d8ec1a4011de5d">&nbsp;[论文PDF]</a><br /> &nbsp; &nbsp;<a href="https://daooshee.github.io/BMVC2018website/" rel="nofollow" data-token="b83ecf1744121b36e2c34fcc6b41e84a"> RetinexNet项目介绍，数据集，PPT等</a></p>
<h1 id="**%E4%B8%80%E4%B8%B6Retinex%E7%90%86%E8%AE%BA%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%88%86%E8%A7%A3**">一丶Retinex理论——图像分解</h1>
<p>这个理论在上一篇博客中已有介绍，任何一幅图像可以分解为光照图像（illumination）和反射图像（reflectance），反射图像是物体的本身性质决定的即为不变的部分，光照图则受外界影响比较到，可以去除光照影响或者对光照图像进行校正，则可以达到增强图像的目的。如下图所示：</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307103628854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70"></p>
<p>左边即为低照度图像，中间即为光照图，右边即为反射图像，原图S（x,y）=I(x,y)*R(x,y),将图像变换到log域则变成了相减，然后将光照图像减去即可达到增强图像的目的。</p>
<h1 id="%E4%BA%8C%E4%B8%B6RetinexNet%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">二丶RetinexNet卷积神经网络</h1>
<p>摘抄自论文摘要：</p>
<p>Retinex理论是一种有效的微光图像增强工具。假设观测图像<span style="color:#f33b45;">可以分解为反射图像和照度图像</span>。大多数现有的基于Retinex卢纶的方法都为这种高度不适定的分解精心设计了手工约束和参数，当应用于各种场景时，这些约束和参数可能会受到模型容量的限制。Retinex包括一个用于分解的分解网络（Decom）和一个用于照明调节（Relight）的增强网络。在分解网络的训练过程中，没有分解反射和光照的地面真值。该网络的学习只有关键的约束条件，包括<span style="color:#f33b45;">低/正常光图像共享的一致反射率</span>，以及光照的平滑度。在分解的基础上，利用增强网络增强网对光照进行后续的亮度增强，联合去噪对反射率进行去噪操作。视网膜网是端到端可训练的，学习分解的性质有利于亮度的调节。</p>
<p>理论整体路线即为下图所示：</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307104436199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70"></p>
<blockquote>
<p>输入:低照度图像</p>
<p>分解网络（Decom）：对图像进行分解</p>
<p>增强网络（Relight）：对图像进行增强和调整</p>
<p>输出：校正之后的图像</p>
</blockquote>
<h2 id="1.%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E">1.训练数据说明</h2>
<p>数据主要是利用单反相机不同的光圈值和感光度拍摄同一个场景，作为<strong><span style="color:#f33b45;">图像对</span></strong>进行训练，也就是说同一场景拍摄一个低照度图像，然后在拍摄一个正常图像进行训练，具体数据如下图所示：</p>
<p><img alt="" class="has" height="267" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307105210787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70" width="401"><img alt="" class="has" height="269" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307105235142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70" width="404"></p>
<p>作图为正常拍摄图像，右图为低照度图像，大概拍摄了500张图像对作为训练数据</p>
<h2 id="2.%E5%88%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Decom">2.分解网络——Decom</h2>
<p style="text-indent:50px;">文中的分解网络应该是一个<span style="color:#f33b45;">五层的卷积神经网络</span>，代码中是利用relu函数进行激活，没有什么特别的处理，具体结构如下：</p>
<p style="text-indent:50px;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307104837180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70"></p>
<p style="text-indent:50px;">可以看到将图像对中的低照度图像和正常图像作为输入数据送入卷积神经网络进行分解，最后得到光照图像和反射图像，根据Retinex理论<span style="color:#f33b45;">反射图像基本接近，但是两者光照图像相差很大</span>，这样把每一张训练图像进行分解，然后再送入后面的增强网络进行训练。</p>
<h2 id="3.%E5%A2%9E%E5%BC%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94Relight">3.增强网络——Relight</h2>
<p>增强网络，我看代码应该是一个九层的卷积神经网络，利用relu进行激活，中间还进行最邻近差值的resize操作，具体如下图：</p>
<p style="text-align:center;"><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307110220911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70"></p>
<p> 对刚才分解的反射图像进行去噪音操作，他中间用了平滑，但是<span style="color:#f33b45;">我觉得用了平滑之后降低了图像本身的锐度，图像变得模糊</span>，个人觉得这一步还应该做一下增强处理，回头看看能不能修改一下这个中间处理操作。应该可以用拉普拉斯进行一下图像恢复吧，我觉得这一步降低图像锐度不太好，重建图像稍显模糊。</p>
<h2 id="4.%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA">4.结果展示</h2>
<p><img alt="" class="has" height="197" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307110659257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70" width="296"><img alt="" class="has" height="199" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307110721532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70" width="299"><img alt="" class="has" height="200" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/2019030711075724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70" width="300"></p>
<p>中间即为校正之后的，右边为正常光照图像，虽然和正常图像比不了，但是已经很不错了，</p>
<p><img alt="" class="has" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190307111037453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODI4NTEzMQ==,size_16,color_FFFFFF,t_70"></p>
<p>最后与其他算法做了一些对比工作，感觉各有千秋吧，不过都有一定的亮度提升，还是很值得研究一哈的&nbsp;做一下改进。</p>
<p>下一步，我准备用这个神经网络训练一下自己的数据，然后测试一下增强效果。</p>
<p><a href="https://pan.baidu.com/s/1SQwNMIw-meZE58HlHbE0xQ?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" rel="nofollow" data-token="d811d83e92a6c4e4933330da0f55a37f">数据集百度网盘地址</a></p>
<p><a href="https://github.com/weichen582/RetinexNet" rel="nofollow" data-token="1c2bab8727bf4cbf1efa5b9e21f3db4f">github地址</a></p>
<p>&nbsp;</p>
<p>转载请注明地址：<a href="https://blog.csdn.net/weixin_38285131" rel="nofollow" data-token="80fb09a8d7a278708c96af0751400ca6">https://blog.csdn.net/weixin_38285131</a></p>
<p>&nbsp;</p>
<hr id="hr-toc">
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>计蒜客2019蓝桥杯省赛A组模拟赛（一）题目及解析</title>
		<link>https://uzzz.org/article/3252.html</link>
				<pubDate>Fri, 01 Feb 2019 17:28:45 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[Life]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3252.html</guid>
				<description><![CDATA[&#160; 蓝桥杯历年真题题目及题解目录汇总 &#160; A. 结果填空：阶乘位数&#160;题库链接 分值:&#160;5 蒜头君对阶乘产生了兴趣，他列出了前&#160;10&#160;个正整数的阶乘以及对应位数的表： n n! 位数 1 1 1 2 2 1 3 6 1 4 24 2 5 120 3 6 720 3 7 5040 4 8 40320 5 9 362880 6 10 3628800 7 对于蒜头君来说，再往后就很难计算了。他试图寻找阶乘位数的规律，但是失败了。现在请你帮他计算出第一个正整数的阶乘位数大于等于 10000&#160;的数是多少，即求最小的正整数&#160;n&#160;满足 n!&#160;的位数大于等于 10000。 答案3249，细节，注意少点new对象，大数类的对象之类的，很耗时间，打牛客的时候入过坑 import java.math.BigInteger; public class 阶乘位数 { public static void main(String[] args) { BigInteger n = BigInteger.valueOf(1); BigInteger one =BigInteger.ONE; BigInteger sum = BigInteger.ONE; int len=0; while(len&#60;10000) { n = n.add(one); sum = sum.multiply(n); len = sum.toString().length(); System.out.println(n+" "+len); } System.out.println("答案"+n); } } &#160; &#160;B. 结果填空：炮台实验&#160;题库链接 分值:&#160;7 蒜头君在玩一个战争模拟游戏，他有高度为 1,2,3,…,n&#160;的炮台各一个，他需要把这&#160;n&#160;个炮台从左往右排成一行，并且炮口都朝向右边。 在这个游戏中，所有炮台发射的炮弹会摧毁前方所有高度比自己低的炮台。每当蒜头君把&#160;n&#160;个炮台排成一行后，可能会有一些炮台被摧毁。举个例子：当前有&#160;5&#160;个炮台，从左到右高度分别为 2,1,3,5,4，往右发射炮弹后，高度为&#160;4&#160;的炮台被高度为&#160;5&#160;的摧毁，高度为&#160;1&#160;的炮台被高度为&#160;2的炮台摧毁，最后只会剩下 2,3,5&#160;这三个炮台。 现在蒜头君想知道，如果随机地摆放这&#160;n&#160;个炮台，最后剩下炮台个数的期望是多少？比如 n=2&#160;时，有两种摆放方式，高度序列分别为 1,2&#160;和 2,1，前者最后剩下 2&#160;个炮台，后者最后剩下一个炮台，因此期望为(2+1)​/2=1.5000。 请你求出 n=2019&#160;时剩下炮台个数的期望，保留四位小数。 #include &#60;cstdio&#62; using namespace std; int main() { double ans = 0; int n = 2019; for (int i = 1; i &#60;= n; i++) { ans += 1.0 / i; } printf("%.4f\n", ans); return 0; } &#160;C. 结果填空：马的管辖&#160;题库链接 分值:&#160;13 答案：90，和B组的一样。没看过B组的，建议先看 计蒜客2019蓝桥杯省赛B组模拟赛（一）题目及解析 &#160; &#160;D. 结果填空：修建公路&#160;题库链接 分值:&#160;17 蒜头国有&#160;nn&#160;座城市，编号分别为 0,1,2,3,…,n−1。编号为&#160;xx&#160;和&#160;yy&#160;的两座城市之间如果要修高速公路，必须花费 x∣y&#160;个金币，其中&#124;表示二进制按位或。 吝啬的国王想要花最少的价格修建高速公路，使得所有城市可以通过若干条高速公路互相达到。现在请你求出 n=2019&#160;时，一共有多少不同的方案，能让所有城市连通并且造价最低。方案数可能很大，你只需输出对&#160;10^9+7 取模的结果。 #include &#60;cstdio&#62; #include &#60;cstring&#62; using namespace std; typedef long long LL; const LL mod = 1e9 + 7; int main() { int n = 2019;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<h2>&nbsp;</h2>
<h3><strong><a href="https://blog.csdn.net/weixin_41793113/article/details/87974545" rel="nofollow" data-token="a422129c29f9bff6e7f6591ddfe0621a">蓝桥杯历年真题题目及题解目录汇总</a></strong></h3>
<h3>&nbsp;</h3>
<h3><strong>A. 结果填空：阶乘位数&nbsp;<a href="https://nanti.jisuanke.com/t/36099" rel="nofollow" data-token="d0a46367153c2a7264f2e5e051debebd">题库链接</a></strong></h3>
<p>分值:&nbsp;5</p>
<p>蒜头君对阶乘产生了兴趣，他列出了前&nbsp;10&nbsp;个正整数的阶乘以及对应位数的表：</p>
<table>
<thead>
<tr>
<th>n</th>
<th>n!</th>
<th>位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>24</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>120</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>720</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>5040</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>40320</td>
<td>5</td>
</tr>
<tr>
<td>9</td>
<td>362880</td>
<td>6</td>
</tr>
<tr>
<td>10</td>
<td>3628800</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>对于蒜头君来说，再往后就很难计算了。他试图寻找阶乘位数的规律，但是失败了。现在请你帮他计算出第一个正整数的阶乘位数大于等于 10000&nbsp;的数是多少，即求最小的正整数&nbsp;n&nbsp;满足 n!&nbsp;的位数大于等于 10000。</p>
<p><img alt="" class="has" height="101" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190202011643751.png" width="130"></p>
<p><span style="color:#e579b6;">答案3249，细节，注意少点new对象，大数类的对象之类的，很耗时间，打牛客的时候入过坑</span></p>
<pre class="has">
<code class="language-java">import java.math.BigInteger;

public class 阶乘位数 {

	public static void main(String[] args) {
		BigInteger n = BigInteger.valueOf(1);
		BigInteger one =BigInteger.ONE;
		BigInteger sum = BigInteger.ONE;
		int len=0;
		while(len&lt;10000) {
			n = n.add(one);
			sum = sum.multiply(n);
			len = sum.toString().length();
			System.out.println(n+" "+len);
		}
		System.out.println("答案"+n);
	}

}</code></pre>
<p>&nbsp;</p>
<h3><strong>&nbsp;B. 结果填空：炮台实验&nbsp;<a href="https://nanti.jisuanke.com/t/36100" rel="nofollow" data-token="c0d0c5d981a07dae445f794e0108ae46">题库链接</a></strong></h3>
<p>分值:&nbsp;7</p>
<p>蒜头君在玩一个战争模拟游戏，他有高度为 1,2,3,…,n&nbsp;的炮台各一个，他需要把这&nbsp;n&nbsp;个炮台从左往右排成一行，并且炮口都朝向右边。</p>
<p>在这个游戏中，所有炮台发射的炮弹会摧毁前方所有高度比自己低的炮台。每当蒜头君把&nbsp;n&nbsp;个炮台排成一行后，可能会有一些炮台被摧毁。举个例子：当前有&nbsp;5&nbsp;个炮台，从左到右高度分别为 2,1,3,5,4，往右发射炮弹后，高度为&nbsp;4&nbsp;的炮台被高度为&nbsp;5&nbsp;的摧毁，高度为&nbsp;1&nbsp;的炮台被高度为&nbsp;2的炮台摧毁，最后只会剩下 2,3,5&nbsp;这三个炮台。</p>
<p>现在蒜头君想知道，如果随机地摆放这&nbsp;n&nbsp;个炮台，最后剩下炮台个数的期望是多少？比如 n=2&nbsp;时，有两种摆放方式，高度序列分别为 1,2&nbsp;和 2,1，前者最后剩下 2&nbsp;个炮台，后者最后剩下一个炮台，因此期望为(2+1)​/2=1.5000。</p>
<p>请你求出 n=2019&nbsp;时剩下炮台个数的期望，保留四位小数。</p>
<pre class="has">
<code class="language-cpp">#include &lt;cstdio&gt;
using namespace std;
int main() {
    double ans = 0;
    int n = 2019;
    for (int i = 1; i &lt;= n; i++) {
        ans += 1.0 / i;
    }
    printf("%.4f\n", ans);
    return 0;
}</code></pre>
<h3><strong>&nbsp;C. 结果填空：马的管辖&nbsp;<a href="https://nanti.jisuanke.com/t/36101" rel="nofollow" data-token="2e9b5c26d56d45e200643935df5211fa">题库链接</a></strong></h3>
<p>分值:&nbsp;13</p>
<p><span style="color:#e579b6;">答案：90，和B组的一样。没看过B组的，建议先看</span></p>
<p><a href="https://blog.csdn.net/weixin_41793113/article/details/86721181" rel="nofollow" data-token="dd56f6becf454e6011acf93e460dd700">计蒜客2019蓝桥杯省赛B组模拟赛（一）题目及解析</a></p>
<p>&nbsp;</p>
<h3><strong>&nbsp;D. 结果填空：修建公路&nbsp;<a href="https://nanti.jisuanke.com/t/36102" rel="nofollow" data-token="3e990d9f4e84dd9f4bafdd1fba47d295">题库链接</a></strong></h3>
<p>分值:&nbsp;17</p>
<p>蒜头国有&nbsp;nn&nbsp;座城市，编号分别为 0,1,2,3,…,n−1。编号为&nbsp;xx&nbsp;和&nbsp;yy&nbsp;的两座城市之间如果要修高速公路，必须花费 x∣y&nbsp;个金币，其中<code>|</code>表示二进制按位或。</p>
<p>吝啬的国王想要花最少的价格修建高速公路，使得所有城市可以通过若干条高速公路互相达到。现在请你求出 n=2019&nbsp;时，一共有多少不同的方案，能让所有城市连通并且造价最低。方案数可能很大，你只需输出对&nbsp;10^9+7 取模的结果。</p>
<pre class="has">
<code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
int main() {
    int n = 2019;
    LL ans = 1;
    for (int i = 1; i &lt; n; i++) {
        int t = 0;
        for (int j = 0; i &gt;&gt; j &gt; 0; j++) {
            if (i &gt;&gt; j &amp; 1) t++;
        }
        ans = ans * ((1 &lt;&lt; t) - 1) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}</code></pre>
<h3><strong>&nbsp;E. 代码填空：欧拉函数&nbsp;<a href="https://nanti.jisuanke.com/t/36103" rel="nofollow" data-token="7584a807cb6a9339729b2e9d1c7f299e">题库链接</a></strong></h3>
<p>分值:&nbsp;9</p>
<p>在数论中，对正整数&nbsp;n，欧拉函数 <img alt="\varphi(n)" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cvarphi%28n%29">&nbsp;是小于等于&nbsp;n&nbsp;的正整数中与&nbsp;n&nbsp;互质的数的数目。</p>
<p>例如 <img alt="\varphi(12)" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cvarphi%2812%29">&nbsp;= 4，因为 1,5,7,11&nbsp;均和 12&nbsp;互质。</p>
<p>代码框中的代码是一种求欧拉函数的实现，请分析并填写缺失的代码，计算出<img alt="\varphi(n)" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cvarphi%28n%29">的值。</p>
<p><img alt="" class="has" height="93" src="https://uzshare.com/_p?https://img-blog.csdnimg.cn/20190202012712922.png" width="345"></p>
<pre class="has">
<code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int euler(int n) {
    int res = n;
    for (int i = 2; i &lt;= n; i++) {
        if (n % i == 0) {
            res = res - res / i;
            while (n % i == 0) {
                n /= i;
            }
        }
    }
    return res;
}
int main() {
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; euler(n) &lt;&lt; endl;
    return 0;
}</code></pre>
<h3><strong>&nbsp;F. 程序设计：掎角之势&nbsp;<a href="https://nanti.jisuanke.com/t/36104" rel="nofollow" data-token="fceefca160d1a828ef61e9743e3afb5e">题库链接</a></strong></h3>
<p>分值:&nbsp;11</p>
<pre class="has">
<code class="language-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
using namespace std;
int main() {
    int T;
    scanf("%d", &amp;T);
    while (T--) {
        int x1, y1, x2, y2, x3, y3;
        scanf("%d %d %d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3);
        x1 -= x3;
        y1 -= y3;
        x2 -= x3;
        y2 -= y3;
        if (x1 * y2 == x2 * y1) {
            puts("NO SOLUTION");
            continue;
        }
        double s = fabs(x1 * y2 - x2 * y1);
        double a = sqrt(x1 * x1 + y1 * y1);
        double b = sqrt(x2 * x2 + y2 * y2);
        double c = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        double r1 = s / (a + b + c);
        double r2 = a * b * c / s / 2;
        printf("%.10f %.10f\n", r1 * r1 * acos(-1), r2 * r2 * acos(-1));
    }
    return 0;
}</code></pre>
<p><span style="color:#e579b6;">暴力40%</span></p>
<pre class="has">
<code class="language-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
using namespace std;
int main() {
    int T;
    scanf("%d", &amp;T);
    while (T--) {
        int x1, y1, x2, y2, x3, y3;
        scanf("%d %d %d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3);
        if (y1 == 0 || x2 == 0) {
            puts("NO SOLUTION");
            continue;
        }
        double s = y1 * x2;
        double c = sqrt(y1 * y1 + x2 * x2);
        double r1 = s / (y1 + x2 + c);
        double r2 = c / 2;
        printf("%.10f %.10f\n", r1 * r1 * acos(-1), r2 * r2 * acos(-1));
    }
    return 0;
}</code></pre>
<p>&nbsp;</p>
<h3><strong>&nbsp;G. 程序设计：轻重搭配&nbsp;<a href="https://nanti.jisuanke.com/t/36105" rel="nofollow" data-token="3c2511b66f13fcb765631cfddc0e23fe">题库链接</a></strong></h3>
<p>分值:&nbsp;19</p>
<p><span style="color:#e579b6;">答案：这题也和B组的一样。没看过B组的，建议先看</span></p>
<p><a href="https://blog.csdn.net/weixin_41793113/article/details/86721181" rel="nofollow" data-token="dd56f6becf454e6011acf93e460dd700">计蒜客2019蓝桥杯省赛B组模拟赛（一）题目及解析</a></p>
<p>&nbsp;</p>
<h3><strong>&nbsp;H. 程序设计：忽明忽暗&nbsp;<a href="https://nanti.jisuanke.com/t/36106" rel="nofollow" data-token="c5fdc14c775d4bc021950a375a01de94">题库链接</a></strong></h3>
<p>分值:&nbsp;21</p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
int main() {
    long long n, mod = 1e9 + 7;
    cin &gt;&gt; n;
    long long t = sqrt(n);
    long long ans = t * (t + 1) / 2;
    if (ans % 3 == 0) {
        ans = ans / 3 % mod * (2 * t + 1) % mod;
    } else {
        ans = ans % mod * ((2 * t + 1) / 3) % mod;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
int main() {
    long long n, mod = 1e9 + 7;
    cin &gt;&gt; n;
    __int128 t = sqrt(n);
    long long ans = t * (t + 1) * (2 * t + 1) / 6 % mod;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
bool a[1000005];
int main() {
    long long n, mod = 1e9 + 7;
    cin &gt;&gt; n;
    long long ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = i; j &lt;= n; j += i) {
            a[j] = !a[j];
        }
    }
    for (int i = 1; i &lt;= n; i++) {
        if (a[i]) ans += i;
    }
    cout &lt;&lt; ans % mod &lt;&lt; endl;
    return 0;
}</code></pre>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
int main() {
    long long n, mod = 1e9 + 7;
    cin &gt;&gt; n;
    long long t = sqrt(n);
    long long ans = 0;
    for (long long i = 1; i * i &lt;= n; i++) {
        ans += i * i;
        ans %= mod;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><strong>&nbsp;I. 程序设计：人以群分&nbsp;<a href="https://nanti.jisuanke.com/t/36107" rel="nofollow" data-token="bcd076f50443646d992f5f85bfd3df5e">题库链接</a></strong></h3>
<p>分值:&nbsp;23</p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 500005;
int n, m;
int a[N], dp[N];
bool check(int x) {
    // dp[0~m-1]=0
    for (int i = m; i &lt;= n; i++) {
        if (a[i] - a[dp[i - m] + 1] &lt;= x) {
            dp[i] = i;
        } else {
            dp[i] = dp[i - 1];
        }
    }
    return dp[n] == n;
}
int main() {
    scanf("%d %d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) {
        scanf("%d", &amp;a[i]);
    }
    sort(a + 1, a + n + 1);
    int l = 0, r = 1e9;
    while (l &lt; r) {
        int mid = (l + r) &gt;&gt; 1;
        if (check(mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    printf("%d\n", l);
    return 0;
}</code></pre>
<p><span style="color:#e579b6;">暴力30%</span></p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 500005;
int n, m;
int a[N];
int ans = 0;
void dfs(int u, int x, int t) {
    if (u == n) {
        if (u - x + 1 &gt;= m) {
            t = max(t, a[u] - a[x]);
            ans = min(ans, t);
        }
        return;
    }
    if (u - x + 1 &gt;= m) {
        dfs(u + 1, u + 1, max(t, a[u] - a[x]));
    }
    dfs(u + 1, x, t);
}
int main() {
    scanf("%d %d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) {
        scanf("%d", &amp;a[i]);
    }
    sort(a + 1, a + n + 1);
    ans = 1e9;
    dfs(1, 1, 0);
    printf("%d\n", ans);
    return 0;
}</code></pre>
<p><span style="color:#e579b6;">&nbsp;暴力60%</span></p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
const int N = 500005;
int n, m;
int a[N], dp[N];
bool check(int x) {
    // dp[0~m-1]=0
    for (int i = m; i &lt;= n; i++) {
        if (a[i] - a[dp[i - m] + 1] &lt;= x) {
            dp[i] = i;
        } else {
            dp[i] = dp[i - 1];
        }
    }
    return dp[n] == n;
}
int main() {
    scanf("%d %d", &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; i++) {
        scanf("%d", &amp;a[i]);
    }
    sort(a + 1, a + n + 1);
    for (int i = 0;; i++) {
        if (check(i)) {
            printf("%d\n", i);
            break;
        }
    }
    return 0;
}</code></pre>
<h3>&nbsp;<strong>J. 程序设计：势能之和&nbsp;<a href="https://nanti.jisuanke.com/t/36108" rel="nofollow" data-token="217a610df18cf73d430c5f6e3d22ed77">题库链接</a></strong></h3>
<p>分值:&nbsp;25</p>
<pre class="has">
<code class="language-cpp">#include &lt;cstdio&gt;
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 1000005;
int a[N];
LL two[N];
LL b[N];
LL inv[1000005];
void inv_init(int n) {
    inv[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
}
int main() {
    const int wc = 1e6;
    two[0] = 1;
    for (int i = 1; i &lt;= wc; i++) {
        two[i] = two[i - 1] * 2 % mod;
    }
    inv_init(wc);
    int n;
    scanf("%d", &amp;n);
    LL all = 1;
    for (int i = 0; i &lt; n; i++) {
        int x;
        scanf("%d", &amp;x);
        a[x]++;
        all = all * x % mod;
    }
    LL ans = 0;
    for (int i = wc; i &gt;= 1; i--) {
        int sum = a[i];
        b[i] = 0;
        for (int j = i + i; j &lt;= wc; j += i) {
            b[i] -= b[j];
            sum += a[j];
        }
        b[i] += two[sum] - 1;
        b[i] = (b[i] % mod + mod) % mod;
        ans += b[i] * all % mod * inv[i] % mod;
    }
    ans %= mod;
    printf("%lld\n", ans);
    return 0;
}</code></pre>
<p><span style="color:#e579b6;">暴力30%&nbsp;</span></p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 200005;
LL a[N];
int main() {
    int n;
    scanf("%d", &amp;n);
    LL all = 1;
    for (int i = 0; i &lt; n; i++) {
        scanf("%lld", &amp;a[i]);
        all = all * a[i];
    }
    for (int i = 0; i &lt; n; i++) {
        a[i] = all / a[i];
    }
    LL ans = 0;
    for (int s = 1; s &lt; 1 &lt;&lt; n; s++) {
        LL tmp = 1;
        for (int i = 0; i &lt; n; i++) {
            if (s &gt;&gt; i &amp; 1) {
                tmp = tmp / __gcd(tmp, a[i]) * a[i];
            }
        }
        ans = (ans + tmp) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}</code></pre>
<p><span style="color:#e579b6;">暴力60%&nbsp;</span></p>
<pre class="has">
<code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
typedef long long LL;
const LL mod = 1e9 + 7;
const int N = 200005;
LL a[N];
LL pow_mod(LL x, LL p) {
    LL res = 1;
    while (p) {
        if (p &amp; 1) res = res * x % mod;
        p &gt;&gt;= 1;
        x = x * x % mod;
    }
    return res;
}
int main() {
    int n;
    scanf("%d", &amp;n);
    LL all = 1;
    for (int i = 0; i &lt; n; i++) {
        scanf("%lld", &amp;a[i]);
        all = all * a[i] % mod;
    }
    LL ans = 0;
    for (int s = 1; s &lt; 1 &lt;&lt; n; s++) {
        LL tmp = 0;
        for (int i = 0; i &lt; n; i++) {
            if (s &gt;&gt; i &amp; 1) {
                tmp = __gcd(a[i], tmp);
            }
        }
        ans = (ans + all * pow_mod(tmp, mod - 2)) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}</code></pre>
<p>&nbsp;</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>算法刷题（18）_逆时针打印矩阵学习记录</title>
		<link>https://uzzz.org/article/3379.html</link>
				<pubDate>Sat, 28 Jul 2018 21:12:15 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3379.html</guid>
				<description><![CDATA[算法刷题（18）_逆时针打印矩阵学习记录 【说明】 题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵：&#160; 1&#160;&#160; 2&#160;&#160; 3&#160;&#160; 4&#160; 5&#160;&#160; 6&#160;&#160; 7&#160;&#160; 8&#160; 9&#160; 10 11 12&#160; 13 14 15 16&#160; 则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7. 【算法实现】 package p4; /** * 逆时针打印矩阵 * @author Guozhu Zhu * @date 2018/7/29 * @version 1.0 * */ public class Test02 { public static void main(String[] args) { int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}}; int[] res = Solution01(arr, 4, 3); for (int i : res) { System.out.println(i); } } public static int[] Solution01(int[][] arr, int n, int m) { int startX = 0; int startY = 0; int endX = m-1; int endY = n-1; int index = 0; int[] res = new int[n*m]; while (startX &#60;= endX &#38;&#38; startY &#60;= endY) { // 上----&#62;下 if (startY &#60;= endY) { for (int i = startY; i &#60;= endY; i++) { res[index++] = arr[i][startX]; } } // 左----&#62;右 (两列以上) if (startX &#60; endX) { for (int i = startX+1; i &#60;= endX; i++) { res[index++] = arr[endY][i]; } } // 下----&#62;上(两行两列以上) if (startX &#60; endX &#38;&#38; startY &#60; endY) { for]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<blockquote>
<p>算法刷题（18）_逆时针打印矩阵学习记录</p>
</blockquote>
<p>【说明】</p>
<p>题目：输入一个矩阵，按照从外向里以顺时针顺序依次打印出每一个数字，例如：如果输入如下矩阵：&nbsp;<br /> 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;<br /> 5&nbsp;&nbsp; 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;<br /> 9&nbsp; 10 11 12&nbsp;<br /> 13 14 15 16&nbsp;</p>
<p>则依次打印出数字1, 5，9，13，14，15，16，12，8，4，3，2，6，10，11，7.</p>
<p>【算法实现】</p>
<pre class="has">
<code class="language-java">package p4;

/**
 * 逆时针打印矩阵
 * @author Guozhu Zhu
 * @date 2018/7/29
 * @version 1.0
 *
 */
public class Test02 {
	
	public static void main(String[] args) {
		int[][] arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12}};
		int[] res = Solution01(arr, 4, 3);
		for (int i : res) {
			System.out.println(i);
		}
	}
	
	public static int[] Solution01(int[][] arr, int n, int m) {
		int startX = 0;
		int startY = 0;
		int endX = m-1;
		int endY = n-1;
		int index = 0;
		int[] res = new int[n*m];
		while (startX &lt;= endX &amp;&amp; startY &lt;= endY) {
			// 上----&gt;下
			if (startY &lt;= endY) {
				for (int i = startY; i &lt;= endY; i++) {
					res[index++] = arr[i][startX];
				}
			}
			// 左----&gt;右 (两列以上)
			if (startX &lt; endX) {
				for (int i = startX+1; i &lt;= endX; i++) {
					res[index++] = arr[endY][i];
				}
			}
			// 下----&gt;上(两行两列以上)
			if (startX &lt; endX &amp;&amp; startY &lt; endY) {
				for (int i = endY-1; i &gt;= startY; i--) {
					res[index++] = arr[i][endX];
				}
			}
			// 右----&gt;左(三列两行以上)
			if (startX &lt; endX-1 &amp;&amp; startY &lt; endY) {
				for (int i = endX-1; i &gt;= startX+1; i--) {
					res[index++] = arr[startY][i];
				}
			}
			startX++;
			startY++;
			endX--;
			endY--;
		}
		return res;
	}

}
</code></pre>
<p><img alt="" class="has" height="452" src="https://uzshare.com/_p?https://img-blog.csdn.net/20180729051157287?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzc3MDAyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="286"></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>leetcode经典题目及解法记录</title>
		<link>https://uzzz.org/article/2455.html</link>
				<pubDate>Fri, 20 Oct 2017 14:43:50 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2455.html</guid>
				<description><![CDATA[Question15 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 解法如下： public List&#60;List&#60;Integer&#62;&#62; threeSum(int[] nums) { List&#60;List&#60;Integer&#62;&#62; res = new ArrayList(); Arrays.sort(nums); for(int i = 0; i &#60; nums.length; i++){ if(i==0&#124;&#124;(i&#62;0&#38;&#38;nums[i]!=nums[i-1])){ int lo=i+1, hi=nums.length-1, sum=0-nums[i]; while(lo&#60;hi){ if(nums[lo]+nums[hi]==sum){ res.add(Arrays.asList(nums[i], nums[lo], nums[hi])); while(lo&#60;hi&#38;&#38;nums[lo]==nums[lo+1]) lo++; while(lo&#60;hi&#38;&#38;nums[hi]==nums[hi-1]) hi--; lo++; hi--; }else if(nums[lo]+nums[hi]&#60;sum) lo++; else hi--; } } } return res; } Question16 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
  <!-- flowchart 箭头图标 勿删 --><br />
  <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
   <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
  </svg> </p>
<blockquote>
<p>Question15 <strong>3Sum</strong></p>
</blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. <br /> Note: The solution set must not contain duplicate triplets.</p>
<p>For example, given array S = [-1, 0, 1, 2, -1, -4], <br /> A solution set is: <br /> [ <br /> [-1, 0, 1], <br /> [-1, -1, 2] <br /> ] <br /> 解法如下：</p>
<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList();
    Arrays.sort(nums);
    for(int i = 0; i &lt; nums.length; i++){
        if(i==0||(i&gt;0&amp;&amp;nums[i]!=nums[i-1])){
            int lo=i+1, hi=nums.length-1, sum=0-nums[i];
            while(lo&lt;hi){
                if(nums[lo]+nums[hi]==sum){
                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                    while(lo&lt;hi&amp;&amp;nums[lo]==nums[lo+1]) lo++;
                    while(lo&lt;hi&amp;&amp;nums[hi]==nums[hi-1]) hi--;
                    lo++;
                    hi--;
                }else if(nums[lo]+nums[hi]&lt;sum)
                    lo++;
                else
                    hi--;
            }
        }
    }
    return res;
}
</code></pre>
<hr>
<blockquote>
<p>Question16 <strong>3Sum Closest</strong> </p>
</blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1. <br /> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). <br /> 解法如下：</p>
<pre><code>public int threeSumClosest(int[] nums, int target) {
    int res = nums[0]+nums[1]+nums[nums.length-1];
    Arrays.sort(nums);
    for(int i = 0; i &lt; nums.length-2; i++){
        int lo = i+1, hi = nums.length-1;
        while(lo &lt; hi){
            int sum = nums[i]+nums[lo]+nums[hi];
            if(sum==target)
                return sum;
            if(sum&lt;target)
                lo++;
            else
                hi--;
            if(Math.abs(res-target)&gt;Math.abs(sum-target))
                res = sum;
        }
    }
    return res;
}
</code></pre>
</p></div>
<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-526ced5128.css" rel="stylesheet">
</div>
]]></content:encoded>
										</item>
		<item>
		<title>Elo评分算法原理与实现</title>
		<link>https://uzzz.org/article/2888.html</link>
				<pubDate>Wed, 19 Apr 2017 07:38:55 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2888.html</guid>
				<description><![CDATA[《社交网络》里的Mark Zackburg被女朋友甩后，在舍友的启发下，充分发挥了技术宅男自娱自乐的恶搞天分，做出了Facemash网站，对学校女生的相貌进行排名打分，结果网站访问流量过大，直接把学校网络搞瘫痪了。Facemask大受欢迎的关键就在于Zackburg基友Eduardo写在窗户上的排名公式，看电影之时就对这个排名公式非常感兴趣，上网了解下，才发现这条公式就是大名鼎鼎的ELO等级分制度。ELO的应用非常广泛，大部分棋类比赛，现在流行的MODB游戏，像11平台的DOTA天梯系统，都是采用ELO等级分。 ELO等级分制度是由匈牙利裔美国物理学家Elo创建的一个衡量各类对弈活动选手水平的评分方法，是当今对弈水平评估的公认的权威方法。被广泛应用于国际象棋、围棋、足球等运动，以及很多网游与电子竞技产业。游戏界比较著名的应用有： WOW（魔兽世界）、DOTA、LOL。 ELO计算方法 Ra：A玩家当前的积分 Rb：B玩家当前的积分 Sa：实际胜负值，胜=1，平=0.5，负=0 Ea：预期A选手的胜负值，Ea=1/(1+10^[(Rb-Ra)/400]) Eb：预期B选手的胜负值，Eb=1/(1+10^[(Ra-Rb)/400]) 因为E值也为预估，则Ea+ Eb=1 R’a=Ra+K（Sa-Ea） R’a：A玩家进行了一场比赛之后的积分 其中 K 值是一个常量系数，按照国际象棋里的标准， K 值对于大师选手为16，对于一般选手是32。K值的大小直接关系到一局游戏结束，根据胜负关系计算出的积分变化值。 关于K值 K值是一个极限值，代表理论上最多可以赢一个玩家的得分和失分，K/2就是相同rating的玩家其中一方胜利后所得的分数。国际象棋大师赛中，K=16；在大部分的游戏规则中，K=32。通常水平越高的比赛中其K值越小，这样做是为了避免少数的几场比赛就能改变高端顶尖玩家的排名。 关于分母400 公式Ea和Eb中分母的400是怎么来的呢？为何是400，不是200、100或者是其他？ 根据公式可以得出，当K值相同的情况下，越高的分母，越低的积分变化。总体来说400是一个平衡的、万金油的值、让多数玩家积分保持 标准正态分布 的值。具体可以参考：http://en.chessbase.com/post/arpad-elo-and-the-elo-rating-system 实例说明 若当前A玩家积分为1500，B玩家积分为1600 预估A玩家的胜负值： Ea = 1/(1+10^[（1600-1500）/400]）≈0.36 预估B玩家的胜负值： Eb = 1-Ea = 1-0.36 = 0.64 假设A玩家获胜，实际胜负值为Sa = 1 A玩家最终得分为 ：R’a = 1500 + 32*(1-0.36) = 1500+20.5 = 1520 A玩家赢20分，B玩家输20分。 假设B玩家获胜，实际胜负值为Sa = 1 B队最终得分为 R’b = 1600 + 32*(1-0.64) = 1600 + 11.52 = 1612，B玩家赢12分，A玩家输12分。 class Elorating: ELO_RESULT_WIN = 1 ELO_RESULT_LOSS = -1 ELO_RESULT_TIE = 0 ELO_RATING_DEFAULT = 1500 ratingA = 0 ratingB = 0 def __init__(self, ratingA = ELO_RATING_DEFAULT, ratingB = ELO_RATING_DEFAULT): self.ratingA = ratingA self.ratingB = ratingB def setResult(self, result): scoreAwin = self.computeScore(self.ratingA, self.ratingB) scoreBwin = self.computeScore(self.ratingB, self.ratingA) score_adjust = 0 if result == self.ELO_RESULT_WIN: score_adjust = 1 elif result == self.ELO_RESULT_LOSS: score_adjust = 0 else: score_adjust = 0.5 self.ratingA = self.ratingA + self.computeK(self.ratingA) * (score_adjust - scoreAwin) self.ratingB = self.ratingB + self.computeK(self.ratingB) * (score_adjust - scoreBwin) def computeK(self, rating): if rating &#62;= 2400: return 16 elif rating &#62;= 2100: return 24 else: return 36 def computeScore(self, rating1, rating2): return 1 / (1+pow(10, (rating1]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170419154206351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXExMDA0NDAxMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>《社交网络》里的Mark Zackburg被女朋友甩后，在舍友的启发下，充分发挥了技术宅男自娱自乐的恶搞天分，做出了Facemash网站，对学校女生的相貌进行排名打分，结果网站访问流量过大，直接把学校网络搞瘫痪了。Facemask大受欢迎的关键就在于Zackburg基友Eduardo写在窗户上的排名公式，看电影之时就对这个排名公式非常感兴趣，上网了解下，才发现这条公式就是大名鼎鼎的ELO等级分制度。ELO的应用非常广泛，大部分棋类比赛，现在流行的MODB游戏，像11平台的DOTA天梯系统，都是采用ELO等级分。</p>
<p>ELO等级分制度是由匈牙利裔美国物理学家Elo创建的一个衡量各类对弈活动选手水平的评分方法，是当今对弈水平评估的公认的权威方法。被广泛应用于国际象棋、围棋、足球等运动，以及很多网游与电子竞技产业。游戏界比较著名的应用有： WOW（魔兽世界）、DOTA、LOL。</p>
<p> ELO计算方法 <br /> Ra：A玩家当前的积分 <br /> Rb：B玩家当前的积分 <br /> Sa：实际胜负值，胜=1，平=0.5，负=0 <br /> Ea：预期A选手的胜负值，Ea=1/(1+10^[(Rb-Ra)/400]) <br /> Eb：预期B选手的胜负值，Eb=1/(1+10^[(Ra-Rb)/400]) <br /> 因为E值也为预估，则Ea+ Eb=1 </p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170419153519685?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXExMDA0NDAxMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20170419153542740?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXExMDA0NDAxMTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>R’a=Ra+K（Sa-Ea） <br /> R’a：A玩家进行了一场比赛之后的积分 <br /> 其中 K 值是一个常量系数，按照国际象棋里的标准， K 值对于大师选手为16，对于一般选手是32。K值的大小直接关系到一局游戏结束，根据胜负关系计算出的积分变化值。</p>
<p> 关于K值 <br /> K值是一个极限值，代表理论上最多可以赢一个玩家的得分和失分，K/2就是相同rating的玩家其中一方胜利后所得的分数。国际象棋大师赛中，K=16；在大部分的游戏规则中，K=32。通常水平越高的比赛中其K值越小，这样做是为了避免少数的几场比赛就能改变高端顶尖玩家的排名。</p>
<p> 关于分母400 <br /> 公式Ea和Eb中分母的400是怎么来的呢？为何是400，不是200、100或者是其他？ <br /> 根据公式可以得出，当K值相同的情况下，越高的分母，越低的积分变化。总体来说400是一个平衡的、万金油的值、让多数玩家积分保持 标准正态分布 的值。具体可以参考：http://en.chessbase.com/post/arpad-elo-and-the-elo-rating-system</p>
<p> 实例说明 <br /> 若当前A玩家积分为1500，B玩家积分为1600 <br /> 预估A玩家的胜负值： Ea = 1/(1+10^[（1600-1500）/400]）≈0.36 <br /> 预估B玩家的胜负值： Eb = 1-Ea = 1-0.36 = 0.64 <br /> 假设A玩家获胜，实际胜负值为Sa = 1 <br /> A玩家最终得分为 ：R’a = 1500 + 32*(1-0.36) = 1500+20.5 = 1520 <br /> A玩家赢20分，B玩家输20分。 <br /> 假设B玩家获胜，实际胜负值为Sa = 1 <br /> B队最终得分为 R’b = 1600 + 32*(1-0.64) = 1600 + 11.52 = 1612，B玩家赢12分，A玩家输12分。</p>
</p>
<pre><code class="language-python">class Elorating:
    ELO_RESULT_WIN = 1
    ELO_RESULT_LOSS = -1
    ELO_RESULT_TIE = 0

    ELO_RATING_DEFAULT = 1500

    ratingA = 0
    ratingB = 0

    def __init__(self, ratingA = ELO_RATING_DEFAULT, ratingB = ELO_RATING_DEFAULT):
        self.ratingA = ratingA
        self.ratingB = ratingB

    def setResult(self, result):
        scoreAwin = self.computeScore(self.ratingA, self.ratingB)
        scoreBwin = self.computeScore(self.ratingB, self.ratingA)

        score_adjust = 0
        if result == self.ELO_RESULT_WIN:
            score_adjust = 1
        elif result == self.ELO_RESULT_LOSS:
            score_adjust = 0
        else:
            score_adjust = 0.5

        self.ratingA = self.ratingA + self.computeK(self.ratingA) * (score_adjust - scoreAwin)
        self.ratingB = self.ratingB + self.computeK(self.ratingB) * (score_adjust - scoreBwin)


    def computeK(self, rating):
        if rating &gt;= 2400:
            return 16
        elif rating &gt;= 2100:
            return 24
        else:
            return 36


    def computeScore(self, rating1, rating2):
        return 1 / (1+pow(10, (rating1 - rating2) / 400))

    pass</code></pre>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>一道逻辑题 房间里有100盏电灯</title>
		<link>https://uzzz.org/article/3448.html</link>
				<pubDate>Sun, 12 Apr 2015 08:41:51 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[java]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3448.html</guid>
				<description><![CDATA[在 博客园看到的这个问题，也想做一下。题目是这样的 房间里有100盏电灯，编号为1，2，3……100，每盏灯上有一个按钮，初始时灯全都是关的。编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）……第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？ 最简单的做法就是模拟一下100个同学进入房间的情景，从1号同学开始每个人都去按一遍开关，最后看一下哪些灯亮着，这个方法最简单也最容易想到，可是效率有点低。其实可以计算一下每个开关被按下的次数，因为刚开始的时候所有的灯泡都是关着的，所以如果某个灯泡的开关被按了奇数次，那么这个灯泡最终就是开着的，否则就是关着的。那怎么计算每个灯泡开关被按下的次数呢？因为每个同学都会按下自己编号倍数的开关，即如果灯泡编号是同学编号的倍数，他就会按下开关，也就是说如果同学编号是灯泡编号的约数，他就会按下开关（这不是废话么）。那么统计一下灯泡编号约数的个数就可以了，约数个数为计数的灯泡最后开着，约数个数为偶数的灯泡最后关着。下边是代码： public class Lamp { public static void main(String[] args){ int result = 0; for(int i=1;i&#60;=100;i++){ if(isOdd(getFactorNum(i))){ result += 1; } } System.out.println(result); } //求n约数的个数 public static int getFactorNum(int n){ int result = 0; for(int i=1;i&#60;=n;i++){ if(n%i == 0){ result += 1; } } return result; } //判断n是否为奇数 public static boolean isOdd(int n){ return (n&#38;1) == 1; } } &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;更新&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212; 又想了一下还有更简单的算法，因为一个数的约数都成成对出现的，也就是说如果n存在一个约数p，那么一定有一个q与之相对应且满足n=pq，所以n约数的个数一定是偶数，但是有一种情况例外，那就是p=q，所以只有编号为完全平方数的灯泡亮着。按着这个方法计算就简单多了，直接return (int)Math.sqrt(100);]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
   在<br />
  <a href="http://www.cnblogs.com/t2xingzhe/archive/2012/10/23/2735095.html" rel="nofollow" data-token="8e923973a11f16e4cbdd9ffcc3a77d19">博客园</a>看到的这个问题，也想做一下。题目是这样的</p>
<p> 房间里有100盏电灯，编号为1，2，3……100，每盏灯上有一个按钮，初始时灯全都是关的。编好号的100位同学由房间外依次走进去，将自己编号的倍数的灯的按钮全部按一次，例如第一位同学把编号是1的倍数的灯的按钮按一下（此时100盏灯全亮），第二位同学把编号是2的倍数的灯的按钮按一下（此时只有50盏灯亮着，50盏被这个人按灭了）……第100位同学把编号是100的倍数的灯（即编号为100的灯）的按钮按一下，请问依次走完后，还有多少盏灯亮着？</p>
<p> 最简单的做法就是模拟一下100个同学进入房间的情景，从1号同学开始每个人都去按一遍开关，最后看一下哪些灯亮着，这个方法最简单也最容易想到，可是效率有点低。其实可以计算一下每个开关被按下的次数，因为刚开始的时候所有的灯泡都是关着的，所以如果某个灯泡的开关被按了奇数次，那么这个灯泡最终就是开着的，否则就是关着的。那怎么计算每个灯泡开关被按下的次数呢？因为每个同学都会按下自己编号倍数的开关，即如果灯泡编号是同学编号的倍数，他就会按下开关，也就是说如果同学编号是灯泡编号的约数，他就会按下开关（这不是废话么）。那么统计一下灯泡编号约数的个数就可以了，约数个数为计数的灯泡最后开着，约数个数为偶数的灯泡最后关着。下边是代码：</p>
<pre><code class="language-java">public class Lamp {
    public static void main(String[] args){
        int result = 0;
        for(int i=1;i&lt;=100;i++){
            if(isOdd(getFactorNum(i))){
                result += 1;
            }
        }
        System.out.println(result);
    }
    //求n约数的个数
    public static int getFactorNum(int n){
        int result = 0;
        for(int i=1;i&lt;=n;i++){
            if(n%i == 0){
                result += 1;
            }
        }
        return result;
    }
    //判断n是否为奇数
    public static boolean isOdd(int n){
        return (n&amp;1) == 1;
    }
}</code></pre>
<p> &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;更新&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;</p>
<p> 又想了一下还有更简单的算法，因为一个数的约数都成成对出现的，也就是说如果n存在一个约数p，那么一定有一个q与之相对应且满足n=pq，所以n约数的个数一定是偶数，但是有一种情况例外，那就是p=q，所以只有编号为完全平方数的灯泡亮着。按着这个方法计算就简单多了，直接return (int)Math.sqrt(100);
 </div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>18大经典数据挖掘算法小结</title>
		<link>https://uzzz.org/article/2442.html</link>
				<pubDate>Fri, 27 Feb 2015 02:04:01 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[机器学习]]></category>
		<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2442.html</guid>
				<description><![CDATA[本文所有涉及到的数据挖掘代码的都放在了我的github上了。 地址链接:&#160;https://github.com/linyiqun/DataMiningAlgorithm 大概花了将近2个月的时间，自己把18大数据挖掘的经典算法进行了学习并且进行了代码实现，涉及到了决策分类，聚类，链接挖掘，关联挖掘，模式挖掘等等方面。也算是对数据挖掘领域的小小入门了吧。下面就做个小小的总结，后面都是我自己相应算法的博文链接，希望能够帮助大家学习。 1.C4.5算法。C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42395865 2.CART算法。CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法， 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42558235 3.KNN(K最近邻)算法。给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42613011 4.Naive&#160;Bayes(朴素贝叶斯)算法。朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42680161 5.SVM(支持向量机)算法。支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42780439 6.EM(期望最大化)算法。期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/42921789 7.Apriori算法。Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43059211 8.FP-Tree(频繁模式树)算法。这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43234309 9.PageRank(网页重要性/排名)算法。PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link&#160;Span攻击。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43311943 10.HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43311943 11.K-Means(K均值)算法。K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43373159 12.BIRCH算法。BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43532111 13.AdaBoost算法。AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43635115 14.GSP算法。GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43699083 15.PreFixSpan算法。PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43766253 16.CBA(基于关联规则分类)算法。CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43818787 17.RoughSets(粗糙集)算法。粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43876001 18.gSpan算法。gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。 详细介绍链接：http://blog.csdn.net/androidlushangderen/article/details/43924273]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p><span style="font-size:14px;color:#333333;"><strong>本文所有涉及到的数据挖掘代码的都放在了我的github上了。</strong></span></p>
<p><span style="font-size:14px;color:#333333;"><strong><span style="color:rgb(102,102,102);font-family:Arial;font-size:14px;line-height:24px;text-indent:28px;">地址链接:&nbsp;<a href="https://github.com/linyiqun/DataMiningAlgorithm" rel="nofollow" data-token="5cf511d039bda90a9a3f7e7e3bedd6fe">https://github.com/linyiqun/DataMiningAlgorithm</a></span></strong></span></p>
<p><span style="font-size:14px;color:#333333;"><strong>大概花了将近<span style="font-family:Consolas;">2</span><span style="font-family:'宋体';">个月的时间，自己把</span><span style="font-family:Consolas;">18</span><span style="font-family:'宋体';">大数据挖掘的经典算法进行了学习并且进行了代码实现，涉及到了决策分类，聚类，链接挖掘，关联挖掘，模式挖掘等等方面。也算是对数据挖掘领域的小小入门了吧。下面就做个小小的总结，后面都是我自己相应算法的博文链接，希望能够帮助大家学习。</span></strong></span></p>
<p><span style="font-size:14px;color:#333333;">1.C4.5<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">C4.5</span><span style="font-family:'宋体';">算法与</span><span style="font-family:Consolas;">ID3</span><span style="font-family:'宋体';">算法一样，都是数学分类算法，</span><span style="font-family:Consolas;">C4.5</span><span style="font-family:'宋体';">算法是</span><span style="font-family:Consolas;">ID3</span><span style="font-family:'宋体';">算法的一个改进。</span><span style="font-family:Consolas;">ID3</span><span style="font-family:'宋体';">算法采用信息增益进行决策判断，而</span><span style="font-family:Consolas;">C4.5</span><span style="font-family:'宋体';">采用的是增益率。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42395865" rel="nofollow" data-token="4ef8cbeb15afe69e8948134b2fa0d242"><strong>http://blog.csdn.net/androidlushangderen/article/details/42395865</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">2.CART<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">CART</span><span style="font-family:'宋体';">算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/42558235" rel="nofollow" data-token="1f4d01181afe1a5568f39a1a72251a0c">http://blog.csdn.net/androidlushangderen/article/details/42558235</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">3.KNN(K<span style="font-family:'宋体';">最近邻</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里</span><span style="font-family:Consolas;">,</span><span style="font-family:'宋体';">有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/42613011" rel="nofollow" data-token="551ac543a216b74b8fe61b3b74979b8a">http://blog.csdn.net/androidlushangderen/article/details/42613011</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">4.Naive&nbsp;Bayes(<span style="font-family:'宋体';">朴素贝叶斯</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。</span></span></p>
<p><span style="color:rgb(51,51,51);font-size:14px;">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42680161" rel="nofollow" data-token="16e425a01dc1630c13c8a53aef4cf127"><strong>http://blog.csdn.net/androidlushangderen/article/details/42680161</strong></a></span></p>
<p><span style="font-size:14px;color:#333333;">5.SVM(<span style="font-family:'宋体';">支持向量机</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/42780439" rel="nofollow" data-token="53d1b9a67e345ce078495b883c1b0e36">http://blog.csdn.net/androidlushangderen/article/details/42780439</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">6.EM(<span style="font-family:'宋体';">期望最大化</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。期望最大化算法，可以拆分为</span><span style="font-family:Consolas;">2</span><span style="font-family:'宋体';">个算法，</span><span style="font-family:Consolas;">1</span><span style="font-family:'宋体';">个</span><span style="font-family:Consolas;">E-Step</span><span style="font-family:'宋体';">期望化步骤</span><span style="font-family:Consolas;">,</span><span style="font-family:'宋体';">和</span><span style="font-family:Consolas;">1</span><span style="font-family:'宋体';">个</span><span style="font-family:Consolas;">M-Step</span><span style="font-family:'宋体';">最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42921789" rel="nofollow" data-token="468cd551556c8c4703bcdc988ed5022c"><strong>http://blog.csdn.net/androidlushangderen/article/details/42921789</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">7.Apriori<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">Apriori</span><span style="font-family:'宋体';">算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43059211" rel="nofollow" data-token="c0e052a8ed5a3dd3536e9ae6f3924f0b"><strong>http://blog.csdn.net/androidlushangderen/article/details/43059211</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">8.FP-Tree(<span style="font-family:'宋体';">频繁模式树</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。这个算法也有被称为</span><span style="font-family:Consolas;">FP-growth</span><span style="font-family:'宋体';">算法，这个算法克服了</span><span style="font-family:Consolas;">Apriori</span><span style="font-family:'宋体';">算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与</span><span style="font-family:Consolas;">Apriori</span><span style="font-family:'宋体';">算法一致。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43234309" rel="nofollow" data-token="71fc3d03d9f3ab7aff581f89bdffcc86"><strong>http://blog.csdn.net/androidlushangderen/article/details/43234309</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">9.PageRank(<span style="font-family:'宋体';">网页重要性</span><span style="font-family:Consolas;">/</span><span style="font-family:'宋体';">排名</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">PageRank</span><span style="font-family:'宋体';">算法最早产生于</span><span style="font-family:Consolas;">Google,</span><span style="font-family:'宋体';">核心思想是通过网页的入链数作为一个网页好快的判定标准，如果</span><span style="font-family:Consolas;">1</span><span style="font-family:'宋体';">个网页内部包含了多个指向外部的链接，则</span><span style="font-family:Consolas;">PR</span><span style="font-family:'宋体';">值将会被均分，</span><span style="font-family:Consolas;">PageRank</span><span style="font-family:'宋体';">算法也会遭到</span><span style="font-family:Consolas;">Link&nbsp;Span</span><span style="font-family:'宋体';">攻击。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" rel="nofollow" data-token="e9524d5098a800f5d9f19585a620b537"><strong>http://blog.csdn.net/androidlushangderen/article/details/43311943</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">10.HITS<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">HITS</span><span style="font-family:'宋体';">算法是另外一个链接算法，部分原理与</span><span style="font-family:Consolas;">PageRank</span><span style="font-family:'宋体';">算法是比较相似的，</span><span style="font-family:Consolas;">HITS</span><span style="font-family:'宋体';">算法引入了权威值和中心值的概念，</span><span style="font-family:Consolas;">HITS</span><span style="font-family:'宋体';">算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" rel="nofollow" data-token="e9524d5098a800f5d9f19585a620b537"><strong>http://blog.csdn.net/androidlushangderen/article/details/43311943</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">11.K-Means(K<span style="font-family:'宋体';">均值</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">K-Means</span><span style="font-family:'宋体';">算法是聚类算法，</span><span style="font-family:Consolas;">k</span><span style="font-family:'宋体';">在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定</span><span style="font-family:Consolas;">k</span><span style="font-family:'宋体';">个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43373159" rel="nofollow" data-token="6eadd553c4e1665853a80b6b7bf851d8"><strong>http://blog.csdn.net/androidlushangderen/article/details/43373159</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">12.BIRCH<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">BIRCH</span><span style="font-family:'宋体';">算法利用构建</span><span style="font-family:Consolas;">CF</span><span style="font-family:'宋体';">聚类特征树作为算法的核心，通过树的形式，</span><span style="font-family:Consolas;">BIRCH</span><span style="font-family:'宋体';">算法扫描数据库，在内存中建立一棵初始的</span><span style="font-family:Consolas;">CF-</span><span style="font-family:'宋体';">树，可以看做数据的多层压缩。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43532111" rel="nofollow" data-token="f31c35717af79bed13b6bd2a17215d58"><strong>http://blog.csdn.net/androidlushangderen/article/details/43532111</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">13.AdaBoost<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">AdaBoost</span><span style="font-family:'宋体';">算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/43635115" rel="nofollow" data-token="067a01301427786adf3fcb944d5fb63d">http://blog.csdn.net/androidlushangderen/article/details/43635115</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">14.GSP<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">GSP</span><span style="font-family:'宋体';">算法是序列模式挖掘算法。</span><span style="font-family:Consolas;">GSP</span><span style="font-family:'宋体';">算法也是</span><span style="font-family:Consolas;">Apriori</span><span style="font-family:'宋体';">类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43699083" rel="nofollow" data-token="f161e407f3eedb34944df37e9b8346b0"><strong>http://blog.csdn.net/androidlushangderen/article/details/43699083</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">15.PreFixSpan<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">PreFixSpan</span><span style="font-family:'宋体';">算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/43766253" rel="nofollow" data-token="9579185fd5d5d3d51404847fc04c1096">http://blog.csdn.net/androidlushangderen/article/details/43766253</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">16.CBA(<span style="font-family:'宋体';">基于关联规则分类</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">CBA</span><span style="font-family:'宋体';">算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43818787" rel="nofollow" data-token="c228da78d775f77c38000872ba522b7c"><strong>http://blog.csdn.net/androidlushangderen/article/details/43818787</strong></a></span></span></p>
<p><span style="font-size:14px;color:#333333;">17.RoughSets(<span style="font-family:'宋体';">粗糙集</span><span style="font-family:Consolas;">)</span><span style="font-family:'宋体';">算法。粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/43876001" rel="nofollow" data-token="b4323b26332616186f7fce2adddf7cb4">http://blog.csdn.net/androidlushangderen/article/details/43876001</a></strong></span></span></p>
<p><span style="font-size:14px;color:#333333;">18.gSpan<span style="font-family:'宋体';">算法。</span><span style="font-family:Consolas;">gSpan</span><span style="font-family:'宋体';">算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。</span><span style="font-family:Consolas;">gSpan</span><span style="font-family:'宋体';">算法用到了</span><span style="font-family:Consolas;">DFS</span><span style="font-family:'宋体';">编码，和</span><span style="font-family:Consolas;">Edge</span><span style="font-family:'宋体';">五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。</span></span></p>
<p><span style="font-size:14px;color:#333333;"><span style="font-family:'宋体';">详细介绍链接：<strong><a href="http://blog.csdn.net/androidlushangderen/article/details/43924273" rel="nofollow" data-token="08f74a9eaa479660a3b46a251380d631">http://blog.csdn.net/androidlushangderen/article/details/43924273</a></strong></span></span></p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>C++图形边缘检测与区域提取</title>
		<link>https://uzzz.org/article/3210.html</link>
				<pubDate>Sun, 21 Jul 2013 02:42:52 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3210.html</guid>
				<description><![CDATA[边缘检索与区域提取是我们的课程设计的一个课题。看到这个课题感到十分新颖，因为以前从未接触过这方面的知识。而且由于课程作业要求的语言是c++,所以选择了 c++ 的一个界面类函数库easyX 下载可见官网 http://www.easyx.cn/ 我们将这个课题分为两部分，一是边缘检测，一是区域提取。 关于边缘检测：图像的边缘形成的原因是图像的灰度在某一区域的突然变化使得人眼才有了识别轮廓的功能。所以对于计算机识别边缘我们也可以用数学的方法定量的找出图像中灰度阶跃不连续或是线条不连续的地方，比如说一阶导数的极值点或二阶导数的零点的方法找到边缘。（图片摘自百度）。 [img]http://dl2.iteye.com/upload/attachment/0086/8785/e404332a-a703-3f11-a121-6dce248d25c6.png[/img] 当我们继续往下学时，越来越多的概念涌了出来，各种算子、幅度、差分、阈值、卷积运算。这对我这种数学渣渣的确是一种考验。其实我们没必要将边缘检索的数学推导都看懂。我们只要了解它的基本原理后，在运用它的结论就足以达到我们的目的。 我们总结了一下：什么Prewitt算子、Sobel算子，都是对灰度图片的一个变换，我们称这个变换为卷积模板变换，模板变换后，边缘就会被检索出来。首先让我们必须了解什么叫做卷积模板变换。这个博客说的很清楚，大家可以看看。 http://www.cnblogs.com/a-toad/archive/2008/10/24/1318921.html 所以我们根据这个运算规则，将它封装成一个方法，代码及注释如下 //模板操作，包括图像边缘的检测，图像的平滑都会用到这个函数/*参数的意义* img 指向图像的指针* tempWidth tempHeight 模板的宽高* tempX tempY 模板的中心的x y 坐标* temp 指向模板数组的指针 tempCoef 模板的系数* img2 为转化后的照片*/bool templateChange(IMAGE *img,int tempWidth,int tempHeight,int tempX,int tempY,float *temp,float tempCoef,IMAGE *img2){ long imgWidth = img-&#62;getwidth(); long imgHeight = img-&#62;getheight(); //得到原图的内容 DWORD *p = GetImageBuffer(img); (*img2).Resize(imgWidth,imgHeight); DWORD *p2 = GetImageBuffer(img2); //用于暂存模板值 float result; int endResult; for (long i=tempY;i&#60;imgHeight-tempHeight+tempY;i++){ for (long j=tempX;j&#60;imgWidth-tempWidth+tempX;j++){ result=0; //计算模板 for (int k=0;k&#60;tempHeight;k++){ for (int l=0;l&#60;tempWidth;l++){ //逻辑表达式较复杂（横坐标 i-tempy+k 纵坐标 j-tempx+1） //得到灰度（RGB相同） int z=GetRValue(p[imgWidth*(i+tempY-k)+j-tempX+l]); result +=z*temp[k*tempWidth+l]; } } result *=tempCoef; endResult =abs((int)result); if (endResult&#62;255){ endResult=255; } p2[i*imgWidth+j]=RGB(endResult,endResult,endResult); } } return true;} 了解了这个模板运算，我们反过头来再看各种算子 Sobel算子： [img]http://dl2.iteye.com/upload/attachment/0087/2255/68db3872-c150-3b2b-9b55-33d41bfdb638.png[/img] 进行的横竖两个方向的模板运算后，遍历整个图片取相同像素点模板运算的最大值。 Prewitt算子： [img]http://dl2.iteye.com/upload/attachment/0087/2257/c7a1e5b5-45bf-3189-af75-2dd5a8e991e5.png[/img] 同Sobel算子，进行的横竖两个方向的模板运算后，遍历整个图片取相同像素点模板运算的最大值。 给出了算法，写程序就很容易了。这里只展示prewitt算子的代码： void GraphicCut(IMAGE *img){ IMAGE img1,img2; float temp1[9]={1,0,-1,1,0,-1,1,0,-1}; float tempCoef1=1; templateChange(img,3,3,1,1,temp1,tempCoef1,&#38;img1); float temp2[9]={-1,-1,-1,0,0,0,1,1,1}; float tempCoef2=1; templateChange(img,3,3,1,1,temp2,tempCoef2,&#38;img2); DWORD *p = GetImageBuffer(img); DWORD *p1 = GetImageBuffer(&#38;img1); DWORD *p2 = GetImageBuffer(&#38;img2); for (long i=0;i&#60;img-&#62;getheight();i++) for (long j=0;j&#60;img-&#62;getwidth();j++) if (p1[i*img-&#62;getwidth()+j]&#60;p2[i*img-&#62;getwidth()+j]){ p[i*img-&#62;getwidth()+j]=p2[i*img-&#62;getwidth()+j]; }else{ p[i*img-&#62;getwidth()+j]=p1[i*img-&#62;getwidth()+j]; }} 效果图如下： [img]http://dl2.iteye.com/upload/attachment/0087/2259/4f561acb-b049-3a46-97f8-bff7f7a7e6a2.jpg[/img] [img]http://dl2.iteye.com/upload/attachment/0087/2261/ed21cff1-2ed1-313a-9789-a2abb5cdba62.png[/img] 啃完了边缘检索这块硬骨头后，我们又开始考虑区域要怎么提取。我们最初的想法是做一个类似于搜索的算法，遍历某个区域中的所有点，将这个区域中的像素点提取出来保存到另一幅图片中，就完成了区域提取。 我们最开始想到的是深度搜索，但对于一张500*500的图片来说，这种搜索对时间和空间的消耗都是特别大的，搞不好还会栈溢出。所以我们马上丢弃了这个想法。另一种搜索方法就是广度搜索了，理论上是可行的，所以我们决定试试这种算法。（其实网上有一些经过优化过的搜索算法，如扫描线算法）。 代码如下： void graphicsFill(IMAGE *img1,IMAGE *img2,IMAGE *img3,int mouseX,int mouseY){ long imgWidth = img1-&#62;getwidth(); long imgHeight = img1-&#62;getheight(); DWORD *p1 = GetImageBuffer(img1); DWORD *p2 = GetImageBuffer(img2); DWORD *p3 = GetImageBuffer(img3); list&#60;Point&#62;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
   边缘检索与区域提取是我们的课程设计的一个课题。看到这个课题感到十分新颖，因为以前从未接触过这方面的知识。而且由于课程作业要求的语言是c++,所以选择了 c++ 的一个界面类函数库easyX 下载可见官网 http://www.easyx.cn/<br />
  <br /> 我们将这个课题分为两部分，一是边缘检测，一是区域提取。<br />
  <br /> 关于边缘检测：图像的边缘形成的原因是图像的灰度在某一区域的突然变化使得人眼才有了识别轮廓的功能。所以对于计算机识别边缘我们也可以用数学的方法定量的找出图像中灰度阶跃不连续或是线条不连续的地方，比如说一阶导数的极值点或二阶导数的零点的方法找到边缘。（图片摘自百度）。</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0086/8785/e404332a-a703-3f11-a121-6dce248d25c6.png[/img]</p>
<p>当我们继续往下学时，越来越多的概念涌了出来，各种算子、幅度、差分、阈值、卷积运算。这对我这种数学渣渣的确是一种考验。其实我们没必要将边缘检索的数学推导都看懂。我们只要了解它的基本原理后，在运用它的结论就足以达到我们的目的。<br />
  <br />我们总结了一下：什么Prewitt算子、Sobel算子，都是对灰度图片的一个变换，我们称这个变换为卷积模板变换，模板变换后，边缘就会被检索出来。首先让我们必须了解什么叫做卷积模板变换。这个博客说的很清楚，大家可以看看。<br />
  <br />http://www.cnblogs.com/a-toad/archive/2008/10/24/1318921.html</p>
<p>所以我们根据这个运算规则，将它封装成一个方法，代码及注释如下<br />
  </p>
<pre><code class="language-c++"><br>//模板操作，包括图像边缘的检测，图像的平滑都会用到这个函数<br>/*参数的意义<br>* img 指向图像的指针<br>* tempWidth tempHeight 模板的宽高<br>* tempX tempY 模板的中心的x y 坐标<br>* temp 指向模板数组的指针 tempCoef 模板的系数<br>* img2 为转化后的照片<br>*/<br>bool templateChange(IMAGE *img,int tempWidth,int tempHeight,int tempX,int tempY,float *temp,float tempCoef,IMAGE *img2){<br>	long imgWidth = img-&gt;getwidth();<br>	long imgHeight = img-&gt;getheight();<br>	//得到原图的内容<br>	DWORD *p = GetImageBuffer(img);<br>	(*img2).Resize(imgWidth,imgHeight);<br>	DWORD *p2 = GetImageBuffer(img2);<br>	//用于暂存模板值<br>	float result;<br>	int endResult;<br>	for (long i=tempY;i&lt;imgHeight-tempHeight+tempY;i++){<br>		for (long j=tempX;j&lt;imgWidth-tempWidth+tempX;j++){<br>		    result=0;<br>			//计算模板<br>			for (int k=0;k&lt;tempHeight;k++){<br>				for (int l=0;l&lt;tempWidth;l++){<br>                      //逻辑表达式较复杂（横坐标 i-tempy+k 纵坐标 j-tempx+1）<br>					//得到灰度（RGB相同）<br>					int z=GetRValue(p[imgWidth*(i+tempY-k)+j-tempX+l]);<br>				    result +=z*temp[k*tempWidth+l];<br>				}<br>			}<br>			result *=tempCoef;<br>			endResult =abs((int)result);<br>			if (endResult&gt;255){<br>			    endResult=255;<br>			}<br>			p2[i*imgWidth+j]=RGB(endResult,endResult,endResult);<br>		}<br>	}<br>	return true;<br>}<br></code></pre>
<p>了解了这个模板运算，我们反过头来再看各种算子</p>
<p>Sobel算子：</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2255/68db3872-c150-3b2b-9b55-33d41bfdb638.png[/img]</p>
<p>进行的横竖两个方向的模板运算后，遍历整个图片取相同像素点模板运算的最大值。<br />
  <br />Prewitt算子：</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2257/c7a1e5b5-45bf-3189-af75-2dd5a8e991e5.png[/img]</p>
<p>同Sobel算子，进行的横竖两个方向的模板运算后，遍历整个图片取相同像素点模板运算的最大值。</p>
<p>给出了算法，写程序就很容易了。这里只展示prewitt算子的代码：<br />
  </p>
<pre><code class="language-c++"><br>void GraphicCut(IMAGE *img){<br>	IMAGE img1,img2;<br>	float temp1[9]={1,0,-1,1,0,-1,1,0,-1};<br>	float tempCoef1=1;<br>	templateChange(img,3,3,1,1,temp1,tempCoef1,&amp;img1);<br>	float temp2[9]={-1,-1,-1,0,0,0,1,1,1};<br>	float tempCoef2=1;<br>	templateChange(img,3,3,1,1,temp2,tempCoef2,&amp;img2);<br>	DWORD *p = GetImageBuffer(img);<br>	DWORD *p1 = GetImageBuffer(&amp;img1);<br>	DWORD *p2 = GetImageBuffer(&amp;img2);<br>	for (long i=0;i&lt;img-&gt;getheight();i++)<br>		for (long j=0;j&lt;img-&gt;getwidth();j++)<br>			if (p1[i*img-&gt;getwidth()+j]&lt;p2[i*img-&gt;getwidth()+j]){<br>			   p[i*img-&gt;getwidth()+j]=p2[i*img-&gt;getwidth()+j];<br>			}else{<br>			   p[i*img-&gt;getwidth()+j]=p1[i*img-&gt;getwidth()+j];<br>			}<br>}<br></code></pre>
<p>效果图如下：</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2259/4f561acb-b049-3a46-97f8-bff7f7a7e6a2.jpg[/img]</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2261/ed21cff1-2ed1-313a-9789-a2abb5cdba62.png[/img]</p>
<p>啃完了边缘检索这块硬骨头后，我们又开始考虑区域要怎么提取。我们最初的想法是做一个类似于搜索的算法，遍历某个区域中的所有点，将这个区域中的像素点提取出来保存到另一幅图片中，就完成了区域提取。<br />
  <br />我们最开始想到的是深度搜索，但对于一张500*500的图片来说，这种搜索对时间和空间的消耗都是特别大的，搞不好还会栈溢出。所以我们马上丢弃了这个想法。另一种搜索方法就是广度搜索了，理论上是可行的，所以我们决定试试这种算法。（其实网上有一些经过优化过的搜索算法，如扫描线算法）。<br />
  <br />代码如下：<br />
  </p>
<pre><code class="language-c++"><br>void graphicsFill(IMAGE *img1,IMAGE *img2,IMAGE *img3,int mouseX,int mouseY){<br>	long imgWidth = img1-&gt;getwidth();<br>	long imgHeight = img1-&gt;getheight();<br>	DWORD *p1 = GetImageBuffer(img1);<br>	DWORD *p2 = GetImageBuffer(img2);<br>	DWORD *p3 = GetImageBuffer(img3);<br>	list&lt;Point&gt; stk;<br>	Point point;<br>	point.x = mouseX;<br>	point.y = mouseY;<br>	stk.push_back(point);<br>	int a[]={0,1,1,1,0,-1,-1,-1};<br>	int b[]={1,1,0,-1,-1,-1,0,1};<br>	while (!stk.empty()){<br>		Point pt;<br>		//获取链表头元素 ，并将其弹出<br>		pt=stk.front();  stk.pop_front();<br>		long y=pt.y;<br>		long x=pt.x;<br>		long z;<br>		int x1,y1;<br>		for (int i=0;i&lt;8;i++){<br>		    x1=x+a[i]; y1=y+b[i];<br>			z=abs(long(GetRValue(p1[y*imgWidth+x])-GetRValue(p1[y1*imgWidth+x1])));<br>			if (p2[y1*imgWidth+x1]!=p3[y1*imgWidth+x1]&amp;&amp;z&lt;4){<br>			   p3[y1*imgWidth+x1]=p2[y1*imgWidth+x1];<br>			   Point pt;<br>			   pt.x=x1; pt.y=y1;<br>			   stk.push_back(pt);<br>			}<br>		}<br>	}<br>}<br></code></pre>
<p>提取效果图片如下：</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2259/4f561acb-b049-3a46-97f8-bff7f7a7e6a2.jpg[/img]</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2263/4c58560b-7d0c-3575-846d-e4dbfb064e20.png[/img]</p>
<p>[img]http://dl2.iteye.com/upload/attachment/0087/2267/d193023a-4474-3824-aad3-e9909e01adbb.png[/img]</p>
<p>整的来说，算法的效率还算高。但的确有更好的算法可以去解决这个问题，更好的算法就等读者自己去研究发现了。
 </div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>中国移动互联网投资饕餮盛宴 无线增值业务居首</title>
		<link>https://uzzz.org/article/2664.html</link>
				<pubDate>Wed, 11 Jan 2012 01:19:09 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[算法]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2664.html</guid>
				<description><![CDATA[手机终端的快速普及、通信网络设施建设日臻完善、各类手机应用几何级数出现，成为中国移动互联网产业快速发展的基础及推动力量。当然，在产业自我推动的背后，产业资本与VC/PE的多向关注也是其发展的幕后推手。2011中国移动移动互联网投资创2005年来各年投资新高，这是一个积极的信号，当然也暗藏不安。 　　产业资本与VC/PE共舞，投资转向移动互联网 　　首先，从产业资本的表现来看，2010年以来，以盛大、联想等为代表的产业资金快速转向中国移动互联网行业。2010年2月，盛大将投资部门升级为盛大资本，未来将专注于投资移动互联网领域；2010年11月，联想成立天使基金投资移动互联网，首期投入1亿元；2010年11月，网龙联合IDG成立移动互联网基金；2010年12月，新浪成立转向资金投资移动互联网。种种事件背后标识行业领军企业对于移动互联网产业未来崛起的初步判断是一致的，对于移动互联网产业而言消息利好。 　　其次，从VC/PE投资表现情况来看，“春江水暖鸭先知”。2005-2011年上半年，中国移动互联网行业投资事件158起，其中已经披露投资金额的案例有128起，披露投资金额为11.19亿美元，平均单笔投资金额为874万美元。2005-2011年上半年投资情况来看，2011年上半年，中国移动互联网已经披露的投资案例数量为33起，其中，披露金额的投资案例数为25起，投资金额总额为3.20亿美元，平均单笔投资金额为1278万美元。毫无疑问，自2009年移动互联网市场投资回暖以来，2011年中国的移动互联网投资必然创历年新高。 　　2005年-2011年上半年，中国移动互联网各细分投资领域中，从披露的投资案例数情况来看，无线增值业务及其相关领域披露的投资案例数位居榜首，达31起，占总投资案例总数的19.62%。其次，手机游戏领域投资案例数也较多，达30起，占总投资案例总数的18.99%。此外，无线搜索、无线广告、手机客户端软件，手机支付等领域也是投资方关注的热点领域。清科研究中心分析认为，未来，手机游戏、无线广告、手机支付、手机视频等领域均值得资本市场关注。 　　中国移动互联网快速发展背后的三大推手 　　清科研究中心分析认为，中国移动互联网产业发展背后存在三大推手。 　　其一，开放共赢的移动互联网时代为中小企业参与者提供有益资源。这种开放主要表现为三点：一是，电信运营商转型时代，进一步向产业参与者敞开心扉，网络通路逐渐顺畅；二是，以腾讯、百度、UCWEB、盛大等为代表的企业相继开放应用入口；三是，操作系统底层开放。 　　其二，移动互联网用户使用成本逐渐降低，主要表现在智能手机终端价位降低、流量资费下调、获取应用的时间成本减少。 　　其三，移动互联网企业参与成本不断降低，从利用开放操作系统的应用开发，到利用开放平台的整合营销推广，再到交易成本的降低，尤其成为催生中小企业快速发展的沃土。 　　中国移动互联网多项应用“钱景”广阔，但用户基数并非完全代表变现能力 　　清科研究中心分析认为，手机游戏、移动支付&#38;二维码、LBS、移动社交应用、移动电子商务、无线营销等细分领域均具有较强的投资价值。此外，与先进技术相关的应用及移动互联网化解决方案提供商也具有较好的投资价值。 　　不过，面对异常活跃的市场而言，我们仍需警惕数据背后的谎言与无奈。目前而言，中国移动互联网企业是否具有投资价值的主要评判标准就是用户基数情况，但是未来的某一天，也许我们会发现，用户基数并非代表企业的变现能力，尤其在移动互联网领域更甚。]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p align="left">手机终端的快速普及、通信网络设施建设日臻完善、各类手机应用几何级数出现，成为中国移动<a href="http://news.pedaily.cn/industry/%E4%BA%92%E8%81%94%E7%BD%91/" rel="nofollow" data-token="d8c8459ce9a74929a2459bee1b1896c6">互联网</a>产业快速发展的基础及推动力量。当然，在产业自我推动的背后，产业资本与VC/PE的多向关注也是其发展的幕后推手。2011中国移动移动<a href="http://news.pedaily.cn/industry/%E4%BA%92%E8%81%94%E7%BD%91/" rel="nofollow" data-token="d8c8459ce9a74929a2459bee1b1896c6">互联网</a>投资创2005年来各年投资新高，这是一个积极的信号，当然也暗藏不安。</p>
<p><strong>　　产业资本与VC/PE共舞，投资转向移动互联网</strong></p>
<p>　　首先，从产业资本的表现来看，2010年以来，以<a href="http://zdb.pedaily.cn/Enterprise/%E7%9B%9B%E5%A4%A7/" rel="nofollow" data-token="606f839659eb0510bbf4562d344b55f9">盛大</a>、联想等为代表的产业资金快速转向中国移动互联网行业。2010年2月，<a href="http://zdb.pedaily.cn/Enterprise/%E7%9B%9B%E5%A4%A7/" rel="nofollow" data-token="606f839659eb0510bbf4562d344b55f9">盛大</a>将投资部门升级为盛大资本，未来将专注于投资移动互联网领域；2010年11月，联想成立天使基金投资移动互联网，首期投入1亿元；2010年11月，<a href="http://zdb.pedaily.cn/Enterprise/%E7%BD%91%E9%BE%99/" rel="nofollow" data-token="5fe0ddaf5dbbd26b78c4901eeaf03c65">网龙</a>联合<a href="http://zdb.pedaily.cn/company/IDG%E8%B5%84%E6%9C%AC/" rel="nofollow" data-token="d94104d85b90d0b0cedf2159abf6bbdd">IDG</a>成立移动互联网基金；2010年12月，<a href="http://zdb.pedaily.cn/Enterprise/%E6%96%B0%E6%B5%AA/" rel="nofollow" data-token="907284ca3571c2e30c124d5ede346e1e">新浪</a>成立转向资金投资移动互联网。种种事件背后标识行业领军企业对于移动互联网产业未来崛起的初步判断是一致的，对于移动互联网产业而言消息利好。</p>
<p>　　其次，从VC/PE投资表现情况来看，“春江水暖鸭先知”。2005-2011年上半年，中国移动互联网行业投资事件158起，其中已经披露投资金额的案例有128起，披露投资金额为11.19亿美元，平均单笔投资金额为874万美元。2005-2011年上半年投资情况来看，2011年上半年，中国移动互联网已经披露的投资案例数量为33起，其中，披露金额的投资案例数为25起，投资金额总额为3.20亿美元，平均单笔投资金额为1278万美元。毫无疑问，自2009年移动互联网市场投资回暖以来，2011年中国的移动互联网投资必然创历年新高。</p>
<p>　　2005年-2011年上半年，中国移动互联网各细分投资领域中，从披露的投资案例数情况来看，无线增值业务及其相关领域披露的投资案例数位居榜首，达31起，占总投资案例总数的19.62%。其次，<a href="http://news.pedaily.cn/industry/%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F/" rel="nofollow" data-token="f9e1f00f2b5df0b94b17e4e2721072c8">手机游戏</a>领域投资案例数也较多，达30起，占总投资案例总数的18.99%。此外，无线<a href="http://news.pedaily.cn/industry/%E6%90%9C%E7%B4%A2/" rel="nofollow" data-token="ce0bbd775eae6f29d64a56c2cfa780f2">搜索</a>、无线广告、手机客户端<a href="http://news.pedaily.cn/industry/%E8%BD%AF%E4%BB%B6/" rel="nofollow" data-token="166ce34f1c0d787350880f8d5c5588ab">软件</a>，手机支付等领域也是投资方关注的热点领域。<a href="http://research.pedaily.cn/" rel="nofollow" data-token="519e1da0675030be8eae0010db76d79e">清科研究中心</a>分析认为，未来，<a href="http://news.pedaily.cn/industry/%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F/" rel="nofollow" data-token="f9e1f00f2b5df0b94b17e4e2721072c8">手机游戏</a>、无线广告、手机支付、手机视频等领域均值得资本市场关注。</p>
<p align="center"><img alt="中国移动互联网投资饕餮盛宴 无线增值业务居首" src="http://pic.pedaily.cn/201112/20111205@3885.jpg"></p>
<p><strong>　　中国移动互联网快速发展背后的三大推手</strong></p>
<p>　　<a href="http://research.pedaily.cn/" rel="nofollow" data-token="519e1da0675030be8eae0010db76d79e">清科研究中心</a>分析认为，中国移动互联网产业发展背后存在三大推手。</p>
<p>　　其一，开放共赢的移动互联网时代为中小企业参与者提供有益资源。这种开放主要表现为三点：一是，<a href="http://news.pedaily.cn/industry/%E7%94%B5%E4%BF%A1%E8%BF%90%E8%90%A5/" rel="nofollow" data-token="22fc5263d9b8d8a5b69ae1001cfd38a8">电信运营</a>商转型时代，进一步向产业参与者敞开心扉，网络通路逐渐顺畅；二是，以<a href="http://zdb.pedaily.cn/Enterprise/%E8%85%BE%E8%AE%AF/" rel="nofollow" data-token="13004d725b173a2fda47310b9017d971">腾讯</a>、百度、UCWEB、盛大等为代表的企业相继开放应用入口；三是，操作系统底层开放。</p>
<p>　　其二，移动互联网用户使用成本逐渐降低，主要表现在智能手机终端价位降低、流量资费下调、获取应用的时间成本减少。</p>
<p>　　其三，移动互联网企业参与成本不断降低，从利用开放操作系统的应用开发，到利用开放平台的整合营销推广，再到交易成本的降低，尤其成为催生中小企业快速发展的沃土。</p>
<p>　　中国移动互联网多项应用“钱景”广阔，但用户基数并非完全代表变现能力</p>
<p>　　<a href="http://research.pedaily.cn/" rel="nofollow" data-token="519e1da0675030be8eae0010db76d79e">清科研究</a>中心分析认为，手机游戏、移动支付&amp;二维码、LBS、移动社交应用、移动<a href="http://news.pedaily.cn/industry/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/" rel="nofollow" data-token="42882923c0e308f4e0ac8d7c291dd0ba">电子商务</a>、<a href="http://news.pedaily.cn/industry/%E6%97%A0%E7%BA%BF%E8%90%A5%E9%94%80/" rel="nofollow" data-token="50f95fdeec4dc51e9666fda864a49330">无线营销</a>等细分领域均具有较强的投资价值。此外，与先进技术相关的应用及移动互联网化解决方案提供商也具有较好的投资价值。</p>
<p>　　不过，面对异常活跃的市场而言，我们仍需警惕数据背后的谎言与无奈。目前而言，中国移动互联网企业是否具有投资价值的主要评判标准就是用户基数情况，但是未来的某一天，也许我们会发现，用户基数并非代表企业的变现能力，尤其在移动互联网领域更甚。</p>
<div class="m_t_10 m_b_10"></div>
<div class="clear"></div>
</p></div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
