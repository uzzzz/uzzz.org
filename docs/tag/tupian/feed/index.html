<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>图片 &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/tag/tupian/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Sat, 17 Sep 2016 08:57:34 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>图片 &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Win10白色图标制作及替换</title>
		<link>https://uzzz.org/article/3362.html</link>
				<pubDate>Sat, 17 Sep 2016 08:57:34 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[开发]]></category>
		<category><![CDATA[图片]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/3362.html</guid>
				<description><![CDATA[win10白色图标制作： 一、软件准备IcoFX：提取图标、生成图标。 Photoshop：修改编辑图标。 二、制作步骤1、 提取图标打开IcoFX，直接在桌面上选择快捷方式，拉拽以icoFX打开。 打开后提取图标 打开图标后保存为：png格式 2，然后使用ps打开，开始编辑 先建立一块透明背景，256&#215;256就够了，然后打开图片，将需要保留的白色部分保留，删除其他部分，或者根据自己的需要自定义 1，点击魔术棒，选择白色区域以外的地方，删除 删除不需要的地方，保留需要的地方，然后使用白色前景色，再用油漆桶将需要的地方涂为白色 &#160; &#160; &#160; &#160; &#160; 弄好之后就是上面的那张图片，然后保存，做好的图片在次使用icoFX打开，选择创建一个图标 &#160; &#160; 然后保存为图标之后就可以开始替换了。 替换图标： 替换图标的方式有多种，我只说两种我用的。 1，图标可以放在统一的地方，也可以放在程序安装路径 桌面快捷方式右键&#8212;&#8212;属性&#8212;&#8212;&#8211;打开文件位置&#8212;&#8212;-然后将图标移动到此处&#8212;&#8212;-在回去属性页面点击更换图标&#8212;&#8212;&#8211;浏览找到图标位置&#8212;-替换成功 2.用exe资源查看器（我用的Restorator 2007）打开程序exe文件，然后找到图标，用制作的白色图标替换，然后保存，软件会自动帮助备份 注意：exe替换成功后有些软件会将通知栏图标也变为白色，但有些软件不会，exe替换成功后需要清理一下 Windows通知区域图标历史记录 在网上找到的方法是下面这两种：第一种方法，手工修改注册表：1、按“Win R”组合键，输入“regedit”打开注册表编辑器，然后打开如下键值：&#160;　　HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify　　在右边你可以看到两个键值：IconStreams和PastIconsStream，将它们的值删除。2、然后调出任务管理器将进程“explorer.exe”终止，再在任务管理器中点击“文件——新建任务”，输入“explorer”，回车，以此重新启动该系统进程。(或者重新启动计算机）。现在再来查看一下通知区域的图标，过期的图标已经被成功清理了。第二种方法：用批处理文件清理Windows通知区域图标历史记录：第一种方法虽好，但是有点技术问题在其中，对于菜鸟们来说有点难度，有没有简单的方法？网上有人提供了一个BAT批处理小工具，专门用来清理Windows通知区域图标历史记录。这个BAT文件安全性高，不会造成系统损坏，适用于当前主流的Windows7\vista\XP系统，使用如图所示： bat清理我只在win7上用过，在win10上还没有测试 &#160;&#160;&#160; 批处理： @ ECHO OFF SET PROG=清理系统通知区域 （XP/WIN7/VISTA） COLOR 0a @ ECHO. @ ECHO. &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;说 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 明 @ ECHO. @ ECHO &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; @ ECHO. @ ECHO. &#160; &#160;WINDOWS 系统能在通知区域自动隐藏不活动的图标，这是个非常实用的功能。但是日积 @ ECHO.月累之下，通知区域的图标越来越多，有的是很久之前的图标，甚至该软件已经卸载。图标 @ ECHO.的增多不仅臃肿且看起来十分的不舒服。此批处理文件能帮你清理掉通知区域的历史图标。 @ ECHO. @ ECHO &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211; TITLE %PROG% PAUSE CLS @ ECHO. @ ECHO. &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;Step1：清理通知区域在注册表内的相关子项 &#160; @ ECHO. @ ECHO. ECHO 　　　 &#160; &#160; &#160; &#160; &#160; &#160;★★★　　 &#160; &#160; &#160; &#160;[1] WINDOWS XP　　　　 &#160; &#160; &#160; ★★★ ECHO 　　　 &#160; &#160; &#160; &#160; &#160; &#160;★★★　　 &#160; &#160; &#160; &#160;[2] WINDOWS 7 / VISTA　 &#160; &#160; &#160;★★★ @ ECHO. @ ECHO. SET /P CHOICE=　　　 &#160; &#160;请选择你当前的操作系统 (1/2) ，按回车键执行： IF /I &#8216;%CHOICE%&#8217;==&#8217;1&#8217; GOTO WINXP IF /I &#8216;%CHOICE%&#8217;==&#8217;2&#8217; GOTO WIN7 :WINXP REG DELETE &#8220;HKCU\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\EXPLORER\TRAYNOTIFY&#8221; /V ICONSTREAMS /F]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<p></p>
<h2>win10白色图标制作：</h2>
<p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">一、软件准备</span><br style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">IcoFX：提取图标、生成图标。</span></p>
<p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">Photoshop：修改编辑图标。<br /></span></p>
<p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">二、制作步骤</span><br style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">1、 提取图标</span><br style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">打开IcoFX，直接在桌面上选择快捷方式，拉拽以icoFX打开。</span><br /></span></p>
<p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170000309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br /></span></span></p>
<p><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;"><span style="color:rgb(51,51,51);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:24px;">打开后提取图标</span></span></p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170020606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>打开图标后保存为：png格式</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170026810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>2，然后使用ps打开，开始编辑</p>
<p>先建立一块透明背景，256&#215;256就够了，然后打开图片，将需要保留的白色部分保留，删除其他部分，或者根据自己的需要自定义</p>
<p>1，点击魔术棒，选择白色区域以外的地方，删除</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170033747?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>删除不需要的地方，保留需要的地方，然后使用白色前景色，再用油漆桶将需要的地方涂为白色</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170039028?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170043185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>弄好之后就是上面的那张图片，然后保存，做好的图片在次使用icoFX打开，选择创建一个图标</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170054700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">&nbsp; &nbsp;<img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170058935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>然后保存为图标之后就可以开始替换了。</p>
<p><img src="https://uzshare.com/_p?https://img-blog.csdn.net/20160917170103904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p></p>
<h2>替换图标：</h2>
<div>
   替换图标的方式有多种，我只说两种我用的。
  </div>
<div>
   
  </div>
<div>
   1，图标可以放在统一的地方，也可以放在程序安装路径
  </div>
<div>
   桌面快捷方式右键&#8212;&#8212;属性&#8212;&#8212;&#8211;打开文件位置&#8212;&#8212;-然后将图标移动到此处&#8212;&#8212;-在回去属性页面点击更换图标&#8212;&#8212;&#8211;浏览找到图标位置&#8212;-替换成功
  </div>
<div>
   2.用exe资源查看器（我用的Restorator 2007）打开程序exe文件，然后找到图标，用制作的白色图标替换，然后保存，软件会自动帮助备份
  </div>
<div>
   
  </div>
<div>
   <span style="color:#ff0000;">注意：</span>exe替换成功后有些软件会将通知栏图标也变为白色，但有些软件不会，exe替换成功后需要清理一下<br />
   <span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', Hei, Tahoma, SimHei, sans-serif;font-size:16px;"><strong>Windows通知区域图标历史记录</strong></span>
  </div>
<div>
   <span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', Hei, Tahoma, SimHei, sans-serif;font-size:16px;"><strong><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">在网上找到的方法是下面这两种：</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">第一种方法，手工修改注册表：</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">1、按“Win R”组合键，输入“regedit”打开注册表编辑器，然后打开如下键值：&nbsp;</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">　　HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">　　在右边你可以看到两个键值：IconStreams和PastIconsStream，将它们的值删除。</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">2、然后调出任务管理器将进程“explorer.exe”终止，再在任务管理器中点击“文件——新建任务”，输入“explorer”，回车，以此重新启动该系统进程。(或者重新启动计算机）。现在再来查看一下通知区域的图标，过期的图标已经被成功清理了。</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">第二种方法：用批处理文件清理Windows通知区域图标历史记录：</span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;">第一种方法虽好，但是有点技术问题在其中，对于菜鸟们来说有点难度，有没有简单的方法？网上有人提供了一个BAT批处理小工具，专门用来清理Windows通知区域图标历史记录。这个BAT文件安全性高，不会造成系统损坏，适用于当前主流的Windows7\vista\XP系统，使用如图所示：</span></strong></span>
  </div>
<div>
   <span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', Hei, Tahoma, SimHei, sans-serif;font-size:16px;"><strong>bat清理我只在win7上用过，在win10上还没有测试</strong></span>
  </div>
<div>
   <span style="color:rgb(68,68,68);"><strong><img id="aimg_1259360" src="http://fj.ikafan.com/attachment/forum/201106/14/125908lc1ca8z44clcpt0c.jpg.thumb.jpg" alt="">&nbsp;<span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"></span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><img id="aimg_1259361" src="http://fj.ikafan.com/attachment/forum/201106/14/125908n7jza9j53tsvkl9a.jpg.thumb.jpg" alt="">&nbsp;<span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"></span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><img id="aimg_1259362" src="http://fj.ikafan.com/attachment/forum/201106/14/125908qdl0q53o01oq0o0q.jpg.thumb.jpg" alt="">&nbsp;<span style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"></span><br style="color:rgb(68,68,68);font-family:'Microsoft Yahei', arial, helvetica, sans-serif;font-size:15px;line-height:22.5px;"><img id="aimg_1259354" src="http://fj.ikafan.com/attachment/forum/201106/14/125907u2s2m5zm2s75mct2.jpg.thumb.jpg" alt=""><br /></strong></span>
  </div>
<div>
   <span style="color:rgb(68,68,68);"><strong>批处理：</strong></span>
  </div>
<div>
   <span style="color:rgb(68,68,68);"><strong><br /> @ ECHO OFF<br /> SET PROG=清理系统通知区域 （XP/WIN7/VISTA）<br /> COLOR 0a<br /> @ ECHO.<br /> @ ECHO. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 明<br /> @ ECHO.<br /> @ ECHO &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br /> @ ECHO.<br /> @ ECHO. &nbsp; &nbsp;WINDOWS 系统能在通知区域自动隐藏不活动的图标，这是个非常实用的功能。但是日积<br /> @ ECHO.月累之下，通知区域的图标越来越多，有的是很久之前的图标，甚至该软件已经卸载。图标<br /> @ ECHO.的增多不仅臃肿且看起来十分的不舒服。此批处理文件能帮你清理掉通知区域的历史图标。<br /> @ ECHO.<br /> @ ECHO &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br /> TITLE %PROG%<br /> PAUSE<br /> CLS<br /> @ ECHO.<br /> @ ECHO. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Step1：清理通知区域在注册表内的相关子项 &nbsp;<br /> @ ECHO.<br /> @ ECHO.<br /> ECHO 　　　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;★★★　　 &nbsp; &nbsp; &nbsp; &nbsp;[1] WINDOWS XP　　　　 &nbsp; &nbsp; &nbsp; ★★★<br /> ECHO 　　　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;★★★　　 &nbsp; &nbsp; &nbsp; &nbsp;[2] WINDOWS 7 / VISTA　 &nbsp; &nbsp; &nbsp;★★★<br /> @ ECHO.<br /> @ ECHO.<br /> SET /P CHOICE=　　　 &nbsp; &nbsp;请选择你当前的操作系统 (1/2) ，按回车键执行：<br /> IF /I &#8216;%CHOICE%&#8217;==&#8217;1&#8217; GOTO WINXP<br /> IF /I &#8216;%CHOICE%&#8217;==&#8217;2&#8217; GOTO WIN7<br /> :WINXP<br /> REG DELETE &#8220;HKCU\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\EXPLORER\TRAYNOTIFY&#8221; /V ICONSTREAMS /F<br /> REG DELETE &#8220;HKCU\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\EXPLORER\TRAYNOTIFY&#8221; /V PASTICONSSTREAM /F<br /> PAUSE<br /> GOTO SUCCESS<br /> :WIN7<br /> REG DELETE &#8220;HKEY_CLASSES_ROOT\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\TRAYNOTIFY&#8221; /V ICONSTREAMS /F<br /> REG DELETE &#8220;HKEY_CLASSES_ROOT\LOCAL SETTINGS\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\TRAYNOTIFY&#8221; /V PASTICONSSTREAM /F<br /> PAUSE<br /> GOTO SUCCESS<br /> :SUCCESS<br /> CLS<br /> @ ECHO.<br /> @ ECHO. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Step2：重启Explorer进程 &nbsp;<br /> @ ECHO.<br /> @ ECHO. &nbsp; &nbsp;警告:执行此命令，以完成清理通知区域的整个过程。为了安全起见，执行前请保存当<br /> @ ECHO.前正在编辑的文件或文档，然后选择第 1 项继续。如果你不想执行此步，请选择第 2 项<br /> @ ECHO.退出,清理任务在下次启动计算机后生效。<br /> @ ECHO.<br /> @ ECHO.<br /> ECHO 　　　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;★★★　　 &nbsp; &nbsp; [1] 重启Explorer进程　　　　★★★<br /> ECHO 　　　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;★★★　　 &nbsp; &nbsp; [2] 退出程序　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;★★★<br /> @ ECHO.<br /> @ ECHO.<br /> SET /P CHOICE=　　　请选择要进行的操作 (1/2) ，然后按回车键执行：<br /> IF /I &#8216;%CHOICE%&#8217;==&#8217;1&#8217; GOTO EXPLORER<br /> IF /I &#8216;%CHOICE%&#8217;==&#8217;2&#8217; GOTO SUCCESS1<br /> :EXPLORER<br /> TASKKILL /IM EXPLORER.EXE /F<br /> START EXPLORER.EXE<br /> GOTO SUCCESS1<br /> :SUCCESS1<br /> EXIT&nbsp;</p>
<p></strong></span>
  </div>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>获取网络图片的大小</title>
		<link>https://uzzz.org/article/2464.html</link>
				<pubDate>Mon, 17 Nov 2014 02:29:04 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[图像处理]]></category>
		<category><![CDATA[图片]]></category>

		<guid isPermaLink="false">https://uzzz.org/article/2464.html</guid>
				<description><![CDATA[&#60;span style="font-size:18px;"&#62;// 图片处理 0 半灰色 1 灰度 2 深棕色 3 反色 +(UIImage*)imageWithImage:(UIImage*)image grayLevelType:(UIImageGrayLevelType)type; //色值 变暗多少 0.0 - 1.0 +(UIImage*)imageWithImage:(UIImage*)image darkValue:(float)darkValue; /** 获取网络图片的Size, 先通过文件头来获取图片大小 如果失败 会下载完整的图片Data 来计算大小 所以最好别放在主线程 如果你有使用SDWebImage就会先看下 SDWebImage有缓存过改图片没有 支持文件头大小的格式 png、gif、jpg http://www.cocoachina.com/bbs/read.php?tid=165823 */ +(CGSize)downloadImageSizeWithURL:(id)imageURL; 派生到我的代码片 //讨厌警告 -(id)diskImageDataBySearchingAllPathsForKey:(id)key{return nil;} +(CGSize)downloadImageSizeWithURL:(id)imageURL { NSURL* URL = nil; if([imageURL isKindOfClass:[NSURL class]]){ URL = imageURL; } if([imageURL isKindOfClass:[NSString class]]){ URL = [NSURL URLWithString:imageURL]; } if(URL == nil) return CGSizeZero; NSString* absoluteString = URL.absoluteString; #ifdef dispatch_main_sync_safe if([[SDImageCache sharedImageCache] diskImageExistsWithKey:absoluteString]) { UIImage* image = [[SDImageCache sharedImageCache] imageFromMemoryCacheForKey:absoluteString]; if(!image) { NSData* data = [[SDImageCache sharedImageCache] performSelector:@selector(diskImageDataBySearchingAllPathsForKey:) withObject:URL.absoluteString]; image = [UIImage imageWithData:data]; } if(image) { return image.size; } } #endif NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:URL]; NSString* pathExtendsion = [URL.pathExtension lowercaseString]; CGSize size = CGSizeZero; if([pathExtendsion isEqualToString:@"png"]){ size = [self downloadPNGImageSizeWithRequest:request]; } else if([pathExtendsion isEqual:@"gif"]) { size = [self downloadGIFImageSizeWithRequest:request]; } else{ size = [self downloadJPGImageSizeWithRequest:request]; } if(CGSizeEqualToSize(CGSizeZero, size)) { NSData* data = [NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:URL] returningResponse:nil error:nil]; UIImage* image = [UIImage imageWithData:data]; if(image) { #ifdef dispatch_main_sync_safe [[SDImageCache sharedImageCache] storeImage:image recalculateFromImage:YES imageData:data forKey:URL.absoluteString toDisk:YES]; #endif size = image.size; } } return size; } +(CGSize)downloadPNGImageSizeWithRequest:(NSMutableURLRequest*)request { [request setValue:@"bytes=16-23" forHTTPHeaderField:@"Range"]; NSData*]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <!--一个博主专栏付费入口--><br />
 <!--一个博主专栏付费入口结束-->
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css">
<div class="htmledit_views" id="content_views">
<pre><code class="language-objc">&lt;span style="font-size:18px;"&gt;// 图片处理 0 半灰色  1 灰度   2 深棕色    3 反色  
+(UIImage*)imageWithImage:(UIImage*)image grayLevelType:(UIImageGrayLevelType)type;  
  
//色值 变暗多少 0.0 - 1.0  
+(UIImage*)imageWithImage:(UIImage*)image darkValue:(float)darkValue;  
  
/**  
    获取网络图片的Size, 先通过文件头来获取图片大小  
    如果失败 会下载完整的图片Data 来计算大小 所以最好别放在主线程 
    如果你有使用SDWebImage就会先看下 SDWebImage有缓存过改图片没有 
    支持文件头大小的格式 png、gif、jpg   http://www.cocoachina.com/bbs/read.php?tid=165823 
 */  
+(CGSize)downloadImageSizeWithURL:(id)imageURL; 

派生到我的代码片

    //讨厌警告  
    -(id)diskImageDataBySearchingAllPathsForKey:(id)key{return nil;}  
    +(CGSize)downloadImageSizeWithURL:(id)imageURL  
    {  
        NSURL* URL = nil;  
        if([imageURL isKindOfClass:[NSURL class]]){  
            URL = imageURL;  
        }  
        if([imageURL isKindOfClass:[NSString class]]){  
            URL = [NSURL URLWithString:imageURL];  
        }  
        if(URL == nil)  
            return CGSizeZero;  
          
        NSString* absoluteString = URL.absoluteString;  
          
    #ifdef dispatch_main_sync_safe  
        if([[SDImageCache sharedImageCache] diskImageExistsWithKey:absoluteString])  
        {  
            UIImage* image = [[SDImageCache sharedImageCache] imageFromMemoryCacheForKey:absoluteString];  
            if(!image)  
            {  
                NSData* data = [[SDImageCache sharedImageCache] performSelector:@selector(diskImageDataBySearchingAllPathsForKey:) withObject:URL.absoluteString];  
                image = [UIImage imageWithData:data];  
            }  
            if(image)  
            {  
                return image.size;  
            }  
        }  
    #endif  
          
        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:URL];  
        NSString* pathExtendsion = [URL.pathExtension lowercaseString];  
          
        CGSize size = CGSizeZero;  
        if([pathExtendsion isEqualToString:@"png"]){  
            size =  [self downloadPNGImageSizeWithRequest:request];  
        }  
        else if([pathExtendsion isEqual:@"gif"])  
        {  
            size =  [self downloadGIFImageSizeWithRequest:request];  
        }  
        else{  
            size = [self downloadJPGImageSizeWithRequest:request];  
        }  
        if(CGSizeEqualToSize(CGSizeZero, size))  
        {  
            NSData* data = [NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:URL] returningResponse:nil error:nil];  
            UIImage* image = [UIImage imageWithData:data];  
            if(image)  
            {  
    #ifdef dispatch_main_sync_safe  
                [[SDImageCache sharedImageCache] storeImage:image recalculateFromImage:YES imageData:data forKey:URL.absoluteString toDisk:YES];  
    #endif  
                size = image.size;  
            }  
        }  
        return size;  
    }  
    +(CGSize)downloadPNGImageSizeWithRequest:(NSMutableURLRequest*)request  
    {  
        [request setValue:@"bytes=16-23" forHTTPHeaderField:@"Range"];  
        NSData* data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];  
        if(data.length == 8)  
        {  
            int w1 = 0, w2 = 0, w3 = 0, w4 = 0;  
            [data getBytes:&amp;w1 range:NSMakeRange(0, 1)];  
            [data getBytes:&amp;w2 range:NSMakeRange(1, 1)];  
            [data getBytes:&amp;w3 range:NSMakeRange(2, 1)];  
            [data getBytes:&amp;w4 range:NSMakeRange(3, 1)];  
            int w = (w1 &lt;&lt; 24) + (w2 &lt;&lt; 16) + (w3 &lt;&lt; 8) + w4;  
            int h1 = 0, h2 = 0, h3 = 0, h4 = 0;  
            [data getBytes:&amp;h1 range:NSMakeRange(4, 1)];  
            [data getBytes:&amp;h2 range:NSMakeRange(5, 1)];  
            [data getBytes:&amp;h3 range:NSMakeRange(6, 1)];  
            [data getBytes:&amp;h4 range:NSMakeRange(7, 1)];  
            int h = (h1 &lt;&lt; 24) + (h2 &lt;&lt; 16) + (h3 &lt;&lt; 8) + h4;  
            return CGSizeMake(w, h);  
        }  
        return CGSizeZero;  
    }  
    +(CGSize)downloadGIFImageSizeWithRequest:(NSMutableURLRequest*)request  
    {  
        [request setValue:@"bytes=6-9" forHTTPHeaderField:@"Range"];  
        NSData* data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];  
        if(data.length == 4)  
        {  
            short w1 = 0, w2 = 0;  
            [data getBytes:&amp;w1 range:NSMakeRange(0, 1)];  
            [data getBytes:&amp;w2 range:NSMakeRange(1, 1)];  
            short w = w1 + (w2 &lt;&lt; 8);  
            short h1 = 0, h2 = 0;  
            [data getBytes:&amp;h1 range:NSMakeRange(2, 1)];  
            [data getBytes:&amp;h2 range:NSMakeRange(3, 1)];  
            short h = h1 + (h2 &lt;&lt; 8);  
            return CGSizeMake(w, h);  
        }  
        return CGSizeZero;  
    }  
    +(CGSize)downloadJPGImageSizeWithRequest:(NSMutableURLRequest*)request  
    {  
        [request setValue:@"bytes=0-209" forHTTPHeaderField:@"Range"];  
        NSData* data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];  
          
        if ([data length] &lt;= 0x58) {  
            return CGSizeZero;  
        }  
          
        if ([data length] &lt; 210) {// 肯定只有一个DQT字段  
            short w1 = 0, w2 = 0;  
            [data getBytes:&amp;w1 range:NSMakeRange(0x60, 0x1)];  
            [data getBytes:&amp;w2 range:NSMakeRange(0x61, 0x1)];  
            short w = (w1 &lt;&lt; 8) + w2;  
            short h1 = 0, h2 = 0;  
            [data getBytes:&amp;h1 range:NSMakeRange(0x5e, 0x1)];  
            [data getBytes:&amp;h2 range:NSMakeRange(0x5f, 0x1)];  
            short h = (h1 &lt;&lt; 8) + h2;  
            return CGSizeMake(w, h);  
        } else {  
            short word = 0x0;  
            [data getBytes:&amp;word range:NSMakeRange(0x15, 0x1)];  
            if (word == 0xdb) {  
                [data getBytes:&amp;word range:NSMakeRange(0x5a, 0x1)];  
                if (word == 0xdb) {// 两个DQT字段  
                    short w1 = 0, w2 = 0;  
                    [data getBytes:&amp;w1 range:NSMakeRange(0xa5, 0x1)];  
                    [data getBytes:&amp;w2 range:NSMakeRange(0xa6, 0x1)];  
                    short w = (w1 &lt;&lt; 8) + w2;  
                    short h1 = 0, h2 = 0;  
                    [data getBytes:&amp;h1 range:NSMakeRange(0xa3, 0x1)];  
                    [data getBytes:&amp;h2 range:NSMakeRange(0xa4, 0x1)];  
                    short h = (h1 &lt;&lt; 8) + h2;  
                    return CGSizeMake(w, h);  
                } else {// 一个DQT字段  
                    short w1 = 0, w2 = 0;  
                    [data getBytes:&amp;w1 range:NSMakeRange(0x60, 0x1)];  
                    [data getBytes:&amp;w2 range:NSMakeRange(0x61, 0x1)];  
                    short w = (w1 &lt;&lt; 8) + w2;  
                    short h1 = 0, h2 = 0;  
                    [data getBytes:&amp;h1 range:NSMakeRange(0x5e, 0x1)];  
                    [data getBytes:&amp;h2 range:NSMakeRange(0x5f, 0x1)];  
                    short h = (h1 &lt;&lt; 8) + h2;  
                    return CGSizeMake(w, h);  
                }  
            } else {  
                return CGSizeZero;  
            }  
        }  
    }&lt;/span&gt;</code></pre>
<p>  <span style="font-size:18px;"><br /></span>
 </div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
