<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>application &#8211; 有组织在!</title>
	<atom:link href="https://uzzz.org/tag/application/feed" rel="self" type="application/rss+xml" />
	<link>https://uzzz.org/</link>
	<description></description>
	<lastBuildDate>Fri, 11 Sep 2009 03:41:00 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.2.4</generator>

<image>
	<url>https://uzzz.org/wp-content/uploads/2019/10/cropped-icon-32x32.png</url>
	<title>application &#8211; 有组织在!</title>
	<link>https://uzzz.org/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Flex Deep Link(深链接) BrowserManager</title>
		<link>https://uzzz.org/article/1714.html</link>
				<pubDate>Fri, 11 Sep 2009 03:41:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[application]]></category>
		<category><![CDATA[flash]]></category>
		<category><![CDATA[url]]></category>
		<category><![CDATA[浏览器]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1714.html</guid>
				<description><![CDATA[最近做游戏的时候，发现退出登陆时URL上会自动加上一个“#”字符，很奇怪，Google+Baidu无数次都没有找到答案。今天无意间看到几个群友在说通过“BrowserManager”获取URL，于是仔细查看了API，又发现了“HistoryManager”，这个问题终于明白了。 我们通常看的Web页面 可以通过浏览器的“前进”“后退”来查看刚才看过的页面，同样，嵌入的页面中的flash也可以实现这样的功能。方法是通过HistoryManageer类和BrowserManager类两种方法来实现。HistoryManageer类主要是用在Flex2，Flex3后很少用了。待会我将分别介绍这两种方法。 回到刚才说URL上自动加“#”号的问题：原因是Application 默认historyManagementEnabled属性是ture，也就是说HistoryManageer类功能自动开启了，Application 里面通过程序控制addChild或removeChild任何组件所导致的变化，将会记录在flash的history中，导致重写url，加上“#”字符。故有了这个奇怪的“#”号。在Flex3中，HistoryManager功能在Flex项目中默认打开的还有Accordion 和 TabNavigator组件。对于没有默认打开该功能的组件，如果要实现该功能，则需要另外注册。下面引用两片文章加以说明：对于一个网站来说，其是有若干个网页组成的。而各个网页之间的链接叫做超链接。链接成为网页和网页之间的桥梁。那么，对于一个Flash整站来说，有没有一个办法来实现Flash各页面（更恰当的说是各功能模块）之间的链接呢。比如，我想在浏览器中输入一个链接便可以链到Flash整站中的一页—一个功能模块，而不是每次都要通过Flash整站的第一个页面的功能导航进入。把Flash的各个功能块页面化，那么我们该怎么实现呢。到底能不能实现呢？&#160; 答案是肯定的，通过Flex Deep Link 便能实现上述功能。&#160; &#60;script language=javascript type=text/javascript&#62;&#60;/script&#62; 目录 [隐藏] 1 第一，Deep Link 简介。 2 &#160; 第二，HistoryManager。 3 方法： 4 属性： 5 &#160; 如何分析URl 6 &#160; 获得链接信息 Flex Deep Link(深链接)-第一，Deep Link 简介。 &#160; &#160; Deep Link其实也是依赖Flash和浏览器的交互来实现的，通过获取链接地址中#后面的参数来实现页面标记，当你在Flex Bulid3发布一个项目时，其会自动你发布的目录生成一个名为History的文件夹，里面有History.js,HistoryFrame.html,history.css这三个文件，可见Deep Link也是通过和浏览器交互来实现的.如果浏览器不支持JavaScript或者禁用JavaScript，那么Deep LinK肯定是不能用的。&#160; 对于Deep Link应用，最重要的就是学会应用BrowserManager和HistoryManager这两个类。我们由简单到困难，先讲一讲HistoryManager这个类的应用。 Flex Deep Link(深链接)-&#160; 第二，HistoryManager。 &#160;&#160; &#160; HistoryManager功能在Flex项目中是默认打开的，比如在使用Accordion 和 TabNavigator组件时，在不同区域切换时，Flex会自动记录下各个状态，我们可以通过点击浏览器的“前进”和“后退”按钮来前进和倒退，在你切换这些组件的区域时，Flex会自动你在网页链接的后面加写参数，以便记录当前页面的状态。&#160; 默认情况下HistoryManager的功能是打开的，你可以通过设置各个组件或Application的historyManagementEnabled属性为false（默认为TRUE）来关闭此功能。&#160; 这些都没什么好讲的。关键是怎么在一些普通组建上使用HistoryManager功能，默认的navigator container组建都是支持该功能的。要使一些普通组建也支持此功能，必须：&#160; 1.实现mx.managers.IHistoryManagerClient接口。&#160; 2.用HistoryManager&#8217;的register()方法为组建注册。&#160; 3.当组件状态改变时保存组件的状态。&#160; 4.通过实施IHistoryManagerClient的saveState() 和 loadState()方法来保存和读取组件状态。 &#160;&#160;拿CheckBox为例： &#160;&#60;?xml version=&#8221;1.0&#8243;?&#62;&#60;mx:CheckBox&#160;&#160; xmlns:mx=&#8221;http://www.adobe.com/2006/mxml&#8221;&#160; label=&#8221;Check me&#8221;&#160;&#160; &#160;&#160; implements=&#8221;mx.managers.IHistoryManagerClient&#8221; //关键步骤1，实现接口&#160; creationComplete=&#8221;mx.managers.HistoryManager.register(this);&#8221;//关键步骤2，注册组件&#160; change=&#8221;boxChanged(event)&#8221;//关键步骤3，当组件发生变化时保存状态&#62; &#160; &#60;mx:Script&#62;&#60;![CDATA[&#160; import mx.managers.HistoryManager;&#160; //实施IHistoryManagerClient的saveState()方法保存状态&#160; public function saveState():Object {return {selected:selected};&#160; }&#160; //实施IHistoryManagerClient的loadState()方法读取状态public function loadState(state:Object):void {var newState:Boolean = state; if (newState != selected) {&#160; selected = newState;} else {&#160; if (newState) {&#160; ;&#160; } else {&#160; selected = true;&#160; }}&#160; }&#160; &#160;&#160; // 保存状态&#160; private function boxChanged(e:Event):void {HistoryManager.save();&#160; } &#160;&#160; ]]&#62;&#60;/mx:Script&#62; &#60;/mx:CheckBox&#62;&#160; 注意：如果你把实现HistoryManager功能的组件放到module中，再在主程序中调用，那么HistoryManager功能是没用的。&#160; 麻雀虽小，五脏俱全。上面例子就是如何让任意组件实现HistoryManager的典型案例。点击浏览器的“前进”和“后退”来恢复上个或下个状态。BrowserManager类要比HistoryManager类更复杂些。BrowserManager类好比就是Flex程序和浏览器之间的一个代理。当浏览地址栏的地址发生变化时，浏览器通过BrowserManager类告知Flex程序。&#160;&#160; 可以通过BrowserManager类的getInstance()方法来获得其一个实施了IBrowserManager接口的实例。这样就可以访问其setTitle()和setFragment()方法和属性了。下面我就来介绍一下BrowserManager类的一些属性和方法。&#160; Flex Deep Link(深链接)-方法： &#160; 1.init(fragment,title)&#160; 该方法可以定义默认的链接参数和网页标题。一般在初始化时用到。例如：&#160; browserManager.init(&#8220;&#8221;, &#8220;Test Deep Linking&#8221;);定义了参数为空，标题为Test Deep Linking的网页。&#160; 2.setTitle(title)&#160; 该方法用来设置网页标题。例如：&#160; browserManager.setTitle(&#8220;The New Title&#8221;) 设置网页标题为“The New Title”。&#160; 3.setFragment(fragment)&#160;该方法用来设置网页参数。例如：&#160;browserManager.setFragment(&#8220;id=3&#8221;) 设置参数“id=3”。&#160; Flex Deep Link(深链接)-属性： &#160; 1.url&#160; browserManager.url获得页面完整链接。&#160; 2.base&#160; browserManager.base获得页面基地址。&#160; 3.fragment&#160; browserManager.fragment获得页面链接#后的参数。&#160; 4.lastURL&#160; browserManager.lastURL获得上一个页面链接——IE6我获得是失败的，火狐正确。大家可以自己试试。 &#160; 注意：上面的browserManager便是BrowserManager类的一个实例。实例化过程如下：&#160; import mx.events.BrowserChangeEvent;&#160; import mx.managers.IBrowserManager;&#160; import mx.managers.BrowserManager;&#160; private var browserManager:IBrowserManager;&#160; private function initApp():void {&#160;]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
<p>最近做游戏的时候，发现退出登陆时URL上会自动加上一个“#”字符，很奇怪，Google+Baidu无数次都没有找到答案。今天无意间看到几个群友在说通过“BrowserManager”获取URL，于是仔细查看了API，又发现了“HistoryManager”，这个问题终于明白了。</p>
<p>我们通常看的Web页面 可以通过浏览器的“前进”“后退”来查看刚才看过的页面，同样，嵌入的页面中的flash也可以实现这样的功能。方法是通过HistoryManageer类和BrowserManager类两种方法来实现。HistoryManageer类主要是用在Flex2，Flex3后很少用了。待会我将分别介绍这两种方法。</p>
<p>回到刚才说URL上自动加“#”号的问题：原因是Application 默认historyManagementEnabled属性是ture，也就是说HistoryManageer类功能自动开启了，Application 里面通过程序控制addChild或removeChild任何组件所导致的变化，将会记录在flash的history中，导致重写url，加上“#”字符。故有了这个奇怪的“#”号。在Flex3中，HistoryManager功能在Flex项目中默认打开的还有Accordion 和 TabNavigator组件。对于没有默认打开该功能的组件，如果要实现该功能，则需要另外注册。下面引用两片文章加以说明：<br />对于一个网站来说，其是有若干个网页组成的。而各个网页之间的链接叫做超链接。链接成为网页和网页之间的桥梁。那么，对于一个Flash整站来说，有没有一个办法来实现Flash各页面（更恰当的说是各功能模块）之间的链接呢。比如，我想在浏览器中输入一个链接便可以链到Flash整站中的一页—一个功能模块，而不是每次都要通过Flash整站的第一个页面的功能导航进入。把Flash的各个功能块页面化，那么我们该怎么实现呢。到底能不能实现呢？<br />&nbsp; 答案是肯定的，通过Flex Deep Link 便能实现上述功能。<br />&nbsp; &lt;script language=javascript type=text/javascript&gt;&lt;/script&gt; </p>
<fieldset id="catalog">
<legend>目录 <span class="on-off" id="hideOrshow"><a id="doccatalog_hide_show">[隐藏]</a> </span></legend>
<ul class="link_black" id="full" style="display:block;">
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#1" rel="nofollow" data-token="e3f5d7e86ad81a1d0a8ff7bccf13784a">1 第一，Deep Link 简介。</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#3" rel="nofollow" data-token="8a7a8a2193018c29fc1cb74d53cc8915">2 &nbsp; 第二，HistoryManager。</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#5" rel="nofollow" data-token="a694f9cc82d7e3a7ac76cb14e53b9320">3 方法：</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#7" rel="nofollow" data-token="016195c1d7f1bdb581c708db900d1bdf">4 属性：</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#9" rel="nofollow" data-token="e8b23dbbb08c76046255fb8c41a0f5f5">5 &nbsp; 如何分析URl</a> </li>
<li><a href="http://writeblog.csdn.net/wiki/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29#11" rel="nofollow" data-token="9dad0cae07a63be7b8422a66f2a5d70a">6 &nbsp; 获得链接信息</a> </li>
</ul>
</fieldset>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-第一，Deep Link 简介。</h2>
<p>   <span><a class="mceItemAnchor" name="1">&nbsp;</a> </span>
  </div>
<p>&nbsp; Deep Link其实也是依赖Flash和浏览器的交互来实现的，通过获取链接地址中#后面的参数来实现页面标记，当你在Flex Bulid3发布一个项目时，其会自动你发布的目录生成一个名为History的文件夹，里面有History.js,HistoryFrame.html,history.css这三个文件，可见Deep Link也是通过和浏览器交互来实现的.如果浏览器不支持JavaScript或者禁用JavaScript，那么Deep LinK肯定是不能用的。<br />&nbsp; 对于Deep Link应用，最重要的就是学会应用BrowserManager和HistoryManager这两个类。我们由简单到困难，先讲一讲HistoryManager这个类的应用。</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 第二，HistoryManager。</h2>
<p>   <span>&nbsp;<a href="http://writeblog.csdn.net/editsectionauth/Flex+Deep+Link%28%E6%B7%B1%E9%93%BE%E6%8E%A5%29/3" rel="nofollow" data-token="48dd4cc1bfb43134e3ca3d157f9b9535">&nbsp;</a><a href="http://writeblog.csdn.net/#catalog" rel="nofollow" data-token="f1db0e193720074bc010856f9b17911c"> </a></span>
  </div>
<p>&nbsp; HistoryManager功能在Flex项目中是默认打开的，比如在使用Accordion 和 TabNavigator组件时，在不同区域切换时，Flex会自动记录下各个状态，我们可以通过点击浏览器的“前进”和“后退”按钮来前进和倒退，在你切换这些组件的区域时，Flex会自动你在网页链接的后面加写参数，以便记录当前页面的状态。<br />&nbsp; 默认情况下HistoryManager的功能是打开的，你可以通过设置各个组件或Application的historyManagementEnabled属性为false（默认为TRUE）来关闭此功能。<br />&nbsp; 这些都没什么好讲的。关键是怎么在一些普通组建上使用HistoryManager功能，默认的navigator container组建都是支持该功能的。要使一些普通组建也支持此功能，必须：<br />&nbsp; 1.实现mx.managers.IHistoryManagerClient接口。<br />&nbsp; 2.用HistoryManager&#8217;的register()方法为组建注册。<br />&nbsp; 3.当组件状态改变时保存组件的状态。<br />&nbsp; 4.通过实施IHistoryManagerClient的saveState() 和 loadState()方法来保存和读取组件状态。</p>
<p>&nbsp;<br />&nbsp;拿CheckBox为例：</p>
<p>&nbsp;<br />&lt;?xml version=&#8221;1.0&#8243;?&gt;<br />&lt;mx:CheckBox&nbsp;<br />&nbsp; xmlns:mx=&#8221;http://www.adobe.com/2006/mxml&#8221;<br />&nbsp; label=&#8221;Check me&#8221;&nbsp;<br />&nbsp; &nbsp;<br />&nbsp; implements=&#8221;mx.managers.IHistoryManagerClient&#8221; //关键步骤1，实现接口<br />&nbsp; creationComplete=&#8221;mx.managers.HistoryManager.register(this);&#8221;//关键步骤2，注册组件<br />&nbsp; change=&#8221;boxChanged(event)&#8221;//关键步骤3，当组件发生变化时保存状态<br />&gt;</p>
<p>&nbsp; &lt;mx:Script&gt;&lt;![CDATA[<br />&nbsp; import mx.managers.HistoryManager;<br />&nbsp; //实施IHistoryManagerClient的saveState()方法保存状态<br />&nbsp; public function saveState():Object {<br />return {selected:selected};<br />&nbsp; }<br />&nbsp; //实施IHistoryManagerClient的loadState()方法读取状态<br />public function loadState(state:Object):void {<br />var newState:Boolean = state;</p>
<p>if (newState != selected) {<br />&nbsp; selected = newState;<br />} else {<br />&nbsp; if (newState) {<br />&nbsp; ;<br />&nbsp; } else {<br />&nbsp; selected = true;<br />&nbsp; }<br />}<br />&nbsp; }<br />&nbsp; &nbsp;<br />&nbsp; // 保存状态<br />&nbsp; private function boxChanged(e:Event):void {<br />HistoryManager.save();<br />&nbsp; } &nbsp;<br />&nbsp; ]]&gt;&lt;/mx:Script&gt;</p>
<p>&lt;/mx:CheckBox&gt;<br />&nbsp; 注意：如果你把实现HistoryManager功能的组件放到module中，再在主程序中调用，那么HistoryManager功能是没用的。<br />&nbsp; 麻雀虽小，五脏俱全。上面例子就是如何让任意组件实现HistoryManager的典型案例。点击浏览器的“前进”和“后退”来恢复上个或下个状态。<br />BrowserManager类要比HistoryManager类更复杂些。BrowserManager类好比就是Flex程序和浏览器之间的一个代理。当浏览地址栏的地址发生变化时，浏览器通过BrowserManager类告知Flex程序。&nbsp;<br />&nbsp; 可以通过BrowserManager类的getInstance()方法来获得其一个实施了IBrowserManager接口的实例。这样就可以访问其setTitle()和setFragment()方法和属性了。下面我就来介绍一下BrowserManager类的一些属性和方法。<br />&nbsp; </p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-方法：</h2>
</p></div>
<p>&nbsp; 1.init(fragment,title)<br />&nbsp; 该方法可以定义默认的链接参数和网页标题。一般在初始化时用到。例如：<br />&nbsp; browserManager.init(&#8220;&#8221;, &#8220;Test Deep Linking&#8221;);定义了参数为空，标题为Test Deep Linking的网页。<br />&nbsp; 2.setTitle(title)<br />&nbsp; 该方法用来设置网页标题。例如：<br />&nbsp; browserManager.setTitle(&#8220;The New Title&#8221;) 设置网页标题为“The New Title”。<br />&nbsp; 3.setFragment(fragment)<br />&nbsp;该方法用来设置网页参数。例如：<br />&nbsp;browserManager.setFragment(&#8220;id=3&#8221;) 设置参数“id=3”。<br />&nbsp; </p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-属性：</h2>
</p></div>
<p>&nbsp; 1.url<br />&nbsp; browserManager.url获得页面完整链接。<br />&nbsp; 2.base<br />&nbsp; browserManager.base获得页面基地址。<br />&nbsp; 3.fragment<br />&nbsp; browserManager.fragment获得页面链接#后的参数。<br />&nbsp; 4.lastURL<br />&nbsp; browserManager.lastURL获得上一个页面链接——IE6我获得是失败的，火狐正确。大家可以自己试试。</p>
<p>&nbsp; 注意：上面的browserManager便是BrowserManager类的一个实例。实例化过程如下：<br />&nbsp; import mx.events.BrowserChangeEvent;<br />&nbsp; import mx.managers.IBrowserManager;<br />&nbsp; import mx.managers.BrowserManager;<br />&nbsp; private var browserManager:IBrowserManager;<br />&nbsp; private function initApp():void {<br />&nbsp; browserManager = BrowserManager.getInstance();<br />&nbsp; browserManager.addEventListener(BrowserChangeEvent.BROWSER_URL_CHANGE, parseURL);<br />&nbsp; browserManager.init(&#8220;&#8221;, &#8220;Test Deep Linking&#8221;);<br />}</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 如何分析URl</h2>
</p></div>
<p>&nbsp; 可以用URLUtil类方便的分析Url<br />&nbsp; 类路径mx.utils.URLUtil，例如链接：http://127.0.0.1/index.html#a=3&amp;b=1<br />&nbsp; var o:Object = URLUtil.stringToObject(browserManager.fragment,&#8221;&amp;&#8221;);<br />&nbsp; trace(o.a,o.b)<br />&nbsp; 反过来设置地址栏链接：<br />&nbsp; o.a=5；o.b=7；<br />&nbsp; var s:String = URLUtil.objectToString(o,&#8221;&amp;&#8221;);<br />&nbsp; browserManager.setFragment(s);<br />&nbsp; 注意：如果 URLUtil.objectToString()方法第二个参数为空，那么默认的参数分隔符为&#8221;；&#8221;号。<br />&nbsp;<br />&nbsp; BrowserManager类的事件<br />&nbsp; BrowserManager类有三种事件：<br />&nbsp; 1.applicationURLChange事件；<br />&nbsp; 当在程序执行时调用setFragment()等方法改变URL时派发此事件。<br />&nbsp; 2.browserURLChange事件；<br />&nbsp; 当手动改变浏览器链接或点击“前进”或“后退”时派发此事件。<br />&nbsp; 3.urlChange事件；<br />&nbsp; applicationURLChange事件或browserURLChange事件派发时，都将触发该事件。</p>
<div class="content_h2">
<h2>Flex Deep Link(深链接)-&nbsp; 获得链接信息</h2>
</p></div>
<p>&nbsp; 可以通过BrowserManager类的属性和URLUtil的一些方法来获得链接信息，例如：<br />&nbsp; var url:String = browserManager.url;<br />&nbsp; baseURL = browserManager.base;<br />&nbsp; fragment = browserManager.fragment; &nbsp;<br />&nbsp; previousURL = e.lastURL; &nbsp;</p>
<p>&nbsp; fullURL = mx.utils.URLUtil.getFullURL(url, url);<br />&nbsp; port = mx.utils.URLUtil.getPort(url);<br />&nbsp; protocol = mx.utils.URLUtil.getProtocol(url);<br />&nbsp; serverName = mx.utils.URLUtil.getServerName(url);<br />&nbsp; isSecure = mx.utils.URLUtil.isHttpsurl(/url);</p>
<p>&nbsp; 具体含义也很清楚，我也就不多讲了。<br />&nbsp; 关于BrowserManager类大致也就上面的内容。要注意的是BrowserManager类和HistoryManager类不能同时使用，也就是说用了BrowserManager类就不能再用HistoryManager类了，当你用了BrowserManager类后，系统会自动禁用HistoryManager类。<br />&nbsp; 既然能获得了参数，那么实现文章开头那些功能也就没什么了。通过在初始化程序中获取相应的参数，再根据这些参数控制程序显示。和.net,asp,php类似，万物皆规律。有了BrowserManager类的帮助，加上一些程序控制，现在我在浏览器输入http://127.0.0.1/news.html#id=20便能在Flash整站中显示某个新闻页面了。</p>
</p></div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>神奇的Tor带你冲浪自由的百科全书Wiki</title>
		<link>https://uzzz.org/article/1179.html</link>
				<pubDate>Fri, 16 Jun 2006 05:49:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[darknet]]></category>
		<category><![CDATA[application]]></category>
		<category><![CDATA[加密]]></category>
		<category><![CDATA[服务器]]></category>
		<category><![CDATA[网络]]></category>
		<category><![CDATA[路由器]]></category>
		<category><![CDATA[通讯]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1179.html</guid>
				<description><![CDATA[&#160;&#160;&#160;&#160;&#160;&#160;&#160; 很久的时候就听说过 Wiki（维基百科全书），也在很多的地方看到过Wiki的链接，每次好奇的点击过去，总是无法打开的失望，从此以后头脑中多了一份对于Wiki的牵挂，一份不舍，为什么我就上不去呢？ &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 最后，我看到了一些关于Tor的介绍，标题起的就很吸引人&#8212;&#8211;跨越人造的鸿沟：Tor代理服务器。看了之后，大概的有了些印象，下面是wiki上摘录的一些： Tor是第二代 onion routing（洋葱路由）的一种实现，用户通过Tor可以在因特网上进行 匿名交流。最初该项目由 美国海军研究实验室（US Naval Research Laboratory）赞助。 2004年晚些时候，Tor成为 电子前哨基金会（Electronic Frontier Foundation， EFF）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。 匿名外连 Tor用户在本机运行一个洋葱代理服务器(onion proxy），这个代理周期性地与其他Tor交流，从而在Tor网络中构成虚拟环路（virtual circuit）。 Tor是在7层protocol stack中的application layer进行加密（也就是按照&#8217;onion&#8217;的模式）而它之所以被称为onion是因为它的结构就跟洋葱相同，你只能看出它的外表而想要看到核心就必须 把它层层的剥开。即每个router间的传输都经过symmetric key来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式，这样在洋葱路由器之间可以 保持通讯安全。同时对于客户端，洋葱代理服务器又作为SOCKS接口。一些应用程序就可以将Tor作为代理服务器，网络通讯就可以通过Tor的虚拟环路来进行。 进入Tor网络后，加密信息在路由器间传递，最后到达“退出节点”（exit node），明文数据从这个节点直接发往原来的目的地。对于目的主机而言，是从“退出节点”发来信息。 由于在TCP数据流的级别通讯，Tor显得卓然独立于其他匿名网络。通过使用Tor，一般的应用程序都可以实现匿名，比如IRC、即时通讯，以及浏览网页。浏览网页时，Tor常常与Privoxy联合使用，Privoxy是一个代理服务器，可以在应用层增加保护隐私。 &#160;&#160;&#160;&#160;&#160; 有了Tor之后，我们就可以自由的上自己想上的网站了，这个要比一般的代理服务器好了很多。我们在 Tor的官方站点上可以下载，安装后将socket代理设置为localhost:9050，你就可以自由冲浪了。 &#160;&#160;&#160;&#160;&#160; Tor的页面中有祥细的 教程，那里的英文也不是很难，几个简单的步骤就搞定了。而且tor还专门针对firefox有一个torbutton的扩展，可以通过这个扩展来快速的切换是否使用tor。 &#160;&#160;&#160;&#160; 不多说了，enjoy it~~~~~~~~~]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 很久的时候就听说过<br />
  <a href="http://zh.wikipedia.org" rel="nofollow" data-token="f339ebf690ff805d938b57e74411940a">Wiki</a>（维基百科全书），也在很多的地方看到过Wiki的链接，每次好奇的点击过去，总是无法打开的失望，从此以后头脑中多了一份对于Wiki的牵挂，一份不舍，为什么我就上不去呢？<br />
  </p>
<div style="text-align:left;">
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最后，我看到了一些关于Tor的介绍，标题起的就很吸引人&#8212;&#8211;跨越人造的鸿沟：Tor代理服务器。看了之后，大概的有了些印象，下面是wiki上摘录的一些：<br />
   <br />
   <span></span> </p>
<div style="margin-left:40px;">
    <strong>Tor</strong>是第二代<br />
    <a title="Onion routing" class="new" href="http://zh.wikipedia.org/w/index.php?title=Onion_routing&amp;action=edit" rel="nofollow" data-token="66eb6b2fd339dcd734dd6c580fd2d13e">onion routing</a>（洋葱路由）的一种实现，用户通过Tor可以在因特网上进行<br />
    <a title="匿名" href="http://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D" rel="nofollow" data-token="54e64f7f998939a26c82ffee126a10ac">匿名</a>交流。最初该项目由<br />
    <a title="美国海军研究实验室" class="new" href="http://zh.wikipedia.org/w/index.php?title=%E7%BE%8E%E5%9B%BD%E6%B5%B7%E5%86%9B%E7%A0%94%E7%A9%B6%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;action=edit" rel="nofollow" data-token="9f023f01fe6aee4632b2d8dd044181bd">美国海军研究实验室</a>（US Naval Research Laboratory）赞助。<br />
    <a title="2004年" href="http://zh.wikipedia.org/wiki/2004%E5%B9%B4" rel="nofollow" data-token="2cc9e803182eaf7f5e5b599815cc6fa3">2004年</a>晚些时候，Tor成为<br />
    <a title="电子前哨基金会" class="new" href="http://zh.wikipedia.org/w/index.php?title=%E7%94%B5%E5%AD%90%E5%89%8D%E5%93%A8%E5%9F%BA%E9%87%91%E4%BC%9A&amp;action=edit" rel="nofollow" data-token="aa97acc8013e6298a5b72d4524bd221c">电子前哨基金会</a>（Electronic Frontier Foundation，<br />
    <strong>EFF</strong>）的一个项目。2005年后期，EFF不再赞助Tor项目，但他们继续维持Tor的官方网站。<br />
    </p>
<h2>匿名外连</h2>
<p>Tor用户在本机运行一个洋葱代理服务器(<em>onion proxy</em>），这个代理周期性地与其他Tor交流，从而在Tor网络中构成虚拟环路（<em>virtual circuit</em>）。 Tor是在7层protocol stack中的application layer进行加密（也就是按照&#8217;onion&#8217;的模式）而它之所以被称为onion是因为它的结构就跟洋葱相同，你只能看出它的外表而想要看到核心就必须 把它层层的剥开。即每个router间的传输都经过symmetric key来加密，形成有层次的结构。它中间所经过的各节点，都好像洋葱的一层皮，把客户端包在里面，算是保护信息来源的一种方式，这样在洋葱路由器之间可以 保持通讯安全。同时对于客户端，洋葱代理服务器又作为<a title="SOCKS" href="http://zh.wikipedia.org/wiki/SOCKS" rel="nofollow" data-token="e1ef8fef97ee2ee5075c4b62339f6692">SOCKS</a>接口。一些应用程序就可以将Tor作为代理服务器，网络通讯就可以通过Tor的虚拟环路来进行。</p>
<p>进入Tor网络后，加密信息在路由器间传递，最后到达“退出节点”（<em>exit node</em>），明文数据从这个节点直接发往原来的目的地。对于目的主机而言，是从“退出节点”发来信息。</p>
<p>由于在TCP数据流的级别通讯，Tor显得卓然独立于其他匿名网络。通过使用Tor，一般的应用程序都可以实现匿名，比如<a title="IRC" href="http://zh.wikipedia.org/wiki/IRC" rel="nofollow" data-token="4f6ef2684c0a208aa7d7f061a35dfaf1">IRC</a>、<a title="即时通讯" href="http://zh.wikipedia.org/wiki/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF" rel="nofollow" data-token="6af357e534e95402bedafcffa8474378">即时通讯</a>，以及浏览<a title="万维网" href="http://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91" rel="nofollow" data-token="15fd7b71e14b1e9819feef3768d169e9">网页</a>。浏览网页时，Tor常常与<a title="Privoxy" href="http://zh.wikipedia.org/wiki/Privoxy" rel="nofollow" data-token="7f5882d66aae128f216ff2567f38f192">Privoxy</a>联合使用，Privoxy是一个<a title="代理服务器" href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow" data-token="7ebea316f686d8ea54238dadcdba13fe">代理服务器</a>，可以在应用层增加保护隐私。</p>
</p></div>
</p></div>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有了Tor之后，我们就可以自由的上自己想上的网站了，这个要比一般的代理服务器好了很多。我们在<br />
  <a href="http://tor.eff.org" rel="nofollow" data-token="b0c91b976e8404b8d63faa54c842fa91">Tor</a>的官方站点上可以下载，安装后将socket代理设置为localhost:9050，你就可以自由冲浪了。<br />
  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tor的页面中有祥细的<br />
  <a href="http://tor.eff.org/docs/tor-doc-win32.html.en" rel="nofollow" data-token="b124e49583957a735984e5ccb77c0889">教程</a>，那里的英文也不是很难，几个简单的步骤就搞定了。而且tor还专门针对firefox有一个torbutton的扩展，可以通过这个扩展来快速的切换是否使用tor。<br />
  <br />&nbsp;&nbsp;&nbsp;&nbsp; 不多说了，enjoy it~~~~~~~~~
 </div>
</div>
]]></content:encoded>
										</item>
		<item>
		<title>一次WebStress测试</title>
		<link>https://uzzz.org/article/1341.html</link>
				<pubDate>Mon, 07 Mar 2005 10:27:00 +0000</pubDate>
		<dc:creator><![CDATA[fandyvon]]></dc:creator>
				<category><![CDATA[未分类]]></category>
		<category><![CDATA[application]]></category>
		<category><![CDATA[web]]></category>
		<category><![CDATA[服务器]]></category>
		<category><![CDATA[测试]]></category>
		<category><![CDATA[测试工具]]></category>

		<guid isPermaLink="false">http://wp.uzzz.org/article/1341.html</guid>
				<description><![CDATA[writer: demonalexemail: demonalex_at_dark2s.org 前言:看完了SQL的《用WEB压力测试工具模拟请求服务的DOS攻击》，尤觉得意尤未尽，为摸清此软件的&#160;&#160;&#160;&#160; 部分功能，特为此做了一段时间的实验(途中感谢很多网友为此‘捐’出自己的服务器)，写了以&#160;&#160;&#160;&#160; 下一篇烂文，希望能补充SQL大哥在该文中没有点明的知识点。 参考资料:《用WEB压力测试工具模拟请求服务的DOS攻击》、《WEB压力测试指南》 &#160;&#160;&#160; WEB压力测试(WebStress)一直以来都是很多IDC评测人员、网络管理员以及网络安全专家针对服务器性能的重点考察和评价的对象。今天小神有幸为某位网友的虚拟主机做个WEB压力测试(建议:压力测试通常安排在渗透测试之后)。 实验环境:被测试(服务端):WIN2000 ADVANCE SERVER + IIS + 光纤带宽测试者(客户端):WIN2000 PROFESSIONAL + MS WEB APPLICATION STRESS + 中国电信ADSL 实验目的:测试与分析WEB服务器所提供的HTTP服务的综合稳定性。 测试计划:测试类型基准(baseline):静态测试案例(HTM、JPG)[因为朋友只使用了简单的HTML]测试工具:单客户端、测试案例库，客户端程序分析手段:采用对比分析测试对象:企业级全能虚拟主机对比对象:“中资源”虚拟主机(dark2s.net)测试方案条件数值指标:*************************************************************************************Url&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 线程&#160;&#160; 持续时间&#160;&#160; 是否使用随机延迟&#160;&#160; 虚拟扼杀带宽&#160;&#160;&#160;&#160;&#160; 其他数值&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;随机遍历地址&#160;&#160;&#160; 20&#160;&#160;&#160;&#160; 5分钟&#160;&#160;&#160;&#160;&#160; 200-400(毫秒)&#160;&#160;&#160;&#160; 56K MODEM(44k)&#160;&#160; default************************************************************************************* 实验步骤:使用Web Application Stress(下称WAS)生成两个新的压力测试脚本-&#62;使用RECORD方式记录其URL-&#62;配置条件测试指标-&#62;测试-&#62;生成REPORT-&#62;以报表方式对比分析其结果 具体操作:在客户端(localhost)打开MS WEB APPLICATION STRESS主程序的菜单栏选择:&#8221;Scripts&#8221;-&#62;&#8221;Create&#8221;-&#62;&#8221;Record&#8221;，选&#8221;Record Delay between request&#8221;，按&#8221;next&#8221;。 &#8220;finish&#8221;。 接下来在弹出的浏览器的地址栏中填入你所要测试的WEB服务器地址，随机浏览几个页面，模拟正常浏览地随机使用WEB的一些功能等。最后关闭浏览器，在WAS点击&#8221;stop recording&#8221;按钮回到主界面，在主脚本显示界面的下方你会看到一个URL行为列表脚本(包括行为、URL地址、组、延迟值)，最后在主脚本显示界面的上方的&#8221;Server&#8221;输入栏中填入需要测试的主机地址。如下图: 完成上述步骤后，点击脚本列表下的&#8221;Settings&#8221;进入设置显示界面，并填入相关参数指标。 最后回到主显示界面，点击工具栏的&#8221;Run Script&#8221;进入压力测试状态。使用Active Ports查看其连接情况，从下图中不难发现WAS现在使用一个进程内的多线程针对主机进行模拟连接测试。 测试完成后点击工具栏的&#8221;Reports&#8221;按钮查看其测试报告。测试报告以树状形式分布，根以被测试服务器划分，子根为测试日期，其下的分枝部分为各类数值的分类指标值。我们要获取整个被测试服务器的宏观数值指标只需要点击测试日期“子根”就可以了。 使用与上述测试相同的步骤和参数指标‘如法炮制’剩下的那台待测服务器(因为时间的关系，小神已经预先把做好的截图放上来了:P)。 最后剩下的工作就是数据规划与对比分析了。开始时还以为需要手工做数据规划这些细腻的整理工作(小神可是出了名的老眼昏花哦!)，后来才发现WAS是带有内置数据库的(微软可不是省油的灯)。使用MS OFFICE的附属工具access打开WAS目录下的WAS.mdb数据库文件，项目中所有的测试条件数值指标与测试得出的数据都将会以‘表’的方式排布在你的面前。阁下只需要找到所需要的属性类表并轻轻一点，就一目了然了。接下来将此.mdb数据库另外保存起来，用作该次测试的初步数据分析蓝本；其后进行对比分析只需再使用access打开原来保存好的那个.mdb数据库，并通过‘子表’链接的方式把需要分析的数据类表与&#8216;Report&#8217;类表链接起来就能够轻易地进行指标数据的对比分析了。 当然，如果你的老板有什么特别需要的话，你也可以结合WORD、EXCEL等工具做出各式各样的分析报表提交上去&#8230;&#8230;后面的“东西”小神就不多说了:P。 &#160;&#160;&#160; 本文写到此处，这次简单的WEB压力测试项目就算告一段落了，当然，现实生活中的WEB压力测试并不是那么简单的(也许现实生活中的WebStress测试会做到让你发疯:P)。 最后让我们总结一下整个测试的基本步骤吧:①了解测试所使用的软件。这是测试前的准备工作 ，任何一个项目，在开始测试之前，&#160; 都应该对它有个全面的了解，如这个软件是干什么的，其功能和性能主要体现在哪几&#160; 个方面，有什么特点，如何才能体现这些特点等。②拟定测试计划。测试计划就是定义一个测试项目的过程 ，以便能够正确地度量和控&#160; 制测试。③实施测试的过程。遵照测试计划，在各种条件下，运行事先设计的测试脚本，记录We&#160; b服务器及相关客户端的性能参数。④分析测试结果。测试会收集到大量的数据，根据这些数据就可以帮助分析Web应用程&#160; 序的性能。##################################################################################################################Some Tips about WAS: 安装WAS后，每次WINDOWS在启动时都会启动一个名为&#8221;WebTool&#8221;(进程:&#8221;webtool.exe&#8221;)的服务，建议各位到“管理工具”-&#62;“服务”，把这个服务调节为“手动”，并在每次使用WAS后将该服务停止，以免长期占用阁下的系统资源。##################################################################################################################&#160;&#160;&#160; 相关测试程序Web Application Stress(WAS)可以到本人的主页http://demonalex.dark2s.org中下载。 附录:Web压力测试的基本指标列表=============================================================================================== Number of hits :测试间隔内虚拟用户点击页面的总次数 Requests per second :每秒客户端的请求次数 Threads :线程数，即虚拟用户并发量 Socket Errors Connect :Socket错误连接次数 Socket Errors Send :Socket错误发送次数 TTFB Avg :从第一个请求发出到测试工具接收到服务器应答数据的第一个字节之间的平均时间 TTLB Avg :从第一个请求发出到测试工具接收到服务器应答数据的最后一个字节之间的平均时间 根据以上数据，可以从以下几个方面分析应用程序性能，生成相应报表 : Number of hits vs. Users :随着虚拟用户的增加，服务器在规定时间内所能处理的总点击数 Requests per second vs. Users :随着虚拟用户的增加，服务器在规定时间内所能处理的每秒请求数 Errors vs. Time :随着模拟访问时间的延续，出现错误的数量 Errors vs. Users :随着虚拟用户的增加，出现错误的数量 Performance Distribution vs. Users :针对虚拟用户数的应用性能分布情况，包括服务器的内存、CPU使用情况等 Performance vs. Users :随着虚拟用户的变化，应用性能的变化===============================================================================================]]></description>
								<content:encoded><![CDATA[<div id="article_content" class="article_content clearfix">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
 <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css">
<div class="htmledit_views" id="content_views">
  <font face="宋体">writer: demonalex<br />email: demonalex_at_dark2s.org</p>
<p>前言:看完了SQL的《用WEB压力测试工具模拟请求服务的DOS攻击》，尤觉得意尤未尽，为摸清此软件的<br />&nbsp;&nbsp;&nbsp;&nbsp; 部分功能，特为此做了一段时间的实验(途中感谢很多网友为此‘捐’出自己的服务器)，写了以<br />&nbsp;&nbsp;&nbsp;&nbsp; 下一篇烂文，希望能补充SQL大哥在该文中没有点明的知识点。</p>
<p>参考资料:《用WEB压力测试工具模拟请求服务的DOS攻击》、《WEB压力测试指南》</p>
<p>&nbsp;&nbsp;&nbsp; WEB压力测试(WebStress)一直以来都是很多IDC评测人员、网络管理员以及网络安全专家针对服务器<br />性能的重点考察和评价的对象。今天小神有幸为某位网友的虚拟主机做个WEB压力测试(建议:压力测试通<br />常安排在渗透测试之后)。</p>
<p>实验环境:<br />被测试(服务端):WIN2000 ADVANCE SERVER + IIS + 光纤带宽<br />测试者(客户端):WIN2000 PROFESSIONAL + MS WEB APPLICATION STRESS + 中国电信ADSL</p>
<p>实验目的:<br />测试与分析WEB服务器所提供的HTTP服务的综合稳定性。</p>
<p>测试计划:<br />测试类型基准(baseline):静态测试案例(HTM、JPG)[因为朋友只使用了简单的HTML]<br />测试工具:单客户端、测试案例库，客户端程序<br />分析手段:采用对比分析<br />测试对象:企业级全能虚拟主机<br />对比对象:“中资源”虚拟主机(dark2s.net)<br />测试方案条件数值指标:<br />*************************************************************************************<br />Url&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程&nbsp;&nbsp; 持续时间&nbsp;&nbsp; 是否使用随机延迟&nbsp;&nbsp; 虚拟扼杀带宽&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其他数值<br />&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />随机遍历地址&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp; 5分钟&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 200-400(毫秒)&nbsp;&nbsp;&nbsp;&nbsp; 56K MODEM(44k)&nbsp;&nbsp; default<br />*************************************************************************************</p>
<p>实验步骤:<br />使用Web Application Stress(下称WAS)生成两个新的压力测试脚本-&gt;使用RECORD方式记录其URL-&gt;配置<br />条件测试指标-&gt;测试-&gt;生成REPORT-&gt;以报表方式对比分析其结果</p>
<p>具体操作:<br />在客户端(localhost)打开MS WEB APPLICATION STRESS主程序的菜单栏选择:&#8221;Scripts&#8221;-&gt;&#8221;Create&#8221;-&gt;&#8221;<br />Record&#8221;，选&#8221;Record Delay between request&#8221;，按&#8221;next&#8221;。</p>
<p><img height="155" src="http://demonalex.nease.net/webstress/0.JPG" width="418" alt=""><br />&#8220;finish&#8221;。<br /><img height="154" src="http://demonalex.nease.net/webstress/1.JPG" width="418" alt=""></p>
<p>接下来在弹出的浏览器的地址栏中填入你所要测试的WEB服务器地址，随机浏览几个页面，模拟正常浏<br />览地随机使用WEB的一些功能等。最后关闭浏览器，在WAS点击&#8221;stop recording&#8221;按钮回到主界面，在主<br />脚本显示界面的下方你会看到一个URL行为列表脚本(包括行为、URL地址、组、延迟值)，最后在主脚本<br />显示界面的上方的&#8221;Server&#8221;输入栏中填入需要测试的主机地址。如下图:<br /><img height="653" src="http://demonalex.nease.net/webstress/2.JPG" width="900" alt=""></p>
<p>完成上述步骤后，点击脚本列表下的&#8221;Settings&#8221;进入设置显示界面，并填入相关参数指标。<br /><img height="653" src="http://demonalex.nease.net/webstress/3.JPG" width="900" alt=""></p>
<p>最后回到主显示界面，点击工具栏的&#8221;Run Script&#8221;进入压力测试状态。<br /><img height="157" src="http://demonalex.nease.net/webstress/4.JPG" width="349" alt=""><br />使用Active Ports查看其连接情况，从下图中不难发现WAS现在使用一个进程内的多线程针对主机进行<br />模拟连接测试。<br /><img height="653" src="http://demonalex.nease.net/webstress/run.JPG" width="900" alt=""></p>
<p>测试完成后点击工具栏的&#8221;Reports&#8221;按钮查看其测试报告。测试报告以树状形式分布，根以被测试服务<br />器划分，子根为测试日期，其下的分枝部分为各类数值的分类指标值。我们要获取整个被测试服务器<br />的宏观数值指标只需要点击测试日期“子根”就可以了。<br /><img height="653" src="http://demonalex.nease.net/webstress/5.JPG" width="900" alt=""></p>
<p>使用与上述测试相同的步骤和参数指标‘如法炮制’剩下的那台待测服务器(因为时间的关系，小神已<br />经预先把做好的截图放上来了:P)。<br /><img height="653" src="http://demonalex.nease.net/webstress/6.JPG" width="900" alt=""></p>
<p>最后剩下的工作就是数据规划与对比分析了。开始时还以为需要手工做数据规划这些细腻的整理工作(<br />小神可是出了名的老眼昏花哦!)，后来才发现WAS是带有内置数据库的(微软可不是省油的灯)。使用MS<br /> OFFICE的附属工具access打开WAS目录下的WAS.mdb数据库文件，项目中所有的测试条件数值指标与测<br />试得出的数据都将会以‘表’的方式排布在你的面前。阁下只需要找到所需要的属性类表并轻轻一点，<br />就一目了然了。<br /><img height="653" src="http://demonalex.nease.net/webstress/7.JPG" width="900" alt=""><br />接下来将此.mdb数据库另外保存起来，用作该次测试的初步数据分析蓝本；其后进行对比分析只需再<br />使用access打开原来保存好的那个.mdb数据库，并通过‘子表’链接的方式把需要分析的数据类表与<br />&#8216;Report&#8217;类表链接起来就能够轻易地进行指标数据的对比分析了。<br /><img height="653" src="http://demonalex.nease.net/webstress/8.JPG" width="900" alt=""></p>
<p>当然，如果你的老板有什么特别需要的话，你也可以结合WORD、EXCEL等工具做出各式各样的分析报<br />表提交上去&#8230;&#8230;后面的“东西”小神就不多说了:P。</p>
<p>&nbsp;&nbsp;&nbsp; 本文写到此处，这次简单的WEB压力测试项目就算告一段落了，当然，现实生活中的WEB压力测试<br />并不是那么简单的(也许现实生活中的WebStress测试会做到让你发疯:P)。</p>
<p>最后让我们总结一下整个测试的基本步骤吧:<br />①了解测试所使用的软件。这是测试前的准备工作 ，任何一个项目，在开始测试之前，<br />&nbsp; 都应该对它有个全面的了解，如这个软件是干什么的，其功能和性能主要体现在哪几<br />&nbsp; 个方面，有什么特点，如何才能体现这些特点等。<br />②拟定测试计划。测试计划就是定义一个测试项目的过程 ，以便能够正确地度量和控<br />&nbsp; 制测试。<br />③实施测试的过程。遵照测试计划，在各种条件下，运行事先设计的测试脚本，记录We<br />&nbsp; b服务器及相关客户端的性能参数。<br />④分析测试结果。测试会收集到大量的数据，根据这些数据就可以帮助分析Web应用程<br />&nbsp; 序的性能。<br />##################################################################################################################<br />Some Tips about WAS:</p>
<p>安装WAS后，每次WINDOWS在启动时都会启动一个名为&#8221;WebTool&#8221;(进程:&#8221;webtool.exe&#8221;)的服务，建议各<br />位到“管理工具”-&gt;“服务”，把这个服务调节为“手动”，并在每次使用WAS后将该服务停止，以免<br />长期占用阁下的系统资源。<br />##################################################################################################################<br />&nbsp;&nbsp;&nbsp; 相关测试程序Web Application Stress(WAS)可以到本人的主页http://demonalex.dark2s.org中<br />下载。</p>
<p>附录:Web压力测试的基本指标列表<br />===============================================================================================<br /></font><br />
  <font face="Impact">Number of hits</font><br />
  <font face="宋体">:测试间隔内虚拟用户点击页面的总次数<br /></font><br />
  <font face="Impact">Requests per second</font><br />
  <font face="宋体">:每秒客户端的请求次数<br /></font><br />
  <font face="Impact">Threads</font><br />
  <font face="宋体">:线程数，即虚拟用户并发量<br /></font><br />
  <font face="Impact">Socket Errors Connect</font><br />
  <font face="宋体">:Socket错误连接次数<br /></font><br />
  <font face="Impact">Socket Errors Send</font><br />
  <font face="宋体">:Socket错误发送次数<br /></font><br />
  <font face="Impact">TTFB Avg</font><br />
  <font face="宋体">:从第一个请求发出到测试工具接收到服务器应答数据的第一个字节之间的平均<br />时间<br /></font><br />
  <font face="Impact">TTLB Avg</font><br />
  <font face="宋体">:从第一个请求发出到测试工具接收到服务器应答数据的最后一个字节之间的平<br />均时间<br /></font><br />
  <b><br /><font face="宋体">根据以上数据，可以从以下几个方面分析应用程序性能，生成相应报表</font></b><br />
  <font face="宋体">:<br /></font><br />
  <font face="Impact">Number of hits vs. Users</font><br />
  <font face="宋体">:随着虚拟用户的增加，服务器在规定时间内所能处理的总点<br />击数<br /></font><br />
  <font face="Impact">Requests per second vs. Users</font><br />
  <font face="宋体">:随着虚拟用户的增加，服务器在规定时间内所能处理<br />的每秒请求数<br /></font><br />
  <font face="Impact">Errors vs. Time</font><br />
  <font face="宋体">:随着模拟访问时间的延续，出现错误的数量<br /></font><br />
  <font face="Impact">Errors vs. Users</font><br />
  <font face="宋体">:随着虚拟用户的增加，出现错误的数量 <br /></font><br />
  <font face="Impact">Performance Distribution vs. Users</font><br />
  <font face="宋体">:针对虚拟用户数的应用性能分布情况，包括服务<br />器的内存、CPU使用情况等 <br /></font><br />
  <font face="Impact">Performance vs. Users</font><br />
  <font face="宋体">:随着虚拟用户的变化，应用性能的变化<br />===============================================================================================</font>
 </div>
</div>
]]></content:encoded>
										</item>
	</channel>
</rss>
